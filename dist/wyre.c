// Generated by Muon compiler, version 0.3.7
#include "external.h"
// GENERAL DEFS
#ifdef _MSC_VER // for MSVC compatibility
#define _Thread_local __declspec(thread)
#define _Static_assert static_assert
#endif
_Static_assert(sizeof(uintptr_t) == 8, "Must use 64-bit output target");
typedef void void__;
typedef int8_t sbyte__;
typedef uint8_t byte__;
typedef int16_t short__;
typedef uint16_t ushort__;
typedef int32_t int__;
typedef uint32_t uint__;
typedef int64_t long__;
typedef uint64_t ulong__;
typedef int64_t ssize__;
typedef uint64_t usize__;
#ifdef _MSC_VER
typedef struct __declspec(align(16)) tag_____s128__ { uint64_t lo; int64_t hi; } s128__;
#else
typedef __int128 s128__;
#endif
typedef float float__;
typedef double double__;
typedef uint8_t bool__;
typedef uint32_t bool32__;
typedef char char__;
typedef uint8_t* pointer__;
typedef struct { pointer__ dataPtr__; int__ length__; } string__;
typedef char* cstring__;
#define null__ NULL
#define false__ 0
#define true__ 1
#define mu_____abandon(x) { top_____abandonFn__(x); }
#define mu_____assert(x) { if (!(x)) { top_____abandonFn__(-2); } }
#define mu_____boundscheck(x) { if (!(x)) { top_____abandonFn__(-3); } }
#define mu_____checkedcast(x) { if (!(x)) { top_____abandonFn__(-4); } }
#define mu_____nomatch() { top_____abandonFn__(-5); }
// STRING TABLE
string__ mu_____string0 = { (pointer__)"", 0 };
string__ mu_____string62 = { (pointer__)"Expected: statement", 19 };
string__ mu_____string52 = { (pointer__)"Value does not fit into suffix type", 35 };
string__ mu_____string41 = { (pointer__)"!=", 2 };
string__ mu_____string151 = { (pointer__)"Don't care values are not allowed here", 38 };
string__ mu_____string244 = { (pointer__)"[{}:0] ", 7 };
string__ mu_____string18 = { (pointer__)"if", 2 };
string__ mu_____string186 = { (pointer__)"Top module input cannot be static", 33 };
string__ mu_____string129 = { (pointer__)"Expected: <=", 12 };
string__ mu_____string139 = { (pointer__)"Expected: register, register.field or slice(...)", 48 };
string__ mu_____string210 = { (pointer__)"jump", 4 };
string__ mu_____string93 = { (pointer__)"--version", 9 };
string__ mu_____string45 = { (pointer__)">=", 2 };
string__ mu_____string73 = { (pointer__)"(", 1 };
string__ mu_____string225 = { (pointer__)"lte", 3 };
string__ mu_____string13 = { (pointer__)"{", 1 };
string__ mu_____string159 = { (pointer__)"Cannot apply operator {} to arguments of type {} and {}", 55 };
string__ mu_____string11 = { (pointer__)"struct", 6 };
string__ mu_____string43 = { (pointer__)">", 1 };
string__ mu_____string100 = { (pointer__)"--indent [number]", 17 };
string__ mu_____string171 = { (pointer__)"Index out of range: must be lower than first value", 50 };
string__ mu_____string81 = { (pointer__)"\x09""", 1 };
string__ mu_____string249 = { (pointer__)"{}", 2 };
string__ mu_____string212 = { (pointer__)"dup", 3 };
string__ mu_____string273 = { (pointer__)" }", 2 };
string__ mu_____string67 = { (pointer__)"Incorrect indentation: close brace must be indented more", 56 };
string__ mu_____string256 = { (pointer__)"'b", 2 };
string__ mu_____string25 = { (pointer__)"Expected: expression", 20 };
string__ mu_____string122 = { (pointer__)"Expected: out", 13 };
string__ mu_____string162 = { (pointer__)"Expected: expression of type $module_out", 40 };
string__ mu_____string205 = { (pointer__)"store", 5 };
string__ mu_____string259 = { (pointer__)") ", 2 };
string__ mu_____string141 = { (pointer__)"Expected: {} args but got {} args", 33 };
string__ mu_____string2 = { (pointer__)"-", 1 };
string__ mu_____string48 = { (pointer__)"|", 1 };
string__ mu_____string193 = { (pointer__)"Expected: field name", 20 };
string__ mu_____string135 = { (pointer__)"Clock statements may not be nested", 34 };
string__ mu_____string16 = { (pointer__)"identifier", 10 };
string__ mu_____string115 = { (pointer__)"${}", 3 };
string__ mu_____string211 = { (pointer__)"nop", 3 };
string__ mu_____string148 = { (pointer__)"Recursive reference to {}", 25 };
string__ mu_____string85 = { (pointer__)"--output", 8 };
string__ mu_____string138 = { (pointer__)"Expected: register of type struct", 33 };
string__ mu_____string222 = { (pointer__)"eq", 2 };
string__ mu_____string87 = { (pointer__)"--indent", 8 };
string__ mu_____string229 = { (pointer__)"shr", 3 };
string__ mu_____string243 = { (pointer__)"input ", 6 };
string__ mu_____string34 = { (pointer__)"]", 1 };
string__ mu_____string71 = { (pointer__)"module input declaration", 24 };
string__ mu_____string97 = { (pointer__)"One or more source files", 24 };
string__ mu_____string276 = { (pointer__)" <= ", 4 };
string__ mu_____string287 = { (pointer__)"Generated output: {}", 20 };
string__ mu_____string278 = { (pointer__)"#(", 2 };
string__ mu_____string20 = { (pointer__)"zx", 2 };
string__ mu_____string181 = { (pointer__)"Expected: constant; must be a divisor of step size", 50 };
string__ mu_____string27 = { (pointer__)"slice", 5 };
string__ mu_____string8 = { (pointer__)"rb", 2 };
string__ mu_____string46 = { (pointer__)"&", 1 };
string__ mu_____string116 = { (pointer__)"$*", 2 };
string__ mu_____string94 = { (pointer__)"--help", 6 };
string__ mu_____string112 = { (pointer__)"Statement must be placed inside clock statement", 47 };
string__ mu_____string180 = { (pointer__)"swizzle() can only be used in static initializer", 48 };
string__ mu_____string60 = { (pointer__)"out", 3 };
string__ mu_____string14 = { (pointer__)"posedge", 7 };
string__ mu_____string29 = { (pointer__)"swizzle", 7 };
string__ mu_____string127 = { (pointer__)"Cannot assign expression to blackbox output", 43 };
string__ mu_____string51 = { (pointer__)"Invalid binary value", 20 };
string__ mu_____string6 = { (pointer__)"%.*s", 4 };
string__ mu_____string30 = { (pointer__)":", 1 };
string__ mu_____string140 = { (pointer__)"slice() can only be used in static initializer or in simulator", 62 };
string__ mu_____string153 = { (pointer__)"Cannot apply operator {} to argument of type {} and target of type {}", 69 };
string__ mu_____string216 = { (pointer__)"add", 3 };
string__ mu_____string65 = { (pointer__)"Expected: {}, or: close brace must be indented less", 51 };
string__ mu_____string261 = { (pointer__)") ? (", 5 };
string__ mu_____string113 = { (pointer__)"Expected: = or <=", 17 };
string__ mu_____string233 = { (pointer__)"begin", 5 };
string__ mu_____string240 = { (pointer__)"// Generated by Wyre compiler {}\x0a""", 33 };
string__ mu_____string91 = { (pointer__)"--max-errors", 12 };
string__ mu_____string32 = { (pointer__)")", 1 };
string__ mu_____string142 = { (pointer__)"Expected: expression of fixed width numeric type", 48 };
string__ mu_____string23 = { (pointer__)"Expected: case item, or: close brace must be indented less", 58 };
string__ mu_____string56 = { (pointer__)"---", 3 };
string__ mu_____string187 = { (pointer__)"Blackbox module input must be of fixed numeric type", 51 };
string__ mu_____string257 = { (pointer__)"x", 1 };
string__ mu_____string49 = { (pointer__)"?", 1 };
string__ mu_____string144 = { (pointer__)"Expected: constant", 18 };
string__ mu_____string255 = { (pointer__)"if (", 4 };
string__ mu_____string268 = { (pointer__)") == ", 5 };
string__ mu_____string184 = { (pointer__)"Target type size must be a multiple of 8", 40 };
string__ mu_____string66 = { (pointer__)"Incorrect indentation: must match previous {}", 45 };
string__ mu_____string92 = { (pointer__)"Expected: number, > 0", 21 };
string__ mu_____string132 = { (pointer__)"Struct must define at least one field", 37 };
string__ mu_____string231 = { (pointer__)"module", 6 };
string__ mu_____string88 = { (pointer__)"number", 6 };
string__ mu_____string22 = { (pointer__)"Expected: newline", 17 };
string__ mu_____string183 = { (pointer__)"Expected: constant; must be a divisor of target type size", 57 };
string__ mu_____string195 = { (pointer__)"Undefined input: {}.{}", 22 };
string__ mu_____string269 = { (pointer__)") :", 3 };
string__ mu_____string79 = { (pointer__)"\"", 1 };
string__ mu_____string125 = { (pointer__)"Expected: expression of fixed width numeric type or struct type or module", 73 };
string__ mu_____string218 = { (pointer__)"and", 3 };
string__ mu_____string33 = { (pointer__)"}", 1 };
string__ mu_____string263 = { (pointer__)"wire ", 5 };
string__ mu_____string279 = { (pointer__)");", 2 };
string__ mu_____string248 = { (pointer__)"{}'d{}", 6 };
string__ mu_____string1 = { (pointer__)"0", 1 };
string__ mu_____string58 = { (pointer__)"Expected: hexadecimal byte value", 32 };
string__ mu_____string24 = { (pointer__)"Incorrect indentation: must match previous case", 47 };
string__ mu_____string238 = { (pointer__)"case", 4 };
string__ mu_____string282 = { (pointer__)"For documentation, see: https://github.com/nickmqb/wyre", 55 };
string__ mu_____string283 = { (pointer__)"Top module not found: {}", 24 };
string__ mu_____string201 = { (pointer__)"Logic loop detected", 19 };
string__ mu_____string134 = { (pointer__)"Expected: fixed width numeric type", 34 };
string__ mu_____string158 = { (pointer__)"Cannot convert operand to type {}", 33 };
string__ mu_____string182 = { (pointer__)"Expected: constant; must be a divisor of block size", 51 };
string__ mu_____string179 = { (pointer__)"Unsupported expression: cannot use swizzle() in constant initializer", 68 };
string__ mu_____string38 = { (pointer__)">>", 2 };
string__ mu_____string164 = { (pointer__)"Cannot unify values of type {} and {}", 37 };
string__ mu_____string40 = { (pointer__)"==", 2 };
string__ mu_____string72 = { (pointer__)"Expected: module input declaration", 34 };
string__ mu_____string155 = { (pointer__)"Cannot apply operator {} to argument of type {}", 47 };
string__ mu_____string199 = { (pointer__)"{}.{}", 5 };
string__ mu_____string265 = { (pointer__)";", 1 };
string__ mu_____string274 = { (pointer__)"end else begin", 14 };
string__ mu_____string277 = { (pointer__)"(* keep *) ", 11 };
string__ mu_____string242 = { (pointer__)"\x0a""", 1 };
string__ mu_____string3 = { (pointer__)"%.17g", 5 };
string__ mu_____string118 = { (pointer__)"[unknown]", 9 };
string__ mu_____string128 = { (pointer__)"out keyword can only be used with register or wire declaration", 62 };
string__ mu_____string185 = { (pointer__)"Cannot simulate blackbox module", 31 };
string__ mu_____string188 = { (pointer__)"Recursive reference to module: {}", 33 };
string__ mu_____string50 = { (pointer__)"case item", 9 };
string__ mu_____string252 = { (pointer__)");\x0a""", 3 };
string__ mu_____string253 = { (pointer__)"always @(", 9 };
string__ mu_____string267 = { (pointer__)"(((", 3 };
string__ mu_____string63 = { (pointer__)"Expected: field declaration", 27 };
string__ mu_____string227 = { (pointer__)"gte", 3 };
string__ mu_____string10 = { (pointer__)"0.1.1", 5 };
string__ mu_____string95 = { (pointer__)"Invalid flag: {}", 16 };
string__ mu_____string224 = { (pointer__)"lt", 2 };
string__ mu_____string35 = { (pointer__)".", 1 };
string__ mu_____string166 = { (pointer__)"Expected: numeric constant", 26 };
string__ mu_____string197 = { (pointer__)", ", 2 };
string__ mu_____string254 = { (pointer__)") begin", 7 };
string__ mu_____string99 = { (pointer__)"--output [path]", 15 };
string__ mu_____string157 = { (pointer__)"Unsupported expression: cannot apply operator {} to arguments of type {} and {}", 79 };
string__ mu_____string104 = { (pointer__)"A symbol with the same name has already been defined", 52 };
string__ mu_____string42 = { (pointer__)"<", 1 };
string__ mu_____string156 = { (pointer__)"Invalid unary operator: {}", 26 };
string__ mu_____string230 = { (pointer__)"storeSlice", 10 };
string__ mu_____string47 = { (pointer__)"^", 1 };
string__ mu_____string77 = { (pointer__)"Unexpected token(s)", 19 };
string__ mu_____string236 = { (pointer__)"output", 6 };
string__ mu_____string198 = { (pointer__)"Missing required parameters: {}", 31 };
string__ mu_____string175 = { (pointer__)"Unsupported expression: cannot use chunk() in constant initializer", 66 };
string__ mu_____string264 = { (pointer__)"local", 5 };
string__ mu_____string143 = { (pointer__)"Expected: expression of numeric type", 36 };
string__ mu_____string168 = { (pointer__)"Unsupported expression: cannot index argument of type {}", 56 };
string__ mu_____string110 = { (pointer__)"Expected: identifier", 20 };
string__ mu_____string117 = { (pointer__)"[{}]", 4 };
string__ mu_____string17 = { (pointer__)"statement", 9 };
string__ mu_____string200 = { (pointer__)"{}_{}", 5 };
string__ mu_____string217 = { (pointer__)"sub", 3 };
string__ mu_____string258 = { (pointer__)"1", 1 };
string__ mu_____string203 = { (pointer__)"pushArray", 9 };
string__ mu_____string126 = { (pointer__)"Blackbox module output must be of fixed numeric type", 52 };
string__ mu_____string149 = { (pointer__)"Recursive reference to const: {}", 32 };
string__ mu_____string190 = { (pointer__)"Expected: module or function name", 33 };
string__ mu_____string106 = { (pointer__)"Undefined type: {}", 18 };
string__ mu_____string192 = { (pointer__)"Field has already been specified", 32 };
string__ mu_____string137 = { (pointer__)"Undefined field: {}.{}", 22 };
string__ mu_____string86 = { (pointer__)"path", 4 };
string__ mu_____string165 = { (pointer__)"Cannot convert constant of type {} to {}", 40 };
string__ mu_____string223 = { (pointer__)"neq", 3 };
string__ mu_____string55 = { (pointer__)"Invalid decimal value", 21 };
string__ mu_____string9 = { (pointer__)"wb", 2 };
string__ mu_____string36 = { (pointer__)"*", 1 };
string__ mu_____string214 = { (pointer__)"neg", 3 };
string__ mu_____string286 = { (pointer__)"Could not write to output file: {}", 34 };
string__ mu_____string37 = { (pointer__)"<<", 2 };
string__ mu_____string177 = { (pointer__)"Expected: constant; must be lower than number of chunks", 55 };
string__ mu_____string124 = { (pointer__)"out keyword can only be used with wire of fixed with numeric type or struct type", 80 };
string__ mu_____string64 = { (pointer__)"field type", 10 };
string__ mu_____string69 = { (pointer__)"blackbox", 8 };
string__ mu_____string83 = { (pointer__)"--top", 5 };
string__ mu_____string272 = { (pointer__)"{ ", 2 };
string__ mu_____string136 = { (pointer__)"Expected: expression of type $1", 31 };
string__ mu_____string82 = { (pointer__)"    ", 4 };
string__ mu_____string103 = { (pointer__)"{}{}\x0a""{}\x0a""{}{}", 12 };
string__ mu_____string120 = { (pointer__)"Expected: expression of fixed width numeric type or struct", 58 };
string__ mu_____string5 = { (pointer__)"false", 5 };
string__ mu_____string26 = { (pointer__)"rep", 3 };
string__ mu_____string57 = { (pointer__)"~", 1 };
string__ mu_____string54 = { (pointer__)"Invalid hexadecimal value", 25 };
string__ mu_____string107 = { (pointer__)"Expected: expression that evaluates to constant during initialization", 69 };
string__ mu_____string111 = { (pointer__)"=", 1 };
string__ mu_____string173 = { (pointer__)"Expected: constant, > 0", 23 };
string__ mu_____string105 = { (pointer__)"Invalid name; must start with letter, _ or #", 44 };
string__ mu_____string206 = { (pointer__)"mask", 4 };
string__ mu_____string176 = { (pointer__)"chunk() can only be used in static initializer", 46 };
string__ mu_____string96 = { (pointer__)"Could not read file: {}", 23 };
string__ mu_____string239 = { (pointer__)"_", 1 };
string__ mu_____string226 = { (pointer__)"gt", 2 };
string__ mu_____string119 = { (pointer__)"Expected: fixed width numeric type or struct type", 49 };
string__ mu_____string235 = { (pointer__)"input", 5 };
string__ mu_____string209 = { (pointer__)"jumpIfZero", 10 };
string__ mu_____string169 = { (pointer__)"Cannot index argument of type {}", 32 };
string__ mu_____string78 = { (pointer__)" ", 1 };
string__ mu_____string150 = { (pointer__)"Expected: register, wire or constant", 36 };
string__ mu_____string170 = { (pointer__)"Index out of range", 18 };
string__ mu_____string213 = { (pointer__)"discard", 7 };
string__ mu_____string121 = { (pointer__)"Expected: type", 14 };
string__ mu_____string84 = { (pointer__)"module name", 11 };
string__ mu_____string196 = { (pointer__)"Expected: parameter name", 24 };
string__ mu_____string219 = { (pointer__)"or", 2 };
string__ mu_____string220 = { (pointer__)"xor", 3 };
string__ mu_____string221 = { (pointer__)"mul", 3 };
string__ mu_____string70 = { (pointer__)"input type", 10 };
string__ mu_____string75 = { (pointer__)"Expected: struct, const or module declaration", 45 };
string__ mu_____string262 = { (pointer__)") : (", 5 };
string__ mu_____string266 = { (pointer__)"assign ", 7 };
string__ mu_____string275 = { (pointer__)"(* keep *) reg ", 15 };
string__ mu_____string61 = { (pointer__)"reg", 3 };
string__ mu_____string21 = { (pointer__)"match", 5 };
string__ mu_____string114 = { (pointer__)"Cannot assign {} to {}", 22 };
string__ mu_____string147 = { (pointer__)"wire", 4 };
string__ mu_____string152 = { (pointer__)"Unsupported expression: cannot apply operator {} to argument of type {}", 71 };
string__ mu_____string178 = { (pointer__)"Expected: constant; must be a divisor of target type {}", 55 };
string__ mu_____string191 = { (pointer__)"Expected: struct type", 21 };
string__ mu_____string101 = { (pointer__)"--max-errors [number]", 21 };
string__ mu_____string232 = { (pointer__)"endmodule", 9 };
string__ mu_____string280 = { (pointer__)"\x0a""endmodule\x0a""", 11 };
string__ mu_____string215 = { (pointer__)"invert", 6 };
string__ mu_____string251 = { (pointer__)" = 0", 4 };
string__ mu_____string167 = { (pointer__)"Must match type of previous case", 32 };
string__ mu_____string39 = { (pointer__)"+", 1 };
string__ mu_____string207 = { (pointer__)"index", 5 };
string__ mu_____string208 = { (pointer__)"shlOr", 5 };
string__ mu_____string234 = { (pointer__)"end", 3 };
string__ mu_____string245 = { (pointer__)"output ", 7 };
string__ mu_____string281 = { (pointer__)"Wyre compiler, version {}", 25 };
string__ mu_____string44 = { (pointer__)"<=", 2 };
string__ mu_____string53 = { (pointer__)"Invalid suffix type", 19 };
string__ mu_____string68 = { (pointer__)"field declaration", 17 };
string__ mu_____string133 = { (pointer__)"Field type cannot be larger than $64", 36 };
string__ mu_____string98 = { (pointer__)"--top [module]", 14 };
string__ mu_____string228 = { (pointer__)"shl", 3 };
string__ mu_____string247 = { (pointer__)" = ", 3 };
string__ mu_____string89 = { (pointer__)"Expected: number", 16 };
string__ mu_____string271 = { (pointer__)"[", 1 };
string__ mu_____string130 = { (pointer__)"Expected: register", 18 };
string__ mu_____string146 = { (pointer__)"register", 8 };
string__ mu_____string28 = { (pointer__)"chunk", 5 };
string__ mu_____string172 = { (pointer__)"Unsupported expression; type of expression cannot be larger than $64", 68 };
string__ mu_____string123 = { (pointer__)"Expected: :=", 12 };
string__ mu_____string31 = { (pointer__)",", 1 };
string__ mu_____string250 = { (pointer__)"{}'h", 4 };
string__ mu_____string108 = { (pointer__)"Statement is not allowed inside blackbox module", 47 };
string__ mu_____string154 = { (pointer__)"Cannot apply operator {} because target type is inferred", 56 };
string__ mu_____string194 = { (pointer__)"Input has already been specified", 32 };
string__ mu_____string163 = { (pointer__)"Cannot convert {} to {}", 23 };
string__ mu_____string90 = { (pointer__)"Expected: number, >= 0", 22 };
string__ mu_____string15 = { (pointer__)"negedge", 7 };
string__ mu_____string7 = { (pointer__)"%.*s\x0a""", 5 };
string__ mu_____string161 = { (pointer__)"Undefined output: {}.{}", 23 };
string__ mu_____string76 = { (pointer__)"Incorrect indentation: top-level declaration may not be indented", 64 };
string__ mu_____string160 = { (pointer__)"Invalid binary operator: {}", 27 };
string__ mu_____string202 = { (pointer__)"push", 4 };
string__ mu_____string102 = { (pointer__)"\x0a""-> {}:{}", 9 };
string__ mu_____string237 = { (pointer__)"inout", 5 };
string__ mu_____string109 = { (pointer__)"Invalid name; must start with letter or _", 41 };
string__ mu_____string4 = { (pointer__)"true", 4 };
string__ mu_____string174 = { (pointer__)"Cannot use slice() in constant initializer", 42 };
string__ mu_____string12 = { (pointer__)"Expected: {}", 12 };
string__ mu_____string145 = { (pointer__)"Expected: constant between 1 and 64 inclusive", 45 };
string__ mu_____string204 = { (pointer__)"load", 4 };
string__ mu_____string19 = { (pointer__)"expression", 10 };
string__ mu_____string284 = { (pointer__)"{} errors ({} shown)", 20 };
string__ mu_____string246 = { (pointer__)"reg ", 4 };
string__ mu_____string59 = { (pointer__)"else", 4 };
string__ mu_____string74 = { (pointer__)":=", 2 };
string__ mu_____string131 = { (pointer__)"Undefined symbol: {}", 20 };
string__ mu_____string285 = { (pointer__)"{} errors", 9 };
string__ mu_____string80 = { (pointer__)"{}\x0a""{}\x0a""{}{}", 10 };
string__ mu_____string189 = { (pointer__)"Expected: module name", 21 };
string__ mu_____string260 = { (pointer__)" (", 2 };
string__ mu_____string270 = { (pointer__)"{}'b{}", 6 };
string__ mu_____string241 = { (pointer__)"\x0a""module ", 8 };
// FORWARD TYPES
typedef struct tag_____MapEntry__string__Ptr__FieldDef______ MapEntry__string__Ptr__FieldDef______;
typedef struct tag_____MapEntry__Node__Tag____ MapEntry__Node__Tag____;
typedef struct tag_____MapEntry__Node__int____ MapEntry__Node__int____;
typedef struct tag_____MapEntry__string__Node____ MapEntry__string__Node____;
typedef struct tag_____MapEntry__Node__Value____ MapEntry__Node__Value____;
typedef struct tag_____MapEntry__NodeWithCtx__string____ MapEntry__NodeWithCtx__string____;
typedef struct tag_____Instruction__ Instruction__;
typedef struct tag_____Block__ Block__;
typedef uint32_t ConstFlags__;
typedef uint32_t CompilationFlags__;
typedef struct tag_____SlotInfo__ SlotInfo__;
typedef struct tag_____ModuleInputDef__ ModuleInputDef__;
typedef struct tag_____TernaryOperatorExpression__ TernaryOperatorExpression__;
typedef struct tag_____StructDef__ StructDef__;
typedef struct tag_____IAllocator__ IAllocator__;
typedef struct tag_____IntRange__ IntRange__;
typedef struct { int__ id__; pointer__ dataPtr__; } Node__;
#define Node_____Ptr__BinaryOperatorExpression____ 1
#define Node_____Ptr__TernaryOperatorExpression____ 2
#define Node_____Ptr__MatchExpression____ 3
#define Node_____Ptr__MatchExpressionCase____ 4
#define Node_____Ptr__CallExpression____ 5
#define Node_____Ptr__StructInitializerExpression____ 6
#define Node_____Ptr__IndexExpression____ 7
#define Node_____Ptr__NumberExpression____ 8
#define Node_____Ptr__ParenExpression____ 9
#define Node_____Ptr__Block____ 10
#define Node_____Ptr__AssignStatement____ 11
#define Node_____Ptr__ClockStatement____ 12
#define Node_____Ptr__IfStatement____ 13
#define Node_____Ptr__UnaryOperatorExpression____ 14
#define Node_____Ptr__CodeUnit____ 15
#define Node_____Ptr__BraceExpression____ 16
#define Node_____Ptr__ArrayExpression____ 17
#define Node_____Ptr__Token____ 18
#define Node_____Ptr__ConstDef____ 19
#define Node_____Ptr__StructDef____ 20
#define Node_____Ptr__FieldDef____ 21
#define Node_____Ptr__ModuleDef____ 22
#define Node_____Ptr__ModuleInputDef____ 23
#define Node_____Ptr__DotExpression____ 24
typedef struct tag_____Tag__ Tag__;
typedef struct tag_____MatchExpression__ MatchExpression__;
typedef struct tag_____CallArg__ CallArg__;
typedef struct tag_____BinaryOperatorExpression__ BinaryOperatorExpression__;
typedef struct tag_____Result__string____ Result__string____;
typedef uint32_t Opcode__;
typedef struct tag_____QueuedCallArgs__ QueuedCallArgs__;
typedef struct tag_____Maybe__uint____ Maybe__uint____;
typedef struct tag_____Maybe__string____ Maybe__string____;
typedef struct tag_____Maybe__long____ Maybe__long____;
typedef struct tag_____Maybe__int____ Maybe__int____;
typedef struct tag_____Maybe__ulong____ Maybe__ulong____;
typedef struct tag_____Map__NodeWithCtx__string____ Map__NodeWithCtx__string____;
typedef struct tag_____Map__string__Ptr__FieldDef______ Map__string__Ptr__FieldDef______;
typedef struct tag_____Map__string__Node____ Map__string__Node____;
typedef struct tag_____Map__Node__int____ Map__Node__int____;
typedef struct tag_____Map__Node__Value____ Map__Node__Value____;
typedef struct tag_____Map__Node__Tag____ Map__Node__Tag____;
typedef struct tag_____ParseState__ ParseState__;
typedef struct tag_____ModuleDef__ ModuleDef__;
typedef struct tag_____Args__ Args__;
typedef struct tag_____SetEntry__string____ SetEntry__string____;
typedef struct tag_____ArenaAllocator__ ArenaAllocator__;
typedef struct tag_____DotExpression__ DotExpression__;
typedef struct tag_____NumberExpression__ NumberExpression__;
typedef struct tag_____Value__ Value__;
typedef struct tag_____ConstDef__ ConstDef__;
typedef uint32_t ValueKind__;
typedef struct tag_____ParenExpression__ ParenExpression__;
typedef struct tag_____SourceFile__ SourceFile__;
typedef struct tag_____CommandLineArgsParser__ CommandLineArgsParser__;
typedef uint32_t StructFlags__;
typedef struct tag_____Compilation__ Compilation__;
typedef struct tag_____FieldDef__ FieldDef__;
typedef struct tag_____BraceExpression__ BraceExpression__;
typedef struct tag_____StringBuilder__ StringBuilder__;
typedef uint32_t AssignFlags__;
typedef struct tag_____CallExpression__ CallExpression__;
typedef struct tag_____UnaryOperatorExpression__ UnaryOperatorExpression__;
typedef struct tag_____EmulatorState__ EmulatorState__;
typedef struct tag_____TypeCheckResult__ TypeCheckResult__;
typedef struct tag_____StructInitializerExpression__ StructInitializerExpression__;
typedef struct tag_____CommandLineArgsParserError__ CommandLineArgsParserError__;
typedef struct tag_____LocationInfo__ LocationInfo__;
typedef uint32_t TagKind__;
typedef struct tag_____IndexExpression__ IndexExpression__;
typedef uint32_t BuiltinCall__;
typedef struct tag_____List__Ptr__AssignStatement______ List__Ptr__AssignStatement______;
typedef struct tag_____List__Error____ List__Error____;
typedef struct tag_____List__Ptr__MatchExpressionCase______ List__Ptr__MatchExpressionCase______;
typedef struct tag_____List__Ptr__CallArg______ List__Ptr__CallArg______;
typedef struct tag_____List__QueuedCallArgs____ List__QueuedCallArgs____;
typedef struct tag_____List__byte____ List__byte____;
typedef struct tag_____List__Ptr__ModuleInstance______ List__Ptr__ModuleInstance______;
typedef struct tag_____List__Node____ List__Node____;
typedef struct tag_____List__SlotInfo____ List__SlotInfo____;
typedef struct tag_____List__int____ List__int____;
typedef struct tag_____List__Instruction____ List__Instruction____;
typedef struct tag_____List__Value____ List__Value____;
typedef struct tag_____List__string____ List__string____;
typedef struct tag_____List__Ptr__SourceFile______ List__Ptr__SourceFile______;
typedef struct tag_____List__Ptr__CodeUnit______ List__Ptr__CodeUnit______;
typedef struct tag_____List__CommandLineArgsParserError____ List__CommandLineArgsParserError____;
typedef struct tag_____List__Ptr__FieldDef______ List__Ptr__FieldDef______;
typedef struct tag_____List__Ptr__ModuleInputDef______ List__Ptr__ModuleInputDef______;
typedef struct tag_____Set__string____ Set__string____;
typedef uint32_t TokenType__;
typedef struct tag_____ArrayExpression__ ArrayExpression__;
typedef struct tag_____AssignStatement__ AssignStatement__;
typedef struct tag_____NodeWithCtx__ NodeWithCtx__;
typedef struct tag_____RangeFinderState__ RangeFinderState__;
typedef struct tag_____ClockStatement__ ClockStatement__;
typedef uint32_t ModuleFlags__;
typedef struct tag_____Array__IntRange____ Array__IntRange____;
typedef struct tag_____Array__Error____ Array__Error____;
typedef struct tag_____Array__int____ Array__int____;
typedef struct tag_____Array__byte____ Array__byte____;
typedef struct tag_____Array__SetEntry__string______ Array__SetEntry__string______;
typedef struct tag_____Array__MapEntry__NodeWithCtx__string______ Array__MapEntry__NodeWithCtx__string______;
typedef struct tag_____Array__MapEntry__Node__Value______ Array__MapEntry__Node__Value______;
typedef struct tag_____Array__MapEntry__Node__int______ Array__MapEntry__Node__int______;
typedef struct tag_____Array__MapEntry__string__Node______ Array__MapEntry__string__Node______;
typedef struct tag_____Array__MapEntry__string__Ptr__FieldDef________ Array__MapEntry__string__Ptr__FieldDef________;
typedef struct tag_____Array__MapEntry__Node__Tag______ Array__MapEntry__Node__Tag______;
typedef struct tag_____Array__string____ Array__string____;
typedef struct tag_____Array__bool____ Array__bool____;
typedef struct tag_____Array__cstring____ Array__cstring____;
typedef struct tag_____MatchExpressionCase__ MatchExpressionCase__;
typedef uint32_t ParseCommaListState__;
typedef struct tag_____GeneratorState__ GeneratorState__;
typedef struct tag_____Token__ Token__;
typedef struct tag_____TypeCheckerContext__ TypeCheckerContext__;
typedef struct tag_____ModuleInstance__ ModuleInstance__;
typedef struct tag_____CommandLineInfo__ CommandLineInfo__;
typedef struct tag_____TypeCheckerState__ TypeCheckerState__;
typedef struct tag_____IndexerState__ IndexerState__;
typedef struct tag_____Error__ Error__;
typedef uint32_t NumberFlags__;
typedef struct tag_____CodeBuilder__ CodeBuilder__;
typedef struct tag_____CodeUnit__ CodeUnit__;
typedef uint32_t ModuleInputFlags__;
typedef struct tag_____IfStatement__ IfStatement__;
typedef pointer__ (*fun__Ptr__ArenaAllocator____pointer__ssize__ssize__ssize__pointer____)(ArenaAllocator__*, pointer__, ssize__, ssize__, ssize__);
typedef void__ (*fun__int__void____)(int__);
typedef pointer__ (*fun__Ptr__ArenaAllocator____ssize__pointer____)(ArenaAllocator__*, ssize__);
typedef pointer__ (*fun__pointer__ssize__pointer____)(pointer__, ssize__);
typedef void__ (*fun__pointer__pointer__void____)(pointer__, pointer__);
typedef int__ (*fun__Error__Error__int____)(Error__, Error__);
typedef pointer__ (*fun__pointer__pointer__ssize__ssize__ssize__pointer____)(pointer__, pointer__, ssize__, ssize__, ssize__);
// STRUCTS
typedef struct tag_____MapEntry__string__Ptr__FieldDef______ {
	uint__ hash__;
	string__ key__;
	FieldDef__* value__;
} MapEntry__string__Ptr__FieldDef______;
typedef struct tag_____Tag__ {
	TagKind__ kind__;
	int__ q__;
} Tag__;
typedef struct tag_____MapEntry__Node__Tag____ {
	uint__ hash__;
	Node__ key__;
	Tag__ value__;
} MapEntry__Node__Tag____;
typedef struct tag_____MapEntry__Node__int____ {
	uint__ hash__;
	Node__ key__;
	int__ value__;
} MapEntry__Node__int____;
typedef struct tag_____MapEntry__string__Node____ {
	uint__ hash__;
	string__ key__;
	Node__ value__;
} MapEntry__string__Node____;
typedef struct tag_____Value__ {
	ValueKind__ kind__;
	ulong__ z__;
} Value__;
typedef struct tag_____MapEntry__Node__Value____ {
	uint__ hash__;
	Node__ key__;
	Value__ value__;
} MapEntry__Node__Value____;
typedef struct tag_____NodeWithCtx__ {
	Node__ node__;
	int__ ctxOutput__;
	int__ ctxField__;
} NodeWithCtx__;
typedef struct tag_____MapEntry__NodeWithCtx__string____ {
	uint__ hash__;
	NodeWithCtx__ key__;
	string__ value__;
} MapEntry__NodeWithCtx__string____;
typedef struct tag_____Instruction__ {
	Opcode__ op__;
	ulong__ z__;
} Instruction__;
typedef struct tag_____Block__ {
	Token__* openBrace__;
	List__Node____* contents__;
	Token__* closeBrace__;
} Block__;
typedef struct tag_____SlotInfo__ {
	string__ name__;
	Tag__ tag__;
	ModuleInstance__* inst__;
	Node__ node__;
	int__ field__;
	bool__ isStatic__;
	bool__ isReg__;
} SlotInfo__;
typedef struct tag_____ModuleInputDef__ {
	Token__* name__;
	Token__* type__;
	ModuleInputFlags__ flags__;
	int__ localId__;
} ModuleInputDef__;
typedef struct tag_____TernaryOperatorExpression__ {
	Node__ conditionExpr__;
	Token__* question__;
	Node__ trueExpr__;
	Token__* colon__;
	Node__ falseExpr__;
} TernaryOperatorExpression__;
typedef struct tag_____StructDef__ {
	Token__* name__;
	Token__* keyword__;
	Block__* body__;
	List__Ptr__FieldDef______* fields__;
	CodeUnit__* unit__;
	int__ id__;
	Map__string__Ptr__FieldDef______* symbols__;
	StructFlags__ flags__;
} StructDef__;
typedef struct tag_____IAllocator__ {
	pointer__ data__;
	fun__pointer__ssize__pointer____ allocFn__;
	fun__pointer__pointer__ssize__ssize__ssize__pointer____ reallocFn__;
	fun__pointer__pointer__void____ freeFn__;
} IAllocator__;
typedef struct tag_____IntRange__ {
	int__ from__;
	int__ to__;
} IntRange__;
typedef struct tag_____MatchExpression__ {
	Token__* keyword__;
	Node__ target__;
	Token__* openBrace__;
	List__Ptr__MatchExpressionCase______* cases__;
	List__Node____* contents__;
	Token__* closeBrace__;
} MatchExpression__;
typedef struct tag_____CallArg__ {
	Token__* name__;
	Token__* colon__;
	Node__ expr__;
} CallArg__;
typedef struct tag_____BinaryOperatorExpression__ {
	Node__ lhs__;
	Token__* op__;
	Node__ rhs__;
} BinaryOperatorExpression__;
typedef struct tag_____Result__string____ {
	string__ value__;
	int__ error__;
} Result__string____;
typedef struct tag_____QueuedCallArgs__ {
	CallExpression__* e__;
	ModuleDef__* def__;
	ModuleDef__* context__;
} QueuedCallArgs__;
typedef struct tag_____Maybe__uint____ {
	uint__ value__;
	bool__ hasValue__;
} Maybe__uint____;
typedef struct tag_____Maybe__string____ {
	string__ value__;
	bool__ hasValue__;
} Maybe__string____;
typedef struct tag_____Maybe__long____ {
	long__ value__;
	bool__ hasValue__;
} Maybe__long____;
typedef struct tag_____Maybe__int____ {
	int__ value__;
	bool__ hasValue__;
} Maybe__int____;
typedef struct tag_____Maybe__ulong____ {
	ulong__ value__;
	bool__ hasValue__;
} Maybe__ulong____;
typedef struct tag_____Array__MapEntry__NodeWithCtx__string______ {
	pointer__ dataPtr__;
	int__ count__;
} Array__MapEntry__NodeWithCtx__string______;
typedef struct tag_____Map__NodeWithCtx__string____ {
	Array__MapEntry__NodeWithCtx__string______ entries__;
	int__ count__;
	uint__ capacityMask__;
	int__ growThreshold__;
} Map__NodeWithCtx__string____;
typedef struct tag_____Array__MapEntry__string__Ptr__FieldDef________ {
	pointer__ dataPtr__;
	int__ count__;
} Array__MapEntry__string__Ptr__FieldDef________;
typedef struct tag_____Map__string__Ptr__FieldDef______ {
	Array__MapEntry__string__Ptr__FieldDef________ entries__;
	int__ count__;
	uint__ capacityMask__;
	int__ growThreshold__;
} Map__string__Ptr__FieldDef______;
typedef struct tag_____Array__MapEntry__string__Node______ {
	pointer__ dataPtr__;
	int__ count__;
} Array__MapEntry__string__Node______;
typedef struct tag_____Map__string__Node____ {
	Array__MapEntry__string__Node______ entries__;
	int__ count__;
	uint__ capacityMask__;
	int__ growThreshold__;
} Map__string__Node____;
typedef struct tag_____Array__MapEntry__Node__int______ {
	pointer__ dataPtr__;
	int__ count__;
} Array__MapEntry__Node__int______;
typedef struct tag_____Map__Node__int____ {
	Array__MapEntry__Node__int______ entries__;
	int__ count__;
	uint__ capacityMask__;
	int__ growThreshold__;
} Map__Node__int____;
typedef struct tag_____Array__MapEntry__Node__Value______ {
	pointer__ dataPtr__;
	int__ count__;
} Array__MapEntry__Node__Value______;
typedef struct tag_____Map__Node__Value____ {
	Array__MapEntry__Node__Value______ entries__;
	int__ count__;
	uint__ capacityMask__;
	int__ growThreshold__;
} Map__Node__Value____;
typedef struct tag_____Array__MapEntry__Node__Tag______ {
	pointer__ dataPtr__;
	int__ count__;
} Array__MapEntry__Node__Tag______;
typedef struct tag_____Map__Node__Tag____ {
	Array__MapEntry__Node__Tag______ entries__;
	int__ count__;
	uint__ capacityMask__;
	int__ growThreshold__;
} Map__Node__Tag____;
typedef struct tag_____ParseState__ {
	string__ text__;
	int__ index__;
	int__ lineStart__;
	Token__* token__;
	int__ prevTokenTo__;
	int__ tabSize__;
	bool__ ignoreIndent__;
	int__ base__;
	bool__ exprNoBrace__;
	int__ blockBase__;
	CodeUnit__* unit__;
	ModuleDef__* module__;
	StructDef__* struct___;
	List__Error____* errors__;
} ParseState__;
typedef struct tag_____ModuleDef__ {
	Token__* name__;
	Token__* blackboxKeyword__;
	Token__* openParen__;
	List__Ptr__ModuleInputDef______* inputs__;
	List__Node____* inputsContents__;
	Token__* closeParen__;
	Block__* body__;
	CodeUnit__* unit__;
	int__ id__;
	Map__string__Node____* symbols__;
	List__Ptr__AssignStatement______* outputs__;
	ModuleFlags__ flags__;
	int__ numCalls__;
	int__ numInputSlots__;
	int__ numRegSlots__;
} ModuleDef__;
typedef struct tag_____Args__ {
	List__Ptr__SourceFile______* sources__;
	string__ top__;
	string__ outputPath__;
	int__ indent__;
	int__ maxErrors__;
	bool__ printVersion__;
	bool__ printHelp__;
} Args__;
typedef struct tag_____SetEntry__string____ {
	uint__ hash__;
	string__ value__;
} SetEntry__string____;
typedef struct tag_____ArenaAllocator__ {
	pointer__ from__;
	pointer__ to__;
	pointer__ current__;
} ArenaAllocator__;
typedef struct tag_____DotExpression__ {
	Node__ lhs__;
	Token__* dot__;
	Token__* rhs__;
} DotExpression__;
typedef struct tag_____NumberExpression__ {
	Token__* token__;
	NumberFlags__ flags__;
	ulong__ value__;
	ulong__ dontCare__;
	int__ width__;
} NumberExpression__;
typedef struct tag_____ConstDef__ {
	Token__* colon__;
	Token__* name__;
	Token__* type__;
	Token__* assign__;
	Node__ expr__;
	CodeUnit__* unit__;
	int__ id__;
	ConstFlags__ flags__;
} ConstDef__;
typedef struct tag_____ParenExpression__ {
	Token__* openParen__;
	Node__ expr__;
	Token__* closeParen__;
} ParenExpression__;
typedef struct tag_____SourceFile__ {
	string__ path__;
	string__ text__;
} SourceFile__;
typedef struct tag_____CommandLineArgsParser__ {
	int__ index__;
	Array__string____* args__;
	List__CommandLineArgsParserError____* errors__;
} CommandLineArgsParser__;
typedef struct tag_____Compilation__ {
	List__Ptr__SourceFile______* sources__;
	CompilationFlags__ flags__;
	List__Ptr__CodeUnit______* units__;
	Map__string__Node____* symbols__;
	List__Node____* entities__;
	Map__Node__Tag____* typeMap__;
	Map__Node__Value____* constMap__;
	List__Error____* errors__;
	int__ nonSyntaxErrorStart__;
	double__ elapsedSeconds__;
} Compilation__;
typedef struct tag_____FieldDef__ {
	Token__* name__;
	Token__* type__;
	int__ fieldIndex__;
} FieldDef__;
typedef struct tag_____BraceExpression__ {
	Token__* openBrace__;
	List__Node____* args__;
	List__Node____* contents__;
	Token__* closeBrace__;
} BraceExpression__;
typedef struct tag_____StringBuilder__ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} StringBuilder__;
typedef struct tag_____CallExpression__ {
	Node__ target__;
	Token__* openParen__;
	List__Ptr__CallArg______* args__;
	List__Node____* contents__;
	Token__* closeParen__;
	BuiltinCall__ builtin__;
	int__ callId__;
	Array__int____* calleeLocalIdToArgIndex__;
} CallExpression__;
typedef struct tag_____UnaryOperatorExpression__ {
	Token__* op__;
	Node__ expr__;
} UnaryOperatorExpression__;
typedef struct tag_____EmulatorState__ {
	Compilation__* comp__;
	Map__string__Node____* symbols__;
	Map__Node__Tag____* typeMap__;
	Map__Node__Value____* constMap__;
	List__Node____* entities__;
	List__Error____* errors__;
	List__Ptr__ModuleInstance______* moduleInstances__;
	List__Value____* rs__;
	List__Value____* ws__;
	List__SlotInfo____* infos__;
	List__int____* evalOrder__;
	Map__Node__int____* nextId__;
	Array__bool____* started__;
	Array__bool____* done__;
	ModuleInstance__* inst__;
	int__ evalCtxField__;
	int__ evalCtxOutput__;
	List__Instruction____* tape__;
	List__Instruction____* resetProgram__;
	List__Instruction____* stepProgram__;
	List__Value____* stack__;
	long__ cycle__;
} EmulatorState__;
typedef struct tag_____TypeCheckResult__ {
	Tag__ tag__;
	Value__ value__;
} TypeCheckResult__;
typedef struct tag_____StructInitializerExpression__ {
	Node__ target__;
	Token__* openBrace__;
	List__Ptr__CallArg______* args__;
	List__Node____* contents__;
	Token__* closeBrace__;
	Array__int____* fieldIndexToArgIndex__;
} StructInitializerExpression__;
typedef struct tag_____CommandLineArgsParserError__ {
	int__ index__;
	IntRange__ innerSpan__;
	string__ text__;
} CommandLineArgsParserError__;
typedef struct tag_____LocationInfo__ {
	int__ line__;
	IntRange__ span__;
	IntRange__ columnSpan__;
	string__ lineText__;
} LocationInfo__;
typedef struct tag_____IndexExpression__ {
	Node__ target__;
	Token__* openBracket__;
	Node__ upperExpr__;
	Token__* colon__;
	Node__ lowerExpr__;
	Token__* closeBracket__;
} IndexExpression__;
typedef struct tag_____List__Ptr__AssignStatement______ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__Ptr__AssignStatement______;
typedef struct tag_____List__Error____ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__Error____;
typedef struct tag_____List__Ptr__MatchExpressionCase______ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__Ptr__MatchExpressionCase______;
typedef struct tag_____List__Ptr__CallArg______ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__Ptr__CallArg______;
typedef struct tag_____List__QueuedCallArgs____ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__QueuedCallArgs____;
typedef struct tag_____List__byte____ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__byte____;
typedef struct tag_____List__Ptr__ModuleInstance______ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__Ptr__ModuleInstance______;
typedef struct tag_____List__Node____ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__Node____;
typedef struct tag_____List__SlotInfo____ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__SlotInfo____;
typedef struct tag_____List__int____ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__int____;
typedef struct tag_____List__Instruction____ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__Instruction____;
typedef struct tag_____List__Value____ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__Value____;
typedef struct tag_____List__string____ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__string____;
typedef struct tag_____List__Ptr__SourceFile______ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__Ptr__SourceFile______;
typedef struct tag_____List__Ptr__CodeUnit______ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__Ptr__CodeUnit______;
typedef struct tag_____List__CommandLineArgsParserError____ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__CommandLineArgsParserError____;
typedef struct tag_____List__Ptr__FieldDef______ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__Ptr__FieldDef______;
typedef struct tag_____List__Ptr__ModuleInputDef______ {
	pointer__ dataPtr__;
	int__ count__;
	int__ capacity__;
} List__Ptr__ModuleInputDef______;
typedef struct tag_____Array__SetEntry__string______ {
	pointer__ dataPtr__;
	int__ count__;
} Array__SetEntry__string______;
typedef struct tag_____Set__string____ {
	Array__SetEntry__string______ entries__;
	int__ count__;
	uint__ capacityMask__;
	int__ growThreshold__;
} Set__string____;
typedef struct tag_____ArrayExpression__ {
	Token__* openBracket__;
	List__Node____* contents__;
	List__byte____* data__;
	Token__* closeBracket__;
} ArrayExpression__;
typedef struct tag_____AssignStatement__ {
	Token__* outKeyword__;
	Token__* regKeyword__;
	Node__ nameExpr__;
	Token__* type__;
	Token__* op__;
	Node__ expr__;
	ModuleDef__* module__;
	AssignFlags__ flags__;
	int__ localId__;
	int__ lhsFieldIndex__;
	int__ outputIndex__;
} AssignStatement__;
typedef struct tag_____RangeFinderState__ {
	IntRange__ range__;
} RangeFinderState__;
typedef struct tag_____ClockStatement__ {
	Token__* keyword__;
	Token__* name__;
	Block__* body__;
} ClockStatement__;
typedef struct tag_____Array__IntRange____ {
	pointer__ dataPtr__;
	int__ count__;
} Array__IntRange____;
typedef struct tag_____Array__Error____ {
	pointer__ dataPtr__;
	int__ count__;
} Array__Error____;
typedef struct tag_____Array__int____ {
	pointer__ dataPtr__;
	int__ count__;
} Array__int____;
typedef struct tag_____Array__byte____ {
	pointer__ dataPtr__;
	int__ count__;
} Array__byte____;
typedef struct tag_____Array__string____ {
	pointer__ dataPtr__;
	int__ count__;
} Array__string____;
typedef struct tag_____Array__bool____ {
	pointer__ dataPtr__;
	int__ count__;
} Array__bool____;
typedef struct tag_____Array__cstring____ {
	pointer__ dataPtr__;
	int__ count__;
} Array__cstring____;
typedef struct tag_____MatchExpressionCase__ {
	Node__ valueExpr__;
	Token__* colon__;
	Node__ resultExpr__;
} MatchExpressionCase__;
typedef struct tag_____GeneratorState__ {
	Compilation__* comp__;
	Map__string__Node____* symbols__;
	Map__Node__Tag____* typeMap__;
	Map__Node__Value____* constMap__;
	List__Node____* entities__;
	List__Error____* errors__;
	EmulatorState__* es__;
	ModuleInstance__* inst__;
	int__ evalCtxOutput__;
	int__ evalCtxField__;
	bool__ isNonIndexable__;
	CodeBuilder__* out__;
	CodeBuilder__* first__;
	CodeBuilder__* assignments__;
	CodeBuilder__* regUpdates__;
	Set__string____* globals__;
} GeneratorState__;
typedef struct tag_____Token__ {
	TokenType__ type__;
	string__ value__;
	IntRange__ span__;
	IntRange__ outerSpan__;
	int__ indent__;
} Token__;
typedef struct tag_____TypeCheckerContext__ {
	CodeUnit__* unit__;
	ModuleDef__* module__;
	bool__ inClock__;
	bool__ allowDontCare__;
	bool__ isStaticExpr__;
} TypeCheckerContext__;
typedef struct tag_____ModuleInstance__ {
	ModuleDef__* def__;
	string__ fullName__;
	string__ localName__;
	Array__int____* localState__;
	Array__int____* calls__;
	ModuleInstance__* caller__;
	CallExpression__* callExpr__;
	string__ genGlobalName__;
	string__ genLocalName__;
	Set__string____* genLocalsSet__;
	Map__NodeWithCtx__string____* genLocals__;
} ModuleInstance__;
typedef struct tag_____CommandLineInfo__ {
	string__ text__;
	Array__IntRange____* argSpans__;
} CommandLineInfo__;
typedef struct tag_____TypeCheckerState__ {
	Compilation__* comp__;
	CodeUnit__* unit__;
	ModuleDef__* module__;
	StructDef__* struct___;
	Map__string__Node____* symbols__;
	Map__Node__Tag____* typeMap__;
	Map__Node__Value____* constMap__;
	List__QueuedCallArgs____* queue__;
	bool__ gap__;
	Tag__ gapTag__;
	bool__ inClock__;
	bool__ isStaticExpr__;
	bool__ allowDontCare__;
	List__Error____* errors__;
} TypeCheckerState__;
typedef struct tag_____IndexerState__ {
	Compilation__* comp__;
	CodeUnit__* unit__;
	ModuleDef__* module__;
} IndexerState__;
typedef struct tag_____Error__ {
	CodeUnit__* unit__;
	IntRange__ span__;
	string__ text__;
} Error__;
typedef struct tag_____CodeBuilder__ {
	StringBuilder__* sb__;
	int__ indent__;
	string__ lineSep__;
	bool__ skipSep__;
} CodeBuilder__;
typedef struct tag_____CodeUnit__ {
	string__ path__;
	string__ source__;
	List__Node____* contents__;
	int__ id__;
} CodeUnit__;
typedef struct tag_____IfStatement__ {
	Token__* ifKeyword__;
	Node__ expr__;
	Block__* ifBody__;
	Token__* elseKeyword__;
	Node__ elseBranch__;
} IfStatement__;
// STATIC FIELDS
static int__ mu_____argc;
static pointer__ mu_____argv;
const uint__ ConstFlags__typeCheckDone__ = 2u;
const uint__ ConstFlags__typeCheckStarted__ = 1u;
const uint__ CompilationFlags__generate__ = 1u;
const uint__ CompilationFlags__simulate__ = 2u;
#define CStdlib__stderr__ (pointer__)(stderr)
#define CStdlib__stdin__ (pointer__)(stdin)
const byte__ byte__minValue__ = 0u;
const byte__ byte__maxValue__ = 255u;
const uint__ string__fnvOffsetBasis__ = 2166136261u;
const uint__ string__fnvPrime__ = 16777619u;
const int__ Stdin__tryReadLine_ioError__ = 2;
const int__ Stdin__tryReadLine_eof__ = 1;
const uint__ Opcode__discard__ = 11u;
const uint__ Opcode__neg__ = 12u;
const uint__ Opcode__mul__ = 19u;
const uint__ Opcode__or__ = 17u;
const uint__ Opcode__eq__ = 20u;
const uint__ Opcode__shr__ = 27u;
const uint__ Opcode__jump__ = 8u;
const uint__ Opcode__slice__ = 28u;
const uint__ Opcode__sub__ = 15u;
const uint__ Opcode__lte__ = 23u;
const uint__ Opcode__push__ = 0u;
const uint__ Opcode__pushArray__ = 1u;
const uint__ Opcode__invert__ = 13u;
const uint__ Opcode__swizzle__ = 30u;
const uint__ Opcode__dup__ = 10u;
const uint__ Opcode__and__ = 16u;
const uint__ Opcode__load__ = 2u;
const uint__ Opcode__mask__ = 4u;
const uint__ Opcode__index__ = 5u;
const uint__ Opcode__shlOr__ = 6u;
const uint__ Opcode__lt__ = 22u;
const uint__ Opcode__store__ = 3u;
const uint__ Opcode__gte__ = 25u;
const uint__ Opcode__add__ = 14u;
const uint__ Opcode__gt__ = 24u;
const uint__ Opcode__neq__ = 21u;
const uint__ Opcode__shl__ = 26u;
const uint__ Opcode__jumpIfZero__ = 7u;
const uint__ Opcode__storeSlice__ = 29u;
const uint__ Opcode__xor__ = 18u;
const uint__ Opcode__nop__ = 9u;
const long__ long__maxValue__ = 9223372036854775807LL;
const long__ long__minValue__ = -9223372036854775807LL - 1;
const int__ int__maxValue__ = 2147483647;
const int__ int__minValue__ = -2147483647 - 1;
const usize__ usize__minValue__ = 0uLL;
const usize__ usize__maxValue__ = 0xffffffffffffffffuLL;
const uint__ ValueKind__none__ = 0u;
const uint__ ValueKind__ulong___ = 1u;
const uint__ ValueKind__byteArray__ = 2u;
const ulong__ ulong__maxValue__ = 0xffffffffffffffffuLL;
const ulong__ ulong__minValue__ = 0uLL;
const uint__ StructFlags__typeCheckDone__ = 1u;
const uint__ AssignFlags__regUpdate__ = 2u;
const uint__ AssignFlags__reg__ = 1u;
const uint__ AssignFlags__wire__ = 4u;
const uint__ AssignFlags__static__ = 8u;
const uint__ AssignFlags__typeCheckStarted__ = 16u;
const uint__ AssignFlags__typeCheckDone__ = 32u;
const sbyte__ sbyte__minValue__ = -128;
const sbyte__ sbyte__maxValue__ = 127;
_Thread_local fun__int__void____ top_____abandonFn__;
const uint__ TagKind__number__ = 1u;
const uint__ TagKind__unknown__ = 0u;
const uint__ TagKind__struct___ = 3u;
const uint__ TagKind__moduleOut__ = 2u;
const uint__ BuiltinCall__rep__ = 1u;
const uint__ BuiltinCall__slice__ = 2u;
const uint__ BuiltinCall__chunk__ = 3u;
const uint__ BuiltinCall__none__ = 0u;
const uint__ BuiltinCall__swizzle__ = 4u;
const uint__ uint__maxValue__ = 4294967295u;
const uint__ uint__minValue__ = 0u;
const ushort__ ushort__minValue__ = 0u;
const ushort__ ushort__maxValue__ = 65535u;
const uint__ TokenType__openBracket__ = 7u;
const uint__ TokenType__operator__ = 2u;
const uint__ TokenType__identifier__ = 0u;
const uint__ TokenType__end__ = 10u;
const uint__ TokenType__closeBracket__ = 8u;
const uint__ TokenType__invalid__ = 11u;
const uint__ TokenType__openParen__ = 3u;
const uint__ TokenType__comma__ = 9u;
const uint__ TokenType__openBrace__ = 5u;
const uint__ TokenType__closeParen__ = 4u;
const uint__ TokenType__closeBrace__ = 6u;
const uint__ TokenType__numberLiteral__ = 1u;
const bool__ top______32bit__ = 0;
_Thread_local IAllocator__ top_____currentAllocator__;
const uint__ ModuleFlags__typeCheckDone__ = 4u;
const uint__ ModuleFlags__top__ = 1u;
const uint__ ModuleFlags__typeCheckStarted__ = 2u;
const uint__ ParseCommaListState__expectValue__ = 1u;
const uint__ ParseCommaListState__expectComma__ = 2u;
const uint__ ParseCommaListState__start__ = 0u;
const ssize__ ssize__minValue__ = -9223372036854775807LL - 1;
const ssize__ ssize__maxValue__ = 9223372036854775807LL;
const short__ short__minValue__ = -32768;
const short__ short__maxValue__ = 32767;
#define top_____compilerVersion__ mu_____string10
const int__ Parser__sameLine__ = 2147483647;
static int__ Parser__maxBase__;
const uint__ NumberFlags__exactWidth__ = 2u;
const uint__ NumberFlags__valid__ = 1u;
const uint__ NumberFlags__none__ = 0u;
const uint__ NumberFlags__dontCare__ = 4u;
const uint__ ModuleInputFlags__static__ = 1u;
// FUNCTIONS
SourceFile__* top_____tryReadSourceFile__(string__ path__);
uint__ double__hash__(double__ val__);
int__ double__compare__(double__ a__, double__ b__);
void__ double__writeTo__(double__ val__, StringBuilder__* sb__);
void__ EmulatorStep__unaryOperator__(EmulatorState__* s__, UnaryOperatorExpression__* e__);
void__ EmulatorStep__pushValue__(EmulatorState__* s__, Value__ val__);
void__ EmulatorStep__chunk__(EmulatorState__* s__, CallExpression__* e__);
int__ EmulatorStep__emit__(EmulatorState__* s__, Opcode__ op__);
void__ EmulatorStep__assign__(EmulatorState__* s__, AssignStatement__* st__);
void__ EmulatorStep__binaryOperator__(EmulatorState__* s__, BinaryOperatorExpression__* e__);
int__ EmulatorStep__emitz__(EmulatorState__* s__, Opcode__ op__, ulong__ z__);
void__ EmulatorStep__slice__(EmulatorState__* s__, CallExpression__* e__);
void__ EmulatorStep__expressionInner__(EmulatorState__* s__, Node__ e__);
void__ EmulatorStep__assignSlice__(EmulatorState__* s__, AssignStatement__* st__, CallExpression__* e__, int__ si__);
int__ EmulatorStep__emiti__(EmulatorState__* s__, Opcode__ op__, int__ z__);
void__ EmulatorStep__if___(EmulatorState__* s__, IfStatement__* st__);
void__ EmulatorStep__paren__(EmulatorState__* s__, ParenExpression__* e__);
void__ EmulatorStep__module__(EmulatorState__* s__, ModuleInstance__* inst__);
void__ EmulatorStep__clock__(EmulatorState__* s__, ClockStatement__* st__);
void__ EmulatorStep__number__(EmulatorState__* s__, NumberExpression__* e__);
void__ EmulatorStep__dot__(EmulatorState__* s__, DotExpression__* e__);
void__ EmulatorStep__block__(EmulatorState__* s__, Block__* block__);
void__ EmulatorStep__rep__(EmulatorState__* s__, CallExpression__* e__);
void__ EmulatorStep__swizzle__(EmulatorState__* s__, CallExpression__* e__);
void__ EmulatorStep__structInit__(EmulatorState__* s__, StructInitializerExpression__* e__);
void__ EmulatorStep__call__(EmulatorState__* s__, CallExpression__* e__);
void__ EmulatorStep__patch__(EmulatorState__* s__, int__ index__);
void__ EmulatorStep__expression__(EmulatorState__* s__, Node__ e__);
void__ EmulatorStep__match___(EmulatorState__* s__, MatchExpression__* e__);
void__ EmulatorStep__index__(EmulatorState__* s__, IndexExpression__* e__);
void__ EmulatorStep__mask__(EmulatorState__* s__, Tag__ tag__);
void__ EmulatorStep__ternaryOperator__(EmulatorState__* s__, TernaryOperatorExpression__* e__);
void__ EmulatorStep__slot__(EmulatorState__* s__, int__ si__);
void__ EmulatorStep__token__(EmulatorState__* s__, Token__* e__);
void__ EmulatorStep__brace__(EmulatorState__* s__, BraceExpression__* e__);
void__ top_____main__();
void__ Stderr__write__(string__ s__);
void__ Stderr__writeLine__(string__ s__);
pointer__ IAllocator__alloc__(IAllocator__ a__, ssize__ numBytes__);
pointer__ IAllocator__realloc__(IAllocator__ a__, pointer__ ptr__, ssize__ newSizeInBytes__, ssize__ prevSizeInBytes__, ssize__ copySizeInBytes__);
void__ IAllocator__free__(IAllocator__ a__, pointer__ ptr__);
uint__ char__hash__(char__ ch__);
int__ char__compare__(char__ a__, char__ b__);
void__ char__writeTo__(char__ ch__, StringBuilder__* sb__);
uint__ byte__hash__(byte__ val__);
void__ byte__writeTo__(byte__ val__, StringBuilder__* sb__);
Args__* top_____parseArgs__(CommandLineArgsParser__* parser__, bool__ isCompiler__);
uint__ bool32__hash__(bool32__ val__);
void__ bool32__writeTo__(bool32__ val__, StringBuilder__* sb__);
uint__ pointer__hash__(pointer__ p__);
ssize__ pointer__subtractSigned__(pointer__ a__, pointer__ b__);
usize__ pointer__subtractUnsigned__(pointer__ a__, pointer__ b__);
int__ pointer__compare__(pointer__ a__, pointer__ b__);
void__ pointer__writeTo__(pointer__ p__, StringBuilder__* sb__);
uint__ cstring__hash__(cstring__ cstr__);
int__ cstring__length__(cstring__ cstr__);
void__ cstring__writeTo__(cstring__ cstr__, StringBuilder__* sb__);
IntRange__ IntRange__cons__(int__ from__, int__ to__);
uint__ Node__hash__(Node__ n__);
Tag__ Tag__cons__(TagKind__ kind__, int__ q__);
bool__ Tag__isValid__(Tag__ t__);
void__ EmulatorAllocator__block__(EmulatorState__* s__, Block__* st__);
Value__ EmulatorAllocator__createValue__(EmulatorState__* s__, Tag__ tag__, bool__ allocArray__);
void__ EmulatorAllocator__call__(EmulatorState__* s__, CallExpression__* e__, string__ name__);
string__ EmulatorAllocator__formatName__(string__ a__, string__ b__);
void__ EmulatorAllocator__if___(EmulatorState__* s__, IfStatement__* st__);
void__ EmulatorAllocator__top__(EmulatorState__* s__, ModuleDef__* def__);
int__ EmulatorAllocator__module__(EmulatorState__* s__, ModuleDef__* def__, string__ name__);
void__ EmulatorAllocator__assign__(EmulatorState__* s__, AssignStatement__* st__);
void__ EmulatorAllocator__expression__(EmulatorState__* s__, Node__ e__);
bool__ string__endsWith__(string__ s__, string__ suffix__);
int__ string__compare_ignoreCase__(string__ a__, string__ b__);
string__ string__replace__(string__ s__, string__ sub__, string__ replacement__);
char__ string__toLower___(char__ ch__);
uint__ string__hash__(string__ s__);
string__ string__from_cstring__(cstring__ cstr__);
string__ string__slice__(string__ s__, int__ from__, int__ to__);
bool__ string__equals__(string__ a__, string__ b__);
string__ string__alloc__(pointer__ dataPtr__, int__ length__);
int__ string__indexOfChar__(string__ s__, char__ ch__);
bool__ string__startsWith_ignoreCase__(string__ s__, string__ prefix__);
bool__ string__startsWith__(string__ s__, string__ prefix__);
cstring__ string__alloc_cstring__(string__ s__);
Array__string____ string__split__(string__ s__, char__ sep__);
string__ string__repeatChar__(char__ ch__, int__ count__);
int__ string__compare__(string__ a__, string__ b__);
string__ string__from__(pointer__ dataPtr__, int__ length__);
string__ string__join__(string__ sep__, Array__string____* items__);
int__ string__indexOf__(string__ s__, string__ sub__);
uint__ bool__hash__(bool__ val__);
void__ bool__writeTo__(bool__ val__, StringBuilder__* sb__);
Result__string____ Stdin__tryReadLine__();
Result__string____ Result__fromValue__string____(string__ value__);
Result__string____ Result__fromError__string____(int__ error__);
string__ Opcode__toString__(Opcode__ op__);
Maybe__uint____ Maybe__from__uint____(uint__ value__);
Maybe__string____ Maybe__from__string____(string__ value__);
Maybe__long____ Maybe__from__long____(long__ value__);
Maybe__int____ Maybe__from__int____(int__ value__);
Maybe__ulong____ Maybe__from__ulong____(ulong__ value__);
Maybe__string____ Map__maybeGet__NodeWithCtx__string____(Map__NodeWithCtx__string____* this__, NodeWithCtx__ key__);
bool__ Map__containsKey__string__Node____(Map__string__Node____* this__, string__ key__);
void__ Map__addOrUpdate__Node__int____(Map__Node__int____* this__, Node__ key__, int__ value__);
bool__ Map__tryAdd__NodeWithCtx__string____(Map__NodeWithCtx__string____* this__, NodeWithCtx__ key__, string__ value__);
bool__ Map__tryAdd__Node__Value____(Map__Node__Value____* this__, Node__ key__, Value__ value__);
bool__ Map__tryAdd__Node__Tag____(Map__Node__Tag____* this__, Node__ key__, Tag__ value__);
bool__ Map__tryAdd__string__Node____(Map__string__Node____* this__, string__ key__, Node__ value__);
bool__ Map__tryAdd__string__Ptr__FieldDef______(Map__string__Ptr__FieldDef______* this__, string__ key__, FieldDef__* value__);
void__ Map__add__NodeWithCtx__string____(Map__NodeWithCtx__string____* this__, NodeWithCtx__ key__, string__ value__);
void__ Map__add__Node__Value____(Map__Node__Value____* this__, Node__ key__, Value__ value__);
void__ Map__add__Node__Tag____(Map__Node__Tag____* this__, Node__ key__, Tag__ value__);
FieldDef__* Map__get__string__Ptr__FieldDef______(Map__string__Ptr__FieldDef______* this__, string__ key__);
Value__ Map__get__Node__Value____(Map__Node__Value____* this__, Node__ key__);
Node__ Map__get__string__Node____(Map__string__Node____* this__, string__ key__);
Tag__ Map__get__Node__Tag____(Map__Node__Tag____* this__, Node__ key__);
Tag__ Map__getOrDefault__Node__Tag____(Map__Node__Tag____* this__, Node__ key__);
Node__ Map__getOrDefault__string__Node____(Map__string__Node____* this__, string__ key__);
int__ Map__getOrDefault__Node__int____(Map__Node__int____* this__, Node__ key__);
Value__ Map__getOrDefault__Node__Value____(Map__Node__Value____* this__, Node__ key__);
FieldDef__* Map__getOrDefault__string__Ptr__FieldDef______(Map__string__Ptr__FieldDef______* this__, string__ key__);
MapEntry__string__Ptr__FieldDef______* Map__getEmptyEntry___string__Ptr__FieldDef______(Map__string__Ptr__FieldDef______* this__, uint__ h__);
MapEntry__Node__Tag____* Map__getEmptyEntry___Node__Tag____(Map__Node__Tag____* this__, uint__ h__);
MapEntry__Node__int____* Map__getEmptyEntry___Node__int____(Map__Node__int____* this__, uint__ h__);
MapEntry__string__Node____* Map__getEmptyEntry___string__Node____(Map__string__Node____* this__, uint__ h__);
MapEntry__Node__Value____* Map__getEmptyEntry___Node__Value____(Map__Node__Value____* this__, uint__ h__);
MapEntry__NodeWithCtx__string____* Map__getEmptyEntry___NodeWithCtx__string____(Map__NodeWithCtx__string____* this__, uint__ h__);
void__ Map__grow__string__Ptr__FieldDef______(Map__string__Ptr__FieldDef______* this__);
void__ Map__grow__Node__Tag____(Map__Node__Tag____* this__);
void__ Map__grow__Node__int____(Map__Node__int____* this__);
void__ Map__grow__string__Node____(Map__string__Node____* this__);
void__ Map__grow__Node__Value____(Map__Node__Value____* this__);
void__ Map__grow__NodeWithCtx__string____(Map__NodeWithCtx__string____* this__);
Map__Node__Tag____ Map__create__Node__Tag____();
Map__NodeWithCtx__string____ Map__create__NodeWithCtx__string____();
Map__string__Node____ Map__create__string__Node____();
Map__Node__int____ Map__create__Node__int____();
Map__Node__Value____ Map__create__Node__Value____();
Map__string__Ptr__FieldDef______ Map__create__string__Ptr__FieldDef______();
uint__ long__hash__(long__ val__);
Maybe__long____ long__tryParse__(string__ s__);
int__ long__compare__(long__ a__, long__ b__);
void__ long__writeTo__(long__ val__, StringBuilder__* sb__);
Maybe__long____ long__tryParseHex__(string__ s__);
Maybe__int____ top_____parseInt__(CommandLineArgsParser__* parser__);
uint__ int__hash__(int__ val__);
Maybe__int____ int__tryParse__(string__ s__);
int__ int__compare__(int__ a__, int__ b__);
void__ int__writeTo__(int__ val__, StringBuilder__* sb__);
uint__ usize__hash__(usize__ val__);
void__ usize__writeTo__(usize__ val__, StringBuilder__* sb__);
void__ ArenaAllocator__restoreState__(ArenaAllocator__* a__, pointer__ state__);
pointer__ ArenaAllocator__alloc__(ArenaAllocator__* a__, ssize__ numBytes__);
pointer__ ArenaAllocator__realloc__(ArenaAllocator__* a__, pointer__ ptr__, ssize__ newSizeInBytes__, ssize__ prevSizeInBytes__, ssize__ copySizeInBytes__);
ArenaAllocator__ ArenaAllocator__cons__(ssize__ capacity__);
IAllocator__ ArenaAllocator__iAllocator_escaping__(ArenaAllocator__* a__);
pointer__ ArenaAllocator__pushState__(ArenaAllocator__* a__);
bool__ File__tryReadToStringBuilder__(string__ path__, StringBuilder__* out__);
bool__ File__tryWriteString__(string__ path__, string__ data__);
uint__ ulong__hash__(ulong__ val__);
Maybe__ulong____ ulong__tryParse__(string__ s__);
int__ ulong__compare__(ulong__ a__, ulong__ b__);
void__ ulong__writeTo__(ulong__ val__, StringBuilder__* sb__);
Maybe__ulong____ ulong__tryParseHex__(string__ s__);
void__ ulong__writeHexTo__(ulong__ val__, StringBuilder__* sb__);
void__ Emulator__reset__(EmulatorState__* s__);
void__ Emulator__commitValues__(EmulatorState__* s__);
EmulatorState__* Emulator__init__(Compilation__* comp__, ModuleDef__* top__);
void__ Emulator__step__(EmulatorState__* s__, string__ clk__, ulong__ val__);
void__ CommandLineArgsParser__error__(CommandLineArgsParser__* self__, string__ text__);
string__ CommandLineArgsParser__readToken__(CommandLineArgsParser__* self__);
string__ CommandLineArgsParser__getErrorDesc__(CommandLineArgsParserError__ e__, CommandLineInfo__ info__);
CommandLineArgsParser__ CommandLineArgsParser__from__(Array__string____* args__, List__CommandLineArgsParserError____* errors__);
CommandLineInfo__ CommandLineArgsParser__getCommandLineInfo__(CommandLineArgsParser__* self__);
void__ CommandLineArgsParser__expected__(CommandLineArgsParser__* self__, string__ text__);
int__ CommandLineArgsParser__getNumColumns___(string__ s__, int__ tabSize__);
void__ CrashHandler__enable__();
void__ TypeChecker__expectedConstant__(TypeCheckerState__* s__, Node__ e__);
void__ TypeChecker__badBinaryOp__(TypeCheckerState__* s__, Token__* op__, Tag__ lhs__, Tag__ rhs__);
void__ TypeChecker__moduleInput__(TypeCheckerState__* s__, ModuleInputDef__* input__);
bool__ TypeChecker__isValidEntityName__(string__ s__);
void__ TypeChecker__statementNotAllowedInsideBlackbox__(TypeCheckerState__* s__, Node__ e__);
void__ TypeChecker__unit__(TypeCheckerState__* s__, CodeUnit__* unit__);
void__ TypeChecker__expectedFixedNumber__(TypeCheckerState__* s__, Node__ e__);
int__ TypeChecker__highestBit__(ulong__ n__);
void__ TypeChecker__badUnify__(TypeCheckerState__* s__, Token__* token__, Tag__ te__, Tag__ fe__);
bool__ TypeChecker__canConvertFreeConst__(TypeCheckerState__* s__, Value__ val__, int__ width__);
Tag__ TypeChecker__tag__(TypeCheckerState__* s__, string__ name__);
void__ TypeChecker__reg__(TypeCheckerState__* s__, AssignStatement__* st__);
void__ TypeChecker__fieldDef__(TypeCheckerState__* s__, FieldDef__* def__);
void__ TypeChecker__ensureAssignDone__(TypeCheckerState__* s__, AssignStatement__* st__, Node__ reference__);
void__ TypeChecker__wire__(TypeCheckerState__* s__, AssignStatement__* st__);
void__ TypeChecker__if___(TypeCheckerState__* s__, IfStatement__* st__);
void__ TypeChecker__badConstConversion__(TypeCheckerState__* s__, Node__ e__, Tag__ from__, Tag__ to__);
void__ TypeChecker__module__(TypeCheckerState__* s__, ModuleDef__* def__);
void__ TypeChecker__ensureStructDone__(TypeCheckerState__* s__, StructDef__* def__);
void__ TypeChecker__ensureModuleDone__(TypeCheckerState__* s__, ModuleDef__* def__, Node__ location__);
TypeCheckResult__ TypeChecker__number__(TypeCheckerState__* s__, NumberExpression__* e__);
TypeCheckResult__ TypeChecker__dot__(TypeCheckerState__* s__, DotExpression__* e__);
TypeCheckResult__ TypeChecker__structInit__(TypeCheckerState__* s__, StructInitializerExpression__* e__);
bool__ TypeChecker__isFixedNumberOrStructOrModuleOut__(Tag__ tag__);
void__ TypeChecker__badConversion__(TypeCheckerState__* s__, Node__ e__, Tag__ from__, Tag__ to__);
int__ TypeChecker__unpackWidth__(Tag__ tag__);
TypeCheckResult__ TypeChecker__array__(TypeCheckerState__* s__, ArrayExpression__* e__);
void__ TypeChecker__unsupportedUnaryOp__(TypeCheckerState__* s__, Token__* op__, Tag__ tag__);
void__ TypeChecker__badUnaryOp__(TypeCheckerState__* s__, Token__* op__, Tag__ tag__);
TypeCheckResult__ TypeChecker__call__(TypeCheckerState__* s__, CallExpression__* e__);
void__ TypeChecker__badAssign__(TypeCheckerState__* s__, Token__* at__, Tag__ from__, Tag__ to__);
TypeCheckResult__ TypeChecker__index__(TypeCheckerState__* s__, IndexExpression__* e__);
void__ TypeChecker__badSymbol__(TypeCheckerState__* s__, Token__* token__);
void__ TypeChecker__invalidNamePrefix__(TypeCheckerState__* s__, Node__ e__);
void__ TypeChecker__builtinArgs__(TypeCheckerState__* s__, CallExpression__* e__, int__ count__);
TypeCheckResult__ TypeChecker__ternaryOperator__(TypeCheckerState__* s__, TernaryOperatorExpression__* e__);
void__ TypeChecker__expectedFixedNumberOrStruct__(TypeCheckerState__* s__, Node__ e__);
TypeCheckResult__ TypeChecker__token__(TypeCheckerState__* s__, Token__* e__);
TypeCheckerContext__ TypeChecker__pushContext__(TypeCheckerState__* s__, CodeUnit__* unit__, ModuleDef__* def__);
TypeCheckResult__ TypeChecker__brace__(TypeCheckerState__* s__, BraceExpression__* e__);
void__ TypeChecker__badGapArgument__(TypeCheckerState__* s__, Token__* op__, Tag__ arg__, Tag__ target__);
int__ TypeChecker__unpackInt__(Value__ value__);
void__ TypeChecker__badGap__(TypeCheckerState__* s__, Token__* op__);
TypeCheckResult__ TypeChecker__expressionContinueGap__(TypeCheckerState__* s__, Node__ e__);
TypeCheckResult__ TypeChecker__unaryOperator__(TypeCheckerState__* s__, UnaryOperatorExpression__* e__);
void__ TypeChecker__invalidNamePrefix_nonStatic__(TypeCheckerState__* s__, Node__ e__);
TypeCheckResult__ TypeChecker__chunk__(TypeCheckerState__* s__, CallExpression__* e__);
void__ TypeChecker__regUpdate__(TypeCheckerState__* s__, AssignStatement__* st__);
void__ TypeChecker__expectedFixedNumberExpression__(TypeCheckerState__* s__, Node__ e__);
void__ TypeChecker__assign__(TypeCheckerState__* s__, AssignStatement__* st__);
TypeCheckResult__ TypeChecker__binaryOperator__(TypeCheckerState__* s__, BinaryOperatorExpression__* e__);
Tag__ TypeChecker__typename__(TypeCheckerState__* s__, Node__ node__, Token__* name__);
bool__ TypeChecker__canAssign__(TypeCheckerState__* s__, Tag__ from__, Value__ fromValue__, Tag__ to__);
TypeCheckResult__ TypeChecker__fixedNumberArg__(TypeCheckerState__* s__, CallExpression__* e__, int__ index__);
TypeCheckResult__ TypeChecker__slice__(TypeCheckerState__* s__, CallExpression__* e__);
void__ TypeChecker__unsupportedRegUpdate__(TypeCheckerState__* s__, Node__ e__);
void__ TypeChecker__const__(TypeCheckerState__* s__, ConstDef__* def__);
TypeCheckResult__ TypeChecker__expressionInner__(TypeCheckerState__* s__, Node__ e__);
string__ TypeChecker__tagString__(Compilation__* comp__, Tag__ tag__);
void__ TypeChecker__badBinaryOperandConversion__(TypeCheckerState__* s__, IntRange__ span__, Tag__ tag__);
TypeCheckResult__ TypeChecker__assignSlice__(TypeCheckerState__* s__, AssignStatement__* st__, CallExpression__* e__);
void__ TypeChecker__unsupportedBinaryOp__(TypeCheckerState__* s__, Token__* op__, Tag__ lhs__, Tag__ rhs__);
TypeCheckResult__ TypeChecker__paren__(TypeCheckerState__* s__, ParenExpression__* e__);
void__ TypeChecker__expectedStaticConstant__(TypeCheckerState__* s__, Node__ e__);
void__ TypeChecker__clock__(TypeCheckerState__* s__, ClockStatement__* st__);
TypeCheckResult__ TypeChecker__numberArg__(TypeCheckerState__* s__, CallExpression__* e__, int__ index__);
bool__ TypeChecker__isValidEntityName_nonStatic__(string__ s__);
TypeCheckResult__ TypeChecker__rep__(TypeCheckerState__* s__, CallExpression__* e__);
TypeCheckResult__ TypeChecker__swizzle__(TypeCheckerState__* s__, CallExpression__* e__);
void__ TypeChecker__block__(TypeCheckerState__* s__, Block__* st__);
int__ TypeChecker__numSlots__(Compilation__* comp__, Tag__ tag__);
TypeCheckResult__ TypeChecker__constantArg__(TypeCheckerState__* s__, CallExpression__* e__, int__ index__);
Maybe__int____ TypeChecker__tryUnpackInt__(Value__ value__);
void__ TypeChecker__comp__(Compilation__* comp__);
void__ TypeChecker__ensureConstDone__(TypeCheckerState__* s__, ConstDef__* def__, Node__ reference__);
TypeCheckResult__ TypeChecker__expression__(TypeCheckerState__* s__, Node__ e__);
void__ TypeChecker__struct___(TypeCheckerState__* s__, StructDef__* def__);
TypeCheckResult__ TypeChecker__match___(TypeCheckerState__* s__, MatchExpression__* e__);
bool__ TypeChecker__isFixedNumberOrStruct__(Tag__ tag__);
void__ TypeChecker__duplicateSymbol__(TypeCheckerState__* s__, Token__* token__);
void__ TypeChecker__expectedFixedNumberOrStructExpression__(TypeCheckerState__* s__, Node__ e__);
TypeCheckResult__ TypeChecker__expressionWithGap__(TypeCheckerState__* s__, Node__ e__, bool__ gap__, Tag__ gapTag__);
void__ TypeChecker__expectedNumberExpression__(TypeCheckerState__* s__, Node__ e__);
void__ TypeChecker__callArgs__(TypeCheckerState__* s__, CallExpression__* e__, ModuleDef__* def__);
void__ TypeChecker__restoreContext__(TypeCheckerState__* s__, TypeCheckerContext__ ctx__);
void__ StringBuilder__reverseSlice__(StringBuilder__* sb__, int__ from__, int__ to__);
void__ StringBuilder__clear__(StringBuilder__* sb__);
string__ StringBuilder__toString__(StringBuilder__* this__);
void__ StringBuilder__writeChar__(StringBuilder__* sb__, char__ ch__);
void__ StringBuilder__reserve__(StringBuilder__* sb__, int__ capacity__);
void__ StringBuilder__write__(StringBuilder__* sb__, string__ s__);
void__ StringBuilder__reserveForWrite__(StringBuilder__* sb__, int__ numBytesToWrite__);
string__ StringBuilder__compactToString__(StringBuilder__* sb__);
uint__ Random__xorshift32__(uint__* state__);
uint__ float__hash__(float__ val__);
int__ float__compare__(float__ a__, float__ b__);
void__ float__writeTo__(float__ val__, StringBuilder__* sb__);
uint__ sbyte__hash__(sbyte__ val__);
void__ sbyte__writeTo__(sbyte__ val__, StringBuilder__* sb__);
Array__string____* Environment__getCommandLineArgs__();
uint__ uint__hash__(uint__ val__);
Maybe__uint____ uint__tryParse__(string__ s__);
int__ uint__compare__(uint__ a__, uint__ b__);
void__ uint__writeTo__(uint__ val__, StringBuilder__* sb__);
uint__ ushort__hash__(ushort__ val__);
void__ ushort__writeTo__(ushort__ val__, StringBuilder__* sb__);
void__ List__reserve__Ptr__SourceFile______(List__Ptr__SourceFile______* this__, int__ capacity__);
void__ List__reserve__Error____(List__Error____* this__, int__ capacity__);
void__ List__reserve__SlotInfo____(List__SlotInfo____* this__, int__ capacity__);
void__ List__reserve__Ptr__AssignStatement______(List__Ptr__AssignStatement______* this__, int__ capacity__);
void__ List__reserve__QueuedCallArgs____(List__QueuedCallArgs____* this__, int__ capacity__);
void__ List__reserve__byte____(List__byte____* this__, int__ capacity__);
void__ List__reserve__int____(List__int____* this__, int__ capacity__);
void__ List__reserve__Node____(List__Node____* this__, int__ capacity__);
void__ List__reserve__Instruction____(List__Instruction____* this__, int__ capacity__);
void__ List__reserve__Ptr__CallArg______(List__Ptr__CallArg______* this__, int__ capacity__);
void__ List__reserve__Ptr__MatchExpressionCase______(List__Ptr__MatchExpressionCase______* this__, int__ capacity__);
void__ List__reserve__Value____(List__Value____* this__, int__ capacity__);
void__ List__reserve__string____(List__string____* this__, int__ capacity__);
void__ List__reserve__Ptr__FieldDef______(List__Ptr__FieldDef______* this__, int__ capacity__);
void__ List__reserve__Ptr__ModuleInputDef______(List__Ptr__ModuleInputDef______* this__, int__ capacity__);
void__ List__reserve__CommandLineArgsParserError____(List__CommandLineArgsParserError____* this__, int__ capacity__);
void__ List__reserve__Ptr__ModuleInstance______(List__Ptr__ModuleInstance______* this__, int__ capacity__);
void__ List__reserve__Ptr__CodeUnit______(List__Ptr__CodeUnit______* this__, int__ capacity__);
Array__Error____ List__slice__Error____(List__Error____* this__, int__ from__, int__ to__);
Array__byte____ List__slice__byte____(List__byte____* this__, int__ from__, int__ to__);
Array__string____ List__slice__string____(List__string____* this__, int__ from__, int__ to__);
void__ List__setCountChecked__Value____(List__Value____* this__, int__ count__);
void__ List__add__Ptr__FieldDef______(List__Ptr__FieldDef______* this__, FieldDef__* item__);
void__ List__add__Error____(List__Error____* this__, Error__ item__);
void__ List__add__Ptr__ModuleInputDef______(List__Ptr__ModuleInputDef______* this__, ModuleInputDef__* item__);
void__ List__add__CommandLineArgsParserError____(List__CommandLineArgsParserError____* this__, CommandLineArgsParserError__ item__);
void__ List__add__SlotInfo____(List__SlotInfo____* this__, SlotInfo__ item__);
void__ List__add__byte____(List__byte____* this__, byte__ item__);
void__ List__add__Ptr__ModuleInstance______(List__Ptr__ModuleInstance______* this__, ModuleInstance__* item__);
void__ List__add__Node____(List__Node____* this__, Node__ item__);
void__ List__add__int____(List__int____* this__, int__ item__);
void__ List__add__Instruction____(List__Instruction____* this__, Instruction__ item__);
void__ List__add__Ptr__CodeUnit______(List__Ptr__CodeUnit______* this__, CodeUnit__* item__);
void__ List__add__Value____(List__Value____* this__, Value__ item__);
void__ List__add__string____(List__string____* this__, string__ item__);
void__ List__add__Ptr__SourceFile______(List__Ptr__SourceFile______* this__, SourceFile__* item__);
void__ List__add__Ptr__AssignStatement______(List__Ptr__AssignStatement______* this__, AssignStatement__* item__);
void__ List__add__QueuedCallArgs____(List__QueuedCallArgs____* this__, QueuedCallArgs__ item__);
void__ List__add__Ptr__CallArg______(List__Ptr__CallArg______* this__, CallArg__* item__);
void__ List__add__Ptr__MatchExpressionCase______(List__Ptr__MatchExpressionCase______* this__, MatchExpressionCase__* item__);
void__ List__grow__Ptr__SourceFile______(List__Ptr__SourceFile______* this__);
void__ List__grow__Error____(List__Error____* this__);
void__ List__grow__SlotInfo____(List__SlotInfo____* this__);
void__ List__grow__Ptr__AssignStatement______(List__Ptr__AssignStatement______* this__);
void__ List__grow__QueuedCallArgs____(List__QueuedCallArgs____* this__);
void__ List__grow__byte____(List__byte____* this__);
void__ List__grow__int____(List__int____* this__);
void__ List__grow__Node____(List__Node____* this__);
void__ List__grow__Instruction____(List__Instruction____* this__);
void__ List__grow__Ptr__CallArg______(List__Ptr__CallArg______* this__);
void__ List__grow__Ptr__MatchExpressionCase______(List__Ptr__MatchExpressionCase______* this__);
void__ List__grow__Value____(List__Value____* this__);
void__ List__grow__string____(List__string____* this__);
void__ List__grow__Ptr__FieldDef______(List__Ptr__FieldDef______* this__);
void__ List__grow__Ptr__ModuleInputDef______(List__Ptr__ModuleInputDef______* this__);
void__ List__grow__CommandLineArgsParserError____(List__CommandLineArgsParserError____* this__);
void__ List__grow__Ptr__ModuleInstance______(List__Ptr__ModuleInstance______* this__);
void__ List__grow__Ptr__CodeUnit______(List__Ptr__CodeUnit______* this__);
bool__ Set__tryRemove__string____(Set__string____* this__, string__ value__);
bool__ Set__tryAdd__string____(Set__string____* this__, string__ value__);
void__ Set__add__string____(Set__string____* this__, string__ value__);
SetEntry__string____* Set__getEmptyEntry___string____(Set__string____* this__, uint__ h__);
bool__ Set__contains__string____(Set__string____* this__, string__ value__);
void__ Set__grow__string____(Set__string____* this__);
Set__string____ Set__create__string____();
string__ ErrorHelper__getErrorDesc__(string__ path__, string__ source__, IntRange__ span__, string__ text__);
LocationInfo__ ErrorHelper__spanToLocationInfo__(string__ source__, IntRange__ span__);
int__ ErrorHelper__getNumColumns__(string__ s__, int__ tabSize__);
int__ ErrorHelper__compareErrors__(Error__ a__, Error__ b__);
void__ EmulatorOrderCalculator__dot__(EmulatorState__* s__, DotExpression__* e__);
void__ EmulatorOrderCalculator__block__(EmulatorState__* s__, Block__* st__);
void__ EmulatorOrderCalculator__structInit__(EmulatorState__* s__, StructInitializerExpression__* e__);
void__ EmulatorOrderCalculator__call__(EmulatorState__* s__, CallExpression__* e__);
void__ EmulatorOrderCalculator__comp__(EmulatorState__* s__);
void__ EmulatorOrderCalculator__expression__(EmulatorState__* s__, Node__ e__);
void__ EmulatorOrderCalculator__assign__(EmulatorState__* s__, AssignStatement__* st__);
void__ EmulatorOrderCalculator__assignRef__(EmulatorState__* s__, AssignStatement__* st__);
void__ EmulatorOrderCalculator__token__(EmulatorState__* s__, Token__* e__);
void__ EmulatorOrderCalculator__wire__(EmulatorState__* s__, AssignStatement__* st__);
void__ EmulatorOrderCalculator__if___(EmulatorState__* s__, IfStatement__* st__);
void__ EmulatorOrderCalculator__input__(EmulatorState__* s__, ModuleInputDef__* inp__);
void__ EmulatorOrderCalculator__module__(EmulatorState__* s__, ModuleInstance__* inst__);
void__ EmulatorOrderCalculator__logicLoop__(EmulatorState__* s__, Node__ e__);
int__ CheckedMath__addPositiveInt__(int__ x__, int__ y__);
ssize__ CheckedMath__mulPositiveSsize__(ssize__ x__, ssize__ y__);
int__ CheckedMath__mulPositiveInt__(int__ x__, int__ y__);
void__ EmulatorRunner__setInput__(EmulatorState__* s__, ModuleInstance__* inst__, string__ input__, ulong__ val__);
Value__ EmulatorRunner__swizzle__(EmulatorState__* s__, Value__ target__, int__ targetWidth__, int__ seqSize__, int__ readStep__, int__ blockSize__);
Array__byte____* EmulatorRunner__unpackArray__(Value__ v__);
void__ EmulatorRunner__run__(EmulatorState__* s__, List__Instruction____* program__);
void__ EmulatorRunner__binaryOperator__(EmulatorState__* s__, List__Value____* stack__, ulong__ result__);
void__ EmulatorRunner__copyToArray__(Value__ v__, Value__* dest__);
void__ EmulatorRunner__setSlot__(EmulatorState__* s__, int__ si__, Value__ val__);
Value__ EmulatorRunner__slice__(EmulatorState__* s__, Value__ target__, ulong__ targetWidth__, ulong__ offset__, ulong__ width__);
ulong__ EmulatorRunner__unpack__(Value__ v__);
ulong__ EmulatorRunner__unpackAsULong__(Value__ v__);
Value__ EmulatorRunner__packULong__(Array__byte____* data__);
void__ EmulatorRunner__storeSlice__(EmulatorState__* s__, int__ si__, ulong__ offset__, ulong__ width__, Value__ val__);
Value__ EmulatorRunner__bigSlice__(EmulatorState__* s__, Value__ target__, ulong__ targetWidth__, ulong__ offset__, ulong__ width__);
Array__byte____ EmulatorRunner__unpackAsArray__(Value__* v__);
Value__ EmulatorRunner__packArray__(Array__byte____* data__);
uint__ NodeWithCtx__hash__(NodeWithCtx__ self__);
bool__ NodeWithCtx__equals__(NodeWithCtx__ a__, NodeWithCtx__ b__);
void__ Stdout__write__(string__ s__);
void__ Stdout__writeLine__(string__ s__);
Array__byte____ Array__slice__byte____(Array__byte____* this__, int__ from__, int__ to__);
void__ Array__stableSort__Error____(Array__Error____* items__, fun__Error__Error__int____ compareFn__);
Array__IntRange____ Array__cons__IntRange____(int__ count__);
Array__Error____ Array__cons__Error____(int__ count__);
Array__int____ Array__cons__int____(int__ count__);
Array__byte____ Array__cons__byte____(int__ count__);
Array__SetEntry__string______ Array__cons__SetEntry__string______(int__ count__);
Array__MapEntry__NodeWithCtx__string______ Array__cons__MapEntry__NodeWithCtx__string______(int__ count__);
Array__MapEntry__Node__Value______ Array__cons__MapEntry__Node__Value______(int__ count__);
Array__MapEntry__Node__Tag______ Array__cons__MapEntry__Node__Tag______(int__ count__);
Array__MapEntry__Node__int______ Array__cons__MapEntry__Node__int______(int__ count__);
Array__MapEntry__string__Node______ Array__cons__MapEntry__string__Node______(int__ count__);
Array__MapEntry__string__Ptr__FieldDef________ Array__cons__MapEntry__string__Ptr__FieldDef________(int__ count__);
Array__bool____ Array__cons__bool____(int__ count__);
Array__string____ Array__cons__string____(int__ count__);
void__ Array__clearValues__byte____(Array__byte____* this__);
void__ Array__stableSortMerge___Error____(Array__Error____* src__, Array__Error____* dest__, int__ from__, int__ chunk__, fun__Error__Error__int____ compareFn__);
void__ Array__copySlice__Error____(Array__Error____* src__, int__ from__, int__ to__, Array__Error____* dest__, int__ index__);
void__ Array__copySlice__byte____(Array__byte____* src__, int__ from__, int__ to__, Array__byte____* dest__, int__ index__);
void__ Indexer__block__(IndexerState__* s__, Block__* st__);
void__ Indexer__unit__(IndexerState__* s__, CodeUnit__* unit__);
void__ Indexer__comp__(Compilation__* comp__);
void__ Indexer__if___(IndexerState__* s__, IfStatement__* st__);
void__ Indexer__assign__(IndexerState__* s__, AssignStatement__* st__);
void__ Indexer__duplicateSymbol__(IndexerState__* s__, Token__* token__);
uint__ ssize__hash__(ssize__ val__);
void__ ssize__writeTo__(ssize__ val__, StringBuilder__* sb__);
IntRange__ RangeFinder__find__(Node__ e__);
void__ RangeFinder__token__(RangeFinderState__* s__, Token__* e__);
void__ RangeFinder__node__(RangeFinderState__* s__, Node__ e__);
IAllocator__ Memory__newArenaAllocator__(ssize__ capacity__);
IAllocator__ Memory__heapAllocator__();
pointer__ Memory__heapAllocFn__(pointer__ data__, ssize__ numBytes__);
pointer__ Memory__heapReallocFn__(pointer__ data__, pointer__ ptr__, ssize__ newSizeInBytes__, ssize__ prevSizeInBytes__, ssize__ copySizeInBytes__);
IAllocator__ Memory__pushAllocator__(IAllocator__ allocator__);
void__ Memory__heapFreeFn__(pointer__ data__, pointer__ ptr__);
void__ Memory__restoreAllocator__(IAllocator__ allocator__);
uint__ short__hash__(short__ val__);
void__ short__writeTo__(short__ val__, StringBuilder__* sb__);
ModuleInputDef__* Parser__moduleInput__(ParseState__* s__);
CodeUnit__* Parser__unit__(string__ text__, List__Error____* errors__, int__ tabSize__);
void__ Parser__finishToken__(ParseState__* s__, int__ outerFrom__, int__ from__, int__ indent__, TokenType__ type__);
void__ Parser__readBadToken_unexpected__(ParseState__* s__);
void__ Parser__errorAt__(ParseState__* s__, int__ index__, string__ text__);
Node__ Parser__parseExpression_alwaysProgress__(ParseState__* s__, int__ minLevel__, List__Node____* out_all__);
void__ Parser__parseAssignStatement__(ParseState__* s__, List__Node____* out__);
void__ Parser__readBadToken__(ParseState__* s__, string__ text__);
void__ Parser__readToken__(ParseState__* s__);
void__ Parser__error__(ParseState__* s__, string__ text__);
void__ Parser__const__(ParseState__* s__, Token__* name__, List__Node____* out__);
bool__ Parser__isOperatorChar__(char__ ch__);
void__ Parser__fieldDef__(ParseState__* s__, List__Node____* out__);
void__ Parser__expected__(ParseState__* s__, string__ text__);
Node__ Parser__parseExpressionLeaf__(ParseState__* s__);
Node__ Parser__parseMatchExpression__(ParseState__* s__);
void__ Parser__module__(ParseState__* s__, Token__* name__, List__Node____* out__);
CallExpression__* Parser__parseCallExpression__(ParseState__* s__, Node__ lhs__);
NumberExpression__* Parser__parseNumber__(ParseState__* s__);
IfStatement__* Parser__parseIfStatement__(ParseState__* s__);
Node__ Parser__parseExpressionTail__(ParseState__* s__, Node__ lhs__, int__ minLevel__);
Block__* Parser__block__(ParseState__* s__, bool__ statements__, string__ desc__);
void__ Parser__parseClockStatement__(ParseState__* s__, List__Node____* out__);
StructInitializerExpression__* Parser__parseStructInitializerExpression__(ParseState__* s__, Node__ lhs__);
int__ Parser__parseNumberSuffix__(ParseState__* s__, string__ suffix__);
void__ Parser__parseComma__(ParseState__* s__, List__Node____* out__);
void__ Parser__parseCallArg__(ParseState__* s__, List__Ptr__CallArg______* out_args__, List__Node____* out_all__);
IndexExpression__* Parser__parseIndexExpression__(ParseState__* s__, Node__ lhs__);
void__ Parser__struct___(ParseState__* s__, Token__* name__, List__Node____* out__);
int__ Parser__getBindingLevel__(string__ op__);
void__ Parser__parseErrorToken__(ParseState__* s__, string__ text__, List__Node____* out__);
Node__ Parser__parseExpression_orNull__(ParseState__* s__, int__ minLevel__);
void__ Parser__expectedAt__(ParseState__* s__, int__ index__, string__ text__);
void__ Parser__parseMatchExpressionCase__(ParseState__* s__, List__Ptr__MatchExpressionCase______* out_cases__, List__Node____* out_all__);
ArrayExpression__* Parser__parseArrayExpression__(ParseState__* s__);
void__ Parser__parseStatement__(ParseState__* s__, List__Node____* out__);
void__ Parser__readBadToken_newline__(ParseState__* s__);
Node__ Parser__parseExpression__(ParseState__* s__, int__ minLevel__);
void__ VerilogGenerator__unaryOperator__(GeneratorState__* s__, UnaryOperatorExpression__* e__);
void__ VerilogGenerator__output__(GeneratorState__* s__, AssignStatement__* o__, string__ genName__, Tag__ tag__);
void__ VerilogGenerator__regUpdate__(GeneratorState__* s__, string__ genName__, Node__ expr__);
string__ VerilogGenerator__newLocal__(GeneratorState__* s__, Tag__ tag__, string__ valStr__);
void__ VerilogGenerator__value__(GeneratorState__* s__, Tag__ tag__, Value__ value__);
void__ VerilogGenerator__assign__(GeneratorState__* s__, AssignStatement__* st__);
void__ VerilogGenerator__binaryOperator__(GeneratorState__* s__, BinaryOperatorExpression__* e__);
void__ VerilogGenerator__unindent__(GeneratorState__* s__);
void__ VerilogGenerator__restore__(GeneratorState__* s__, CodeBuilder__* cb__);
void__ VerilogGenerator__reg__(GeneratorState__* s__, AssignStatement__* st__, string__ genName__, Tag__ tag__);
void__ VerilogGenerator__expressionInner__(GeneratorState__* s__, Node__ e__);
string__ VerilogGenerator__nameOf__(GeneratorState__* s__, ModuleInstance__* inst__, Node__ node__, int__ ctxOutput__, int__ ctxField__);
void__ VerilogGenerator__wire__(GeneratorState__* s__, AssignStatement__* st__, string__ genName__, Tag__ tag__);
string__ VerilogGenerator__trimHash__(string__ s__);
StructDef__* VerilogGenerator__unpackStruct__(GeneratorState__* s__, Tag__ tag__);
void__ VerilogGenerator__if___(GeneratorState__* s__, IfStatement__* st__);
void__ VerilogGenerator__paren__(GeneratorState__* s__, ParenExpression__* e__);
void__ VerilogGenerator__module__(GeneratorState__* s__, ModuleInstance__* inst__);
void__ VerilogGenerator__callInst__(GeneratorState__* s__, ModuleInstance__* target__);
void__ VerilogGenerator__clock__(GeneratorState__* s__, ClockStatement__* st__);
void__ VerilogGenerator__number__(GeneratorState__* s__, NumberExpression__* e__);
void__ VerilogGenerator__dot__(GeneratorState__* s__, DotExpression__* e__);
void__ VerilogGenerator__block__(GeneratorState__* s__, Block__* block__);
void__ VerilogGenerator__rep__(GeneratorState__* s__, CallExpression__* e__);
void__ VerilogGenerator__structInit__(GeneratorState__* s__, StructInitializerExpression__* e__);
void__ VerilogGenerator__numberTag__(GeneratorState__* s__, Tag__ tag__);
string__ VerilogGenerator__uniqueName__(GeneratorState__* s__, ModuleInstance__* inst__, Set__string____* set__, string__ origName__);
void__ VerilogGenerator__write__(GeneratorState__* s__, string__ str__);
CodeBuilder__* VerilogGenerator__push__(GeneratorState__* s__, CodeBuilder__* cb__);
void__ VerilogGenerator__call__(GeneratorState__* s__, CallExpression__* e__);
CodeBuilder__* VerilogGenerator__comp__(Compilation__* comp__, EmulatorState__* es__);
void__ VerilogGenerator__expression__(GeneratorState__* s__, Node__ e__);
void__ VerilogGenerator__match___(GeneratorState__* s__, MatchExpression__* e__);
void__ VerilogGenerator__index__(GeneratorState__* s__, IndexExpression__* e__);
void__ VerilogGenerator__ternaryOperator__(GeneratorState__* s__, TernaryOperatorExpression__* e__);
void__ VerilogGenerator__token__(GeneratorState__* s__, Token__* e__);
bool__ VerilogGenerator__hasStaticInputs__(GeneratorState__* s__, ModuleDef__* def__);
void__ VerilogGenerator__beginLine__(GeneratorState__* s__);
void__ VerilogGenerator__brace__(GeneratorState__* s__, BraceExpression__* e__);
void__ VerilogGenerator__staticValue__(GeneratorState__* s__, ModuleInstance__* instance__, int__ localId__, Tag__ tag__);
void__ VerilogGenerator__input__(GeneratorState__* s__, ModuleInputDef__* inp__, string__ genName__, Tag__ tag__);
void__ VerilogGenerator__indent__(GeneratorState__* s__, string__ lineSep__);
ModuleDef__* VerilogGenerator__unpackModule__(GeneratorState__* s__, Tag__ tag__);
void__ Util__writeByteHexTo__(byte__ b__, StringBuilder__* sb__);
bool__ Util__arrayEquals__byte____(Array__byte____* a__, Array__byte____* b__);
bool__ Util__valEquals__(Value__ a__, Value__ b__);
void__ Util__shlArray__(Array__byte____* a__, int__ n__);
Error__ Error__at__(CodeUnit__* unit__, IntRange__ span__, string__ text__);
Error__ Error__atIndex__(CodeUnit__* unit__, int__ index__, string__ text__);
CodeBuilder__ CodeBuilder__create__();
SourceFile__* top_____tryReadSourceFile__(string__ path__) {
	StringBuilder__* local0 = (StringBuilder__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(StringBuilder__));
	StringBuilder__ local1;
	memset(&local1, 0, sizeof(StringBuilder__));
	*local0 = local1;
	StringBuilder__* sb__ = local0;
	if (!(File__tryReadToStringBuilder__(path__, sb__))) {
		return null__;
	}
	StringBuilder__writeChar__(sb__, '\0');
	SourceFile__* local2 = (SourceFile__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(SourceFile__));
	SourceFile__ local3;
	memset(&local3, 0, sizeof(SourceFile__));
	local3.path__ = path__;
	local3.text__ = StringBuilder__compactToString__(sb__);
	*local2 = local3;
	return local2;
}
uint__ double__hash__(double__ val__) {
	union { double__ from; uint__ to; } local0;
	memset(&local0, 0, sizeof(local0));
	local0.from = val__;
	return local0.to;
}
int__ double__compare__(double__ a__, double__ b__) {
	if (((a__)) < ((b__))) {
		return -1;
	} else {
		if (((a__)) > ((b__))) {
			return 1;
		}
	}
	return 0;
}
void__ double__writeTo__(double__ val__, StringBuilder__* sb__) {
	int__ max__ = 64;
	StringBuilder__reserveForWrite__(sb__, max__);
	int__ size__ = (int__)snprintf((char *)((sb__)->dataPtr__) + ((sb__)->count__), (usize__)((uint__)(max__)), (cstring__)((mu_____string3).dataPtr__), val__);
	bool__ local0 = ((0)) < ((size__));
	if (local0) {
		local0 = ((size__)) < ((max__));
	}
	mu_____assert(local0);
	(sb__)->count__ = (((sb__)->count__)) + ((size__));
}
void__ EmulatorStep__unaryOperator__(EmulatorState__* s__, UnaryOperatorExpression__* e__) {
	bool__ local0 = (((s__)->evalCtxField__)) == ((-1));
	if (local0) {
		local0 = (((s__)->evalCtxOutput__)) == ((-1));
	}
	mu_____assert(local0);
	EmulatorStep__expression__(s__, (e__)->expr__);
	string__ op__ = ((e__)->op__)->value__;
	if (string__equals__(op__, mu_____string2)) {
		EmulatorStep__emit__(s__, Opcode__neg__);
		Node__ local1;
		local1.dataPtr__ = (pointer__)(e__);
		local1.id__ = local1.dataPtr__ != null__ ? Node_____Ptr__UnaryOperatorExpression____ : 0;
		EmulatorStep__mask__(s__, Map__get__Node__Tag____((s__)->typeMap__, local1));
	} else {
		if (string__equals__(op__, mu_____string57)) {
			EmulatorStep__emit__(s__, Opcode__invert__);
			Node__ local2;
			local2.dataPtr__ = (pointer__)(e__);
			local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__UnaryOperatorExpression____ : 0;
			EmulatorStep__mask__(s__, Map__get__Node__Tag____((s__)->typeMap__, local2));
		} else {
			if (string__equals__(op__, mu_____string20)) {
			} else {
				mu_____abandon(-1);
			}
		}
	}
}
void__ EmulatorStep__pushValue__(EmulatorState__* s__, Value__ val__) {
	if (((val__).kind__) == (ValueKind__ulong___)) {
		EmulatorStep__emitz__(s__, Opcode__push__, (val__).z__);
	} else {
		if (((val__).kind__) == (ValueKind__byteArray__)) {
			EmulatorStep__emitz__(s__, Opcode__pushArray__, (val__).z__);
		} else {
			mu_____abandon(-1);
		}
	}
}
void__ EmulatorStep__chunk__(EmulatorState__* s__, CallExpression__* e__) {
	bool__ local0 = (((s__)->evalCtxField__)) == ((-1));
	if (local0) {
		local0 = (((s__)->evalCtxOutput__)) == ((-1));
	}
	mu_____assert(local0);
	List__Ptr__CallArg______* local1 = (e__)->args__;
	uint__ local2 = (uint__)(0);
	mu_____boundscheck(local2 < (uint__)local1->count__);
	Tag__ target__ = Map__get__Node__Tag____((s__)->typeMap__, (((CallArg__**)local1->dataPtr__)[local2])->expr__);
	int__ targetSize__ = TypeChecker__unpackWidth__(target__);
	List__Ptr__CallArg______* local3 = (e__)->args__;
	uint__ local4 = (uint__)(1);
	mu_____boundscheck(local4 < (uint__)local3->count__);
	int__ index__ = TypeChecker__unpackInt__(Map__get__Node__Value____((s__)->constMap__, (((CallArg__**)local3->dataPtr__)[local4])->expr__));
	List__Ptr__CallArg______* local5 = (e__)->args__;
	uint__ local6 = (uint__)(2);
	mu_____boundscheck(local6 < (uint__)local5->count__);
	int__ numChunks__ = TypeChecker__unpackInt__(Map__get__Node__Value____((s__)->constMap__, (((CallArg__**)local5->dataPtr__)[local6])->expr__));
	mu_____assert(((((targetSize__)) % ((numChunks__)))) == ((0)));
	int__ chunkSize__ = ((targetSize__)) / ((numChunks__));
	int__ offset__ = ((index__)) * ((chunkSize__));
	List__Ptr__CallArg______* local7 = (e__)->args__;
	uint__ local8 = (uint__)(0);
	mu_____boundscheck(local8 < (uint__)local7->count__);
	EmulatorStep__expression__(s__, (((CallArg__**)local7->dataPtr__)[local8])->expr__);
	EmulatorStep__emiti__(s__, Opcode__push__, offset__);
	EmulatorStep__emiti__(s__, Opcode__push__, chunkSize__);
	EmulatorStep__emiti__(s__, Opcode__slice__, targetSize__);
}
int__ EmulatorStep__emit__(EmulatorState__* s__, Opcode__ op__) {
	int__ index__ = ((s__)->tape__)->count__;
	Instruction__ local0;
	memset(&local0, 0, sizeof(Instruction__));
	local0.op__ = op__;
	List__add__Instruction____((s__)->tape__, local0);
	return index__;
}
void__ EmulatorStep__assign__(EmulatorState__* s__, AssignStatement__* st__) {
	if (((((st__)->flags__)) & ((AssignFlags__regUpdate__))) != (0)) {
		Array__int____* local0 = ((s__)->inst__)->localState__;
		uint__ local1 = (uint__)((st__)->localId__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		int__ si__ = ((int__*)local0->dataPtr__)[local1];
		if (((st__)->nameExpr__).id__ == Node_____Ptr__Token____) {
			Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, (st__)->expr__);
			if (((tag__).kind__) == (TagKind__number__)) {
				EmulatorStep__expression__(s__, (st__)->expr__);
				EmulatorStep__emiti__(s__, Opcode__store__, si__);
			} else {
				if (((tag__).kind__) == (TagKind__struct___)) {
					List__Node____* local3 = (s__)->entities__;
					uint__ local4 = (uint__)((tag__).q__);
					mu_____boundscheck(local4 < (uint__)local3->count__);
					Node__ local2 = ((Node__*)local3->dataPtr__)[local4];
					mu_____checkedcast(local2.id__ == Node_____Ptr__StructDef____);
					StructDef__* def__ = (StructDef__*)(local2.dataPtr__);
					{
						List__Ptr__FieldDef______* local5 = (def__)->fields__;
						int__ i__ = 0;
						while (i__ < local5->count__) {
							FieldDef__* f__ = ((FieldDef__**)(local5->dataPtr__))[i__];
							(s__)->evalCtxField__ = i__;
							EmulatorStep__expression__(s__, (st__)->expr__);
							EmulatorStep__emiti__(s__, Opcode__store__, ((si__)) + ((i__)));
							i__ += 1;
						}
					}
					(s__)->evalCtxField__ = -1;
				} else {
					mu_____abandon(-1);
				}
			}
		} else {
			if (((st__)->nameExpr__).id__ == Node_____Ptr__DotExpression____) {
				Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, (st__)->expr__);
				if (((tag__).kind__) == (TagKind__number__)) {
					EmulatorStep__expression__(s__, (st__)->expr__);
					EmulatorStep__emiti__(s__, Opcode__store__, ((si__)) + (((st__)->lhsFieldIndex__)));
				} else {
					mu_____abandon(-1);
				}
			} else {
				if (((st__)->nameExpr__).id__ == Node_____Ptr__CallExpression____) {
					Node__ local6 = (st__)->nameExpr__;
					mu_____checkedcast(local6.id__ == Node_____Ptr__CallExpression____);
					CallExpression__* call__ = (CallExpression__*)(local6.dataPtr__);
					if (((call__)->builtin__) == (BuiltinCall__slice__)) {
						EmulatorStep__assignSlice__(s__, st__, call__, si__);
					} else {
						mu_____abandon(-1);
					}
				} else {
					mu_____abandon(-1);
				}
			}
		}
	}
}
void__ EmulatorStep__binaryOperator__(EmulatorState__* s__, BinaryOperatorExpression__* e__) {
	bool__ local0 = (((s__)->evalCtxField__)) == ((-1));
	if (local0) {
		local0 = (((s__)->evalCtxOutput__)) == ((-1));
	}
	mu_____assert(local0);
	EmulatorStep__expression__(s__, (e__)->lhs__);
	EmulatorStep__expression__(s__, (e__)->rhs__);
	string__ op__ = ((e__)->op__)->value__;
	if (string__equals__(op__, mu_____string39)) {
		EmulatorStep__emit__(s__, Opcode__add__);
	} else {
		if (string__equals__(op__, mu_____string2)) {
			EmulatorStep__emit__(s__, Opcode__sub__);
		} else {
			if (string__equals__(op__, mu_____string46)) {
				EmulatorStep__emit__(s__, Opcode__and__);
			} else {
				if (string__equals__(op__, mu_____string48)) {
					EmulatorStep__emit__(s__, Opcode__or__);
				} else {
					if (string__equals__(op__, mu_____string47)) {
						EmulatorStep__emit__(s__, Opcode__xor__);
					} else {
						if (string__equals__(op__, mu_____string36)) {
							EmulatorStep__emit__(s__, Opcode__mul__);
						} else {
							if (string__equals__(op__, mu_____string40)) {
								EmulatorStep__emit__(s__, Opcode__eq__);
							} else {
								if (string__equals__(op__, mu_____string41)) {
									EmulatorStep__emit__(s__, Opcode__neq__);
								} else {
									if (string__equals__(op__, mu_____string44)) {
										EmulatorStep__emit__(s__, Opcode__lte__);
									} else {
										if (string__equals__(op__, mu_____string42)) {
											EmulatorStep__emit__(s__, Opcode__lt__);
										} else {
											if (string__equals__(op__, mu_____string45)) {
												EmulatorStep__emit__(s__, Opcode__gte__);
											} else {
												if (string__equals__(op__, mu_____string43)) {
													EmulatorStep__emit__(s__, Opcode__gt__);
												} else {
													if (string__equals__(op__, mu_____string37)) {
														EmulatorStep__emit__(s__, Opcode__shl__);
													} else {
														if (string__equals__(op__, mu_____string38)) {
															EmulatorStep__emit__(s__, Opcode__shr__);
														} else {
															mu_____abandon(-1);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	Node__ local1;
	local1.dataPtr__ = (pointer__)(e__);
	local1.id__ = local1.dataPtr__ != null__ ? Node_____Ptr__BinaryOperatorExpression____ : 0;
	EmulatorStep__mask__(s__, Map__get__Node__Tag____((s__)->typeMap__, local1));
}
int__ EmulatorStep__emitz__(EmulatorState__* s__, Opcode__ op__, ulong__ z__) {
	int__ index__ = ((s__)->tape__)->count__;
	Instruction__ local0;
	memset(&local0, 0, sizeof(Instruction__));
	local0.op__ = op__;
	local0.z__ = z__;
	List__add__Instruction____((s__)->tape__, local0);
	return index__;
}
void__ EmulatorStep__slice__(EmulatorState__* s__, CallExpression__* e__) {
	bool__ local0 = (((s__)->evalCtxField__)) == ((-1));
	if (local0) {
		local0 = (((s__)->evalCtxOutput__)) == ((-1));
	}
	mu_____assert(local0);
	List__Ptr__CallArg______* local1 = (e__)->args__;
	uint__ local2 = (uint__)(0);
	mu_____boundscheck(local2 < (uint__)local1->count__);
	Tag__ dest__ = Map__get__Node__Tag____((s__)->typeMap__, (((CallArg__**)local1->dataPtr__)[local2])->expr__);
	List__Ptr__CallArg______* local3 = (e__)->args__;
	uint__ local4 = (uint__)(0);
	mu_____boundscheck(local4 < (uint__)local3->count__);
	EmulatorStep__expression__(s__, (((CallArg__**)local3->dataPtr__)[local4])->expr__);
	List__Ptr__CallArg______* local5 = (e__)->args__;
	uint__ local6 = (uint__)(1);
	mu_____boundscheck(local6 < (uint__)local5->count__);
	EmulatorStep__expression__(s__, (((CallArg__**)local5->dataPtr__)[local6])->expr__);
	List__Ptr__CallArg______* local7 = (e__)->args__;
	uint__ local8 = (uint__)(2);
	mu_____boundscheck(local8 < (uint__)local7->count__);
	EmulatorStep__expression__(s__, (((CallArg__**)local7->dataPtr__)[local8])->expr__);
	EmulatorStep__emiti__(s__, Opcode__slice__, TypeChecker__unpackWidth__(dest__));
}
void__ EmulatorStep__expressionInner__(EmulatorState__* s__, Node__ e__) {
	switch ((e__).id__) {
		case Node_____Ptr__Token____: {
			Token__* local0 = (Token__*)(e__.dataPtr__);
			EmulatorStep__token__(s__, local0);
			break;
		}
		case Node_____Ptr__NumberExpression____: {
			NumberExpression__* local1 = (NumberExpression__*)(e__.dataPtr__);
			EmulatorStep__number__(s__, local1);
			break;
		}
		case Node_____Ptr__UnaryOperatorExpression____: {
			UnaryOperatorExpression__* local2 = (UnaryOperatorExpression__*)(e__.dataPtr__);
			EmulatorStep__unaryOperator__(s__, local2);
			break;
		}
		case Node_____Ptr__BinaryOperatorExpression____: {
			BinaryOperatorExpression__* local3 = (BinaryOperatorExpression__*)(e__.dataPtr__);
			EmulatorStep__binaryOperator__(s__, local3);
			break;
		}
		case Node_____Ptr__DotExpression____: {
			DotExpression__* local4 = (DotExpression__*)(e__.dataPtr__);
			EmulatorStep__dot__(s__, local4);
			break;
		}
		case Node_____Ptr__TernaryOperatorExpression____: {
			TernaryOperatorExpression__* local5 = (TernaryOperatorExpression__*)(e__.dataPtr__);
			EmulatorStep__ternaryOperator__(s__, local5);
			break;
		}
		case Node_____Ptr__MatchExpression____: {
			MatchExpression__* local6 = (MatchExpression__*)(e__.dataPtr__);
			EmulatorStep__match___(s__, local6);
			break;
		}
		case Node_____Ptr__ParenExpression____: {
			ParenExpression__* local7 = (ParenExpression__*)(e__.dataPtr__);
			EmulatorStep__paren__(s__, local7);
			break;
		}
		case Node_____Ptr__IndexExpression____: {
			IndexExpression__* local8 = (IndexExpression__*)(e__.dataPtr__);
			EmulatorStep__index__(s__, local8);
			break;
		}
		case Node_____Ptr__CallExpression____: {
			CallExpression__* local9 = (CallExpression__*)(e__.dataPtr__);
			EmulatorStep__call__(s__, local9);
			break;
		}
		case Node_____Ptr__StructInitializerExpression____: {
			StructInitializerExpression__* local10 = (StructInitializerExpression__*)(e__.dataPtr__);
			EmulatorStep__structInit__(s__, local10);
			break;
		}
		case Node_____Ptr__BraceExpression____: {
			BraceExpression__* local11 = (BraceExpression__*)(e__.dataPtr__);
			EmulatorStep__brace__(s__, local11);
			break;
		}
		case 0:
		default: {
			mu_____nomatch();
		}
	}
}
void__ EmulatorStep__assignSlice__(EmulatorState__* s__, AssignStatement__* st__, CallExpression__* e__, int__ si__) {
	List__Ptr__CallArg______* local0 = (e__)->args__;
	uint__ local1 = (uint__)(1);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	EmulatorStep__expression__(s__, (((CallArg__**)local0->dataPtr__)[local1])->expr__);
	List__Ptr__CallArg______* local2 = (e__)->args__;
	uint__ local3 = (uint__)(2);
	mu_____boundscheck(local3 < (uint__)local2->count__);
	EmulatorStep__expression__(s__, (((CallArg__**)local2->dataPtr__)[local3])->expr__);
	EmulatorStep__expression__(s__, (st__)->expr__);
	EmulatorStep__emiti__(s__, Opcode__storeSlice__, si__);
}
int__ EmulatorStep__emiti__(EmulatorState__* s__, Opcode__ op__, int__ z__) {
	int__ index__ = ((s__)->tape__)->count__;
	Instruction__ local0;
	memset(&local0, 0, sizeof(Instruction__));
	local0.op__ = op__;
	int__ local1 = z__;
	mu_____checkedcast(0 <= local1);
	local0.z__ = (ulong__)(local1);
	List__add__Instruction____((s__)->tape__, local0);
	return index__;
}
void__ EmulatorStep__if___(EmulatorState__* s__, IfStatement__* st__) {
	EmulatorStep__expression__(s__, (st__)->expr__);
	int__ pc__ = EmulatorStep__emit__(s__, Opcode__jumpIfZero__);
	EmulatorStep__block__(s__, (st__)->ifBody__);
	if (((st__)->elseBranch__).id__ == Node_____Ptr__IfStatement____) {
		int__ ifEnd__ = EmulatorStep__emit__(s__, Opcode__jump__);
		EmulatorStep__patch__(s__, pc__);
		Node__ local0 = (st__)->elseBranch__;
		mu_____checkedcast(local0.id__ == Node_____Ptr__IfStatement____);
		EmulatorStep__if___(s__, (IfStatement__*)(local0.dataPtr__));
		EmulatorStep__patch__(s__, ifEnd__);
	} else {
		if (((st__)->elseBranch__).id__ == Node_____Ptr__Block____) {
			int__ ifEnd__ = EmulatorStep__emit__(s__, Opcode__jump__);
			EmulatorStep__patch__(s__, pc__);
			Node__ local1 = (st__)->elseBranch__;
			mu_____checkedcast(local1.id__ == Node_____Ptr__Block____);
			EmulatorStep__block__(s__, (Block__*)(local1.dataPtr__));
			EmulatorStep__patch__(s__, ifEnd__);
		} else {
			EmulatorStep__patch__(s__, pc__);
		}
	}
}
void__ EmulatorStep__paren__(EmulatorState__* s__, ParenExpression__* e__) {
	EmulatorStep__expression__(s__, (e__)->expr__);
}
void__ EmulatorStep__module__(EmulatorState__* s__, ModuleInstance__* inst__) {
	(s__)->inst__ = inst__;
	EmulatorStep__block__(s__, ((inst__)->def__)->body__);
}
void__ EmulatorStep__clock__(EmulatorState__* s__, ClockStatement__* st__) {
	EmulatorStep__token__(s__, (st__)->name__);
	if (!string__equals__(((st__)->keyword__)->value__, mu_____string14)) {
		EmulatorStep__emit__(s__, Opcode__invert__);
	}
	int__ pc__ = EmulatorStep__emit__(s__, Opcode__jumpIfZero__);
	EmulatorStep__block__(s__, (st__)->body__);
	EmulatorStep__patch__(s__, pc__);
}
void__ EmulatorStep__number__(EmulatorState__* s__, NumberExpression__* e__) {
	EmulatorStep__emitz__(s__, Opcode__push__, (e__)->value__);
}
void__ EmulatorStep__dot__(EmulatorState__* s__, DotExpression__* e__) {
	Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, (e__)->lhs__);
	if (((tag__).kind__) == (TagKind__struct___)) {
		mu_____assert((((s__)->evalCtxField__)) == ((-1)));
		List__Node____* local1 = (s__)->entities__;
		uint__ local2 = (uint__)((tag__).q__);
		mu_____boundscheck(local2 < (uint__)local1->count__);
		Node__ local0 = ((Node__*)local1->dataPtr__)[local2];
		mu_____checkedcast(local0.id__ == Node_____Ptr__StructDef____);
		StructDef__* def__ = (StructDef__*)(local0.dataPtr__);
		(s__)->evalCtxField__ = (Map__get__string__Ptr__FieldDef______((def__)->symbols__, ((e__)->rhs__)->value__))->fieldIndex__;
		EmulatorStep__expression__(s__, (e__)->lhs__);
		(s__)->evalCtxField__ = -1;
	} else {
		if (((tag__).kind__) == (TagKind__moduleOut__)) {
			mu_____assert((((s__)->evalCtxOutput__)) == ((-1)));
			List__Node____* local4 = (s__)->entities__;
			uint__ local5 = (uint__)((tag__).q__);
			mu_____boundscheck(local5 < (uint__)local4->count__);
			Node__ local3 = ((Node__*)local4->dataPtr__)[local5];
			mu_____checkedcast(local3.id__ == Node_____Ptr__ModuleDef____);
			ModuleDef__* def__ = (ModuleDef__*)(local3.dataPtr__);
			Node__ local6 = Map__get__string__Node____((def__)->symbols__, ((e__)->rhs__)->value__);
			mu_____checkedcast(local6.id__ == Node_____Ptr__AssignStatement____);
			(s__)->evalCtxOutput__ = ((AssignStatement__*)(local6.dataPtr__))->outputIndex__;
			EmulatorStep__expression__(s__, (e__)->lhs__);
			(s__)->evalCtxOutput__ = -1;
		} else {
			mu_____abandon(-1);
		}
	}
}
void__ EmulatorStep__block__(EmulatorState__* s__, Block__* block__) {
	{
		List__Node____* local0 = (block__)->contents__;
		int__ local1 = 0;
		while (local1 < local0->count__) {
			Node__ n__ = ((Node__*)(local0->dataPtr__))[local1];
			switch ((n__).id__) {
				case Node_____Ptr__ClockStatement____: {
					ClockStatement__* local2 = (ClockStatement__*)(n__.dataPtr__);
					EmulatorStep__clock__(s__, local2);
					break;
				}
				case Node_____Ptr__IfStatement____: {
					IfStatement__* local3 = (IfStatement__*)(n__.dataPtr__);
					EmulatorStep__if___(s__, local3);
					break;
				}
				case Node_____Ptr__AssignStatement____: {
					AssignStatement__* local4 = (AssignStatement__*)(n__.dataPtr__);
					EmulatorStep__assign__(s__, local4);
					break;
				}
				case 0:
				default: {
					mu_____nomatch();
				}
			}
			local1 += 1;
		}
	}
}
void__ EmulatorStep__rep__(EmulatorState__* s__, CallExpression__* e__) {
	bool__ local0 = (((s__)->evalCtxField__)) == ((-1));
	if (local0) {
		local0 = (((s__)->evalCtxOutput__)) == ((-1));
	}
	mu_____assert(local0);
	List__Ptr__CallArg______* local1 = (e__)->args__;
	uint__ local2 = (uint__)(0);
	mu_____boundscheck(local2 < (uint__)local1->count__);
	Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, (((CallArg__**)local1->dataPtr__)[local2])->expr__);
	bool__ local3 = ((tag__).kind__) == (TagKind__number__);
	if (local3) {
		local3 = (((tag__).q__)) > ((0));
	}
	mu_____assert(local3);
	List__Ptr__CallArg______* local4 = (e__)->args__;
	uint__ local5 = (uint__)(1);
	mu_____boundscheck(local5 < (uint__)local4->count__);
	int__ n__ = TypeChecker__unpackInt__(Map__get__Node__Value____((s__)->constMap__, (((CallArg__**)local4->dataPtr__)[local5])->expr__));
	List__Ptr__CallArg______* local6 = (e__)->args__;
	uint__ local7 = (uint__)(0);
	mu_____boundscheck(local7 < (uint__)local6->count__);
	EmulatorStep__expression__(s__, (((CallArg__**)local6->dataPtr__)[local7])->expr__);
	{
		int__ i__ = 1;
		while (((i__)) < ((n__))) {
			EmulatorStep__emit__(s__, Opcode__dup__);
			EmulatorStep__emiti__(s__, Opcode__shlOr__, (tag__).q__);
			i__ += 1;
		}
	}
}
void__ EmulatorStep__swizzle__(EmulatorState__* s__, CallExpression__* e__) {
	bool__ local0 = (((s__)->evalCtxField__)) == ((-1));
	if (local0) {
		local0 = (((s__)->evalCtxOutput__)) == ((-1));
	}
	mu_____assert(local0);
	List__Ptr__CallArg______* local1 = (e__)->args__;
	uint__ local2 = (uint__)(0);
	mu_____boundscheck(local2 < (uint__)local1->count__);
	int__ targetWidth__ = TypeChecker__unpackWidth__(Map__get__Node__Tag____((s__)->typeMap__, (((CallArg__**)local1->dataPtr__)[local2])->expr__));
	List__Ptr__CallArg______* local3 = (e__)->args__;
	uint__ local4 = (uint__)(1);
	mu_____boundscheck(local4 < (uint__)local3->count__);
	int__ seqSize__ = TypeChecker__unpackInt__(Map__get__Node__Value____((s__)->constMap__, (((CallArg__**)local3->dataPtr__)[local4])->expr__));
	List__Ptr__CallArg______* local5 = (e__)->args__;
	uint__ local6 = (uint__)(2);
	mu_____boundscheck(local6 < (uint__)local5->count__);
	int__ readStep__ = TypeChecker__unpackInt__(Map__get__Node__Value____((s__)->constMap__, (((CallArg__**)local5->dataPtr__)[local6])->expr__));
	List__Ptr__CallArg______* local7 = (e__)->args__;
	uint__ local8 = (uint__)(3);
	mu_____boundscheck(local8 < (uint__)local7->count__);
	int__ blockSize__ = TypeChecker__unpackInt__(Map__get__Node__Value____((s__)->constMap__, (((CallArg__**)local7->dataPtr__)[local8])->expr__));
	List__Ptr__CallArg______* local9 = (e__)->args__;
	uint__ local10 = (uint__)(0);
	mu_____boundscheck(local10 < (uint__)local9->count__);
	EmulatorStep__expression__(s__, (((CallArg__**)local9->dataPtr__)[local10])->expr__);
	EmulatorStep__emiti__(s__, Opcode__push__, targetWidth__);
	EmulatorStep__emiti__(s__, Opcode__push__, seqSize__);
	EmulatorStep__emiti__(s__, Opcode__push__, readStep__);
	EmulatorStep__emiti__(s__, Opcode__push__, blockSize__);
	EmulatorStep__emit__(s__, Opcode__swizzle__);
}
void__ EmulatorStep__structInit__(EmulatorState__* s__, StructInitializerExpression__* e__) {
	mu_____assert((((s__)->evalCtxField__)) >= ((0)));
	Node__ local0;
	local0.dataPtr__ = (pointer__)(e__);
	local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__StructInitializerExpression____ : 0;
	Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local0);
	mu_____assert(((tag__).kind__) == (TagKind__struct___));
	List__Node____* local2 = (s__)->entities__;
	uint__ local3 = (uint__)((tag__).q__);
	mu_____boundscheck(local3 < (uint__)local2->count__);
	Node__ local1 = ((Node__*)local2->dataPtr__)[local3];
	mu_____checkedcast(local1.id__ == Node_____Ptr__StructDef____);
	StructDef__* def__ = (StructDef__*)(local1.dataPtr__);
	Array__int____* local4 = (e__)->fieldIndexToArgIndex__;
	uint__ local5 = (uint__)((s__)->evalCtxField__);
	mu_____boundscheck(local5 < (uint__)local4->count__);
	int__ argIndex__ = ((int__*)local4->dataPtr__)[local5];
	if (((argIndex__)) >= ((0))) {
		List__Ptr__CallArg______* local6 = (e__)->args__;
		uint__ local7 = (uint__)(argIndex__);
		mu_____boundscheck(local7 < (uint__)local6->count__);
		Node__ arg__ = (((CallArg__**)local6->dataPtr__)[local7])->expr__;
		int__ prevCtxField__ = (s__)->evalCtxField__;
		(s__)->evalCtxField__ = -1;
		EmulatorStep__expression__(s__, arg__);
		(s__)->evalCtxField__ = prevCtxField__;
	} else {
		EmulatorStep__emit__(s__, Opcode__push__);
	}
}
void__ EmulatorStep__call__(EmulatorState__* s__, CallExpression__* e__) {
	if (((e__)->builtin__) == (BuiltinCall__rep__)) {
		EmulatorStep__rep__(s__, e__);
		return;
	} else {
		if (((e__)->builtin__) == (BuiltinCall__slice__)) {
			EmulatorStep__slice__(s__, e__);
			return;
		} else {
			if (((e__)->builtin__) == (BuiltinCall__chunk__)) {
				EmulatorStep__chunk__(s__, e__);
				return;
			} else {
				if (((e__)->builtin__) == (BuiltinCall__swizzle__)) {
					EmulatorStep__swizzle__(s__, e__);
					return;
				}
			}
		}
	}
	mu_____assert(((e__)->builtin__) == (BuiltinCall__none__));
	mu_____assert((((s__)->evalCtxOutput__)) >= ((0)));
	List__Ptr__ModuleInstance______* local0 = (s__)->moduleInstances__;
	Array__int____* local2 = ((s__)->inst__)->calls__;
	uint__ local3 = (uint__)((e__)->callId__);
	mu_____boundscheck(local3 < (uint__)local2->count__);
	uint__ local1 = (uint__)(((int__*)local2->dataPtr__)[local3]);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	ModuleInstance__* target__ = ((ModuleInstance__**)local0->dataPtr__)[local1];
	mu_____assert((((target__)->def__)->blackboxKeyword__) == (null__));
	List__Ptr__AssignStatement______* local4 = ((target__)->def__)->outputs__;
	uint__ local5 = (uint__)((s__)->evalCtxOutput__);
	mu_____boundscheck(local5 < (uint__)local4->count__);
	AssignStatement__* output__ = ((AssignStatement__**)local4->dataPtr__)[local5];
	Array__int____* local6 = (target__)->localState__;
	uint__ local7 = (uint__)((output__)->localId__);
	mu_____boundscheck(local7 < (uint__)local6->count__);
	int__ local8 = (s__)->evalCtxField__;
	int__ local9 = 0;
	int__ si__ = ((((int__*)local6->dataPtr__)[local7])) + (((local8 > local9) ? local8 : local9));
	EmulatorStep__emiti__(s__, Opcode__load__, si__);
}
void__ EmulatorStep__patch__(EmulatorState__* s__, int__ index__) {
	List__Instruction____* local0 = (s__)->tape__;
	uint__ local1 = (uint__)(index__);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	Opcode__ op__ = (((Instruction__*)local0->dataPtr__)[local1]).op__;
	bool__ local2 = (op__) == (Opcode__jump__);
	if (!local2) {
		local2 = (op__) == (Opcode__jumpIfZero__);
	}
	mu_____assert(local2);
	List__Instruction____* local3 = (s__)->tape__;
	uint__ local4 = (uint__)(index__);
	mu_____boundscheck(local4 < (uint__)local3->count__);
	int__ local5 = ((((((s__)->tape__)->count__)) - ((index__)))) - ((1));
	mu_____checkedcast(0 <= local5);
	(((Instruction__*)local3->dataPtr__)[local4]).z__ = (ulong__)(local5);
}
void__ EmulatorStep__expression__(EmulatorState__* s__, Node__ e__) {
	Value__ val__ = Map__getOrDefault__Node__Value____((s__)->constMap__, e__);
	if (((val__).kind__) != (ValueKind__none__)) {
		bool__ local0 = (((s__)->evalCtxField__)) == ((-1));
		if (local0) {
			local0 = (((s__)->evalCtxOutput__)) == ((-1));
		}
		mu_____assert(local0);
		EmulatorStep__pushValue__(s__, val__);
	} else {
		EmulatorStep__expressionInner__(s__, e__);
	}
}
void__ EmulatorStep__match___(EmulatorState__* s__, MatchExpression__* e__) {
	List__int____* local0 = (List__int____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__int____));
	List__int____ local1;
	memset(&local1, 0, sizeof(List__int____));
	*local0 = local1;
	List__int____* jumps__ = local0;
	EmulatorStep__expression__(s__, (e__)->target__);
	{
		List__Ptr__MatchExpressionCase______* local2 = (e__)->cases__;
		int__ local3 = 0;
		while (local3 < local2->count__) {
			MatchExpressionCase__* c__ = ((MatchExpressionCase__**)(local2->dataPtr__))[local3];
			EmulatorStep__emit__(s__, Opcode__dup__);
			EmulatorStep__expression__(s__, (c__)->valueExpr__);
			EmulatorStep__emit__(s__, Opcode__eq__);
			int__ next__ = EmulatorStep__emit__(s__, Opcode__jumpIfZero__);
			EmulatorStep__emit__(s__, Opcode__discard__);
			EmulatorStep__expression__(s__, (c__)->resultExpr__);
			List__add__int____(jumps__, EmulatorStep__emit__(s__, Opcode__jump__));
			EmulatorStep__patch__(s__, next__);
			local3 += 1;
		}
	}
	EmulatorStep__emit__(s__, Opcode__discard__);
	EmulatorStep__emit__(s__, Opcode__push__);
	{
		List__int____* local4 = jumps__;
		int__ local5 = 0;
		while (local5 < local4->count__) {
			int__ j__ = ((int__*)(local4->dataPtr__))[local5];
			EmulatorStep__patch__(s__, j__);
			local5 += 1;
		}
	}
}
void__ EmulatorStep__index__(EmulatorState__* s__, IndexExpression__* e__) {
	ulong__ upper__ = (Map__get__Node__Value____((s__)->constMap__, (e__)->upperExpr__)).z__;
	ulong__ local0;
	if ((((e__)->lowerExpr__).dataPtr__) != ((pointer__)(null__))) {
		local0 = (Map__get__Node__Value____((s__)->constMap__, (e__)->lowerExpr__)).z__;
	} else {
		local0 = upper__;
	}
	ulong__ lower__ = local0;
	EmulatorStep__expression__(s__, (e__)->target__);
	ulong__ bits__ = ((((upper__)) - ((lower__)))) + ((ulong__)(1));
	if (((bits__)) < ((ulong__)(64))) {
		EmulatorStep__emitz__(s__, Opcode__index__, ((((ulong__)lower__) << (32))) | ((((bits__)) & ((4294967295uLL)))));
	} else {
		bool__ local1 = ((upper__)) == ((ulong__)(63));
		if (local1) {
			local1 = ((lower__)) == ((ulong__)(0));
		}
		mu_____assert(local1);
	}
}
void__ EmulatorStep__mask__(EmulatorState__* s__, Tag__ tag__) {
	bool__ local0 = ((tag__).kind__) == (TagKind__number__);
	if (local0) {
		local0 = (((tag__).q__)) <= ((64));
	}
	mu_____assert(local0);
	bool__ local1 = (((tag__).q__)) > ((0));
	if (local1) {
		local1 = (((tag__).q__)) < ((64));
	}
	if (local1) {
		EmulatorStep__emitz__(s__, Opcode__mask__, ((((ulong__)1uLL) << ((tag__).q__))) - ((ulong__)(1)));
	}
}
void__ EmulatorStep__ternaryOperator__(EmulatorState__* s__, TernaryOperatorExpression__* e__) {
	EmulatorStep__expression__(s__, (e__)->conditionExpr__);
	int__ pc__ = EmulatorStep__emit__(s__, Opcode__jumpIfZero__);
	EmulatorStep__expression__(s__, (e__)->trueExpr__);
	int__ trueEnd__ = EmulatorStep__emit__(s__, Opcode__jump__);
	EmulatorStep__patch__(s__, pc__);
	EmulatorStep__expression__(s__, (e__)->falseExpr__);
	EmulatorStep__patch__(s__, trueEnd__);
}
void__ EmulatorStep__slot__(EmulatorState__* s__, int__ si__) {
	List__SlotInfo____* local0 = (s__)->infos__;
	uint__ local1 = (uint__)(si__);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	SlotInfo__ info__ = ((SlotInfo__*)local0->dataPtr__)[local1];
	Node__ node__ = (info__).node__;
	(s__)->evalCtxField__ = (info__).field__;
	switch ((node__).id__) {
		case Node_____Ptr__ModuleInputDef____: {
			ModuleInputDef__* local2 = (ModuleInputDef__*)(node__.dataPtr__);
			{
				ModuleInstance__* caller__ = ((info__).inst__)->caller__;
				CallExpression__* e__ = ((info__).inst__)->callExpr__;
				(s__)->inst__ = caller__;
				List__Ptr__CallArg______* local3 = (e__)->args__;
				Array__int____* local5 = (e__)->calleeLocalIdToArgIndex__;
				uint__ local6 = (uint__)((local2)->localId__);
				mu_____boundscheck(local6 < (uint__)local5->count__);
				uint__ local4 = (uint__)(((int__*)local5->dataPtr__)[local6]);
				mu_____boundscheck(local4 < (uint__)local3->count__);
				EmulatorStep__expression__(s__, (((CallArg__**)local3->dataPtr__)[local4])->expr__);
			}
			break;
		}
		case Node_____Ptr__AssignStatement____: {
			AssignStatement__* local7 = (AssignStatement__*)(node__.dataPtr__);
			{
				(s__)->inst__ = (info__).inst__;
				EmulatorStep__expression__(s__, (local7)->expr__);
			}
			break;
		}
		case 0:
		default: {
			mu_____nomatch();
		}
	}
	EmulatorStep__emiti__(s__, Opcode__store__, si__);
}
void__ EmulatorStep__token__(EmulatorState__* s__, Token__* e__) {
	string__ name__ = (e__)->value__;
	Node__ local0;
	if (((s__)->inst__) != (null__)) {
		local0 = Map__getOrDefault__string__Node____((((s__)->inst__)->def__)->symbols__, name__);
	} else {
		Node__ local1;
		local1.dataPtr__ = null__;
		local1.id__ = 0;
		local0 = local1;
	}
	Node__ node__ = local0;
	switch ((node__).id__) {
		case Node_____Ptr__ModuleInputDef____: {
			ModuleInputDef__* local2 = (ModuleInputDef__*)(node__.dataPtr__);
			{
				Array__int____* local3 = ((s__)->inst__)->localState__;
				uint__ local4 = (uint__)((local2)->localId__);
				mu_____boundscheck(local4 < (uint__)local3->count__);
				int__ local5 = (s__)->evalCtxField__;
				int__ local6 = 0;
				int__ si__ = ((((int__*)local3->dataPtr__)[local4])) + (((local5 > local6) ? local5 : local6));
				EmulatorStep__emiti__(s__, Opcode__load__, si__);
			}
			break;
		}
		case Node_____Ptr__AssignStatement____: {
			AssignStatement__* local7 = (AssignStatement__*)(node__.dataPtr__);
			{
				Array__int____* local8 = ((s__)->inst__)->localState__;
				uint__ local9 = (uint__)((local7)->localId__);
				mu_____boundscheck(local9 < (uint__)local8->count__);
				int__ local10 = (s__)->evalCtxField__;
				int__ local11 = 0;
				int__ si__ = ((((int__*)local8->dataPtr__)[local9])) + (((local10 > local11) ? local10 : local11));
				if (((si__)) >= ((0))) {
					EmulatorStep__emiti__(s__, Opcode__load__, si__);
				} else {
					EmulatorStep__expression__(s__, (local7)->expr__);
				}
			}
			break;
		}
		default: {
			{
				node__ = Map__getOrDefault__string__Node____((s__)->symbols__, name__);
				switch ((node__).id__) {
					case Node_____Ptr__ConstDef____: {
						ConstDef__* local12 = (ConstDef__*)(node__.dataPtr__);
						{
							bool__ local13 = (((s__)->evalCtxField__)) == ((-1));
							if (local13) {
								local13 = (((s__)->evalCtxOutput__)) == ((-1));
							}
							mu_____assert(local13);
							EmulatorStep__pushValue__(s__, Map__get__Node__Value____((s__)->constMap__, (local12)->expr__));
						}
						break;
					}
					case 0:
					default: {
						mu_____nomatch();
					}
				}
			}
			break;
		}
		case 0: {
			mu_____nomatch();
		}
	}
}
void__ EmulatorStep__brace__(EmulatorState__* s__, BraceExpression__* e__) {
	bool__ local0 = (((s__)->evalCtxField__)) == ((-1));
	if (local0) {
		local0 = (((s__)->evalCtxOutput__)) == ((-1));
	}
	mu_____assert(local0);
	{
		List__Node____* local1 = (e__)->args__;
		int__ i__ = 0;
		while (i__ < local1->count__) {
			Node__ arg__ = ((Node__*)(local1->dataPtr__))[i__];
			Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, arg__);
			bool__ local2 = ((tag__).kind__) == (TagKind__number__);
			if (local2) {
				local2 = (((tag__).q__)) > ((0));
			}
			mu_____assert(local2);
			EmulatorStep__expression__(s__, arg__);
			if (((i__)) > ((0))) {
				EmulatorStep__emiti__(s__, Opcode__shlOr__, (tag__).q__);
			}
			i__ += 1;
		}
	}
}
void__ top_____main__() {
	top_____currentAllocator__ = Memory__newArenaAllocator__((ssize__)(((((256)) * ((1024)))) * ((1024))));
	CrashHandler__enable__();
	List__CommandLineArgsParserError____* local0 = (List__CommandLineArgsParserError____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__CommandLineArgsParserError____));
	List__CommandLineArgsParserError____ local1;
	memset(&local1, 0, sizeof(List__CommandLineArgsParserError____));
	*local0 = local1;
	List__CommandLineArgsParserError____* argErrors__ = local0;
	CommandLineArgsParser__* local2 = (CommandLineArgsParser__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(CommandLineArgsParser__));
	*local2 = CommandLineArgsParser__from__(Environment__getCommandLineArgs__(), argErrors__);
	CommandLineArgsParser__* parser__ = local2;
	Args__* args__ = top_____parseArgs__(parser__, true__);
	if ((((argErrors__)->count__)) > ((0))) {
		CommandLineInfo__ info__ = CommandLineArgsParser__getCommandLineInfo__(parser__);
		{
			List__CommandLineArgsParserError____* local3 = argErrors__;
			int__ local4 = 0;
			while (local4 < local3->count__) {
				CommandLineArgsParserError__ it__ = ((CommandLineArgsParserError__*)(local3->dataPtr__))[local4];
				Stderr__writeLine__(CommandLineArgsParser__getErrorDesc__(it__, info__));
				local4 += 1;
			}
		}
		exit(1);
	}
	bool__ local5 = (args__)->printVersion__;
	if (!local5) {
		local5 = (args__)->printHelp__;
	}
	if (local5) {
		StringBuilder__ local6;
		memset(&local6, 0, sizeof(local6));
		string__ local7 = { (pointer__)"Wyre compiler, version ", 23 };
		StringBuilder__write__(&local6, local7);
		StringBuilder__write__(&local6, top_____compilerVersion__);
		Stdout__writeLine__(StringBuilder__compactToString__(&local6));
		if ((args__)->printHelp__) {
			Stdout__writeLine__(mu_____string282);
		}
		exit(1);
	}
	Compilation__* local8 = (Compilation__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Compilation__));
	Compilation__ local9;
	memset(&local9, 0, sizeof(Compilation__));
	local9.sources__ = (args__)->sources__;
	List__Error____* local10 = (List__Error____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Error____));
	List__Error____ local11;
	memset(&local11, 0, sizeof(List__Error____));
	*local10 = local11;
	local9.errors__ = local10;
	List__Ptr__CodeUnit______* local12 = (List__Ptr__CodeUnit______*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Ptr__CodeUnit______));
	List__Ptr__CodeUnit______ local13;
	memset(&local13, 0, sizeof(List__Ptr__CodeUnit______));
	*local12 = local13;
	local9.units__ = local12;
	*local8 = local9;
	Compilation__* comp__ = local8;
	{
		List__Ptr__SourceFile______* local14 = (comp__)->sources__;
		int__ i__ = 0;
		while (i__ < local14->count__) {
			SourceFile__* sf__ = ((SourceFile__**)(local14->dataPtr__))[i__];
			CodeUnit__* unit__ = Parser__unit__((sf__)->text__, (comp__)->errors__, (args__)->indent__);
			(unit__)->path__ = (sf__)->path__;
			(unit__)->id__ = i__;
			List__add__Ptr__CodeUnit______((comp__)->units__, unit__);
			i__ += 1;
		}
	}
	Indexer__comp__(comp__);
	Node__ top__ = Map__getOrDefault__string__Node____((comp__)->symbols__, (args__)->top__);
	if ((top__).id__ == Node_____Ptr__ModuleDef____) {
		Node__ local15 = top__;
		mu_____checkedcast(local15.id__ == Node_____Ptr__ModuleDef____);
		Node__ local16 = top__;
		mu_____checkedcast(local16.id__ == Node_____Ptr__ModuleDef____);
		((ModuleDef__*)(local15.dataPtr__))->flags__ = ((((ModuleDef__*)(local16.dataPtr__))->flags__)) | ((ModuleFlags__top__));
	} else {
		Error__ local17;
		memset(&local17, 0, sizeof(Error__));
		StringBuilder__ local18;
		memset(&local18, 0, sizeof(local18));
		string__ local19 = { (pointer__)"Top module not found: ", 22 };
		StringBuilder__write__(&local18, local19);
		StringBuilder__write__(&local18, (args__)->top__);
		local17.text__ = StringBuilder__compactToString__(&local18);
		List__add__Error____((comp__)->errors__, local17);
	}
	TypeChecker__comp__(comp__);
	EmulatorState__* es__ = (EmulatorState__*)(null__);
	if (((((comp__)->errors__)->count__)) == ((0))) {
		Node__ local20 = top__;
		mu_____checkedcast(local20.id__ == Node_____Ptr__ModuleDef____);
		es__ = Emulator__init__(comp__, (ModuleDef__*)(local20.dataPtr__));
		Emulator__reset__(es__);
	}
	Array__Error____ local21 = List__slice__Error____((comp__)->errors__, 0, (comp__)->nonSyntaxErrorStart__);
	Array__stableSort__Error____(&local21, &ErrorHelper__compareErrors__);
	Array__Error____ local22 = List__slice__Error____((comp__)->errors__, (comp__)->nonSyntaxErrorStart__, ((comp__)->errors__)->count__);
	Array__stableSort__Error____(&local22, &ErrorHelper__compareErrors__);
	if (((((comp__)->errors__)->count__)) > ((0))) {
		{
			List__Error____* local23 = (comp__)->errors__;
			int__ i__ = 0;
			while (i__ < local23->count__) {
				Error__ e__ = ((Error__*)(local23->dataPtr__))[i__];
				if (((i__)) >= (((args__)->maxErrors__))) {
					goto label4;
				}
				if (((e__).unit__) != (null__)) {
					Stdout__writeLine__(ErrorHelper__getErrorDesc__(((e__).unit__)->path__, ((e__).unit__)->source__, (e__).span__, (e__).text__));
				} else {
					Stdout__writeLine__((e__).text__);
				}
				i__ += 1;
			}
		label4:
			{}
		}
		if (((((comp__)->errors__)->count__)) > (((args__)->maxErrors__))) {
			StringBuilder__ local24;
			memset(&local24, 0, sizeof(local24));
			int__writeTo__(((comp__)->errors__)->count__, &local24);
			string__ local25 = { (pointer__)" errors (", 9 };
			StringBuilder__write__(&local24, local25);
			int__writeTo__((args__)->maxErrors__, &local24);
			string__ local26 = { (pointer__)" shown)", 7 };
			StringBuilder__write__(&local24, local26);
			Stdout__writeLine__(StringBuilder__compactToString__(&local24));
		} else {
			StringBuilder__ local27;
			memset(&local27, 0, sizeof(local27));
			int__writeTo__(((comp__)->errors__)->count__, &local27);
			string__ local28 = { (pointer__)" errors", 7 };
			StringBuilder__write__(&local27, local28);
			Stdout__writeLine__(StringBuilder__compactToString__(&local27));
		}
		exit(1);
	}
	CodeBuilder__* out__ = VerilogGenerator__comp__(comp__, es__);
	if (!(File__tryWriteString__((args__)->outputPath__, StringBuilder__compactToString__((out__)->sb__)))) {
		StringBuilder__ local29;
		memset(&local29, 0, sizeof(local29));
		string__ local30 = { (pointer__)"Could not write to output file: ", 32 };
		StringBuilder__write__(&local29, local30);
		StringBuilder__write__(&local29, (args__)->outputPath__);
		Stderr__writeLine__(StringBuilder__compactToString__(&local29));
		exit(1);
	}
	StringBuilder__ local31;
	memset(&local31, 0, sizeof(local31));
	string__ local32 = { (pointer__)"Generated output: ", 18 };
	StringBuilder__write__(&local31, local32);
	StringBuilder__write__(&local31, (args__)->outputPath__);
	Stdout__writeLine__(StringBuilder__compactToString__(&local31));
}
void__ Stderr__write__(string__ s__) {
	fprintf((FILE *)CStdlib__stderr__, (cstring__)((mu_____string6).dataPtr__), (s__).length__, (s__).dataPtr__);
}
void__ Stderr__writeLine__(string__ s__) {
	fprintf((FILE *)CStdlib__stderr__, (cstring__)((mu_____string7).dataPtr__), (s__).length__, (s__).dataPtr__);
}
pointer__ IAllocator__alloc__(IAllocator__ a__, ssize__ numBytes__) {
	return (a__).allocFn__((a__).data__, numBytes__);
}
pointer__ IAllocator__realloc__(IAllocator__ a__, pointer__ ptr__, ssize__ newSizeInBytes__, ssize__ prevSizeInBytes__, ssize__ copySizeInBytes__) {
	return (a__).reallocFn__((a__).data__, ptr__, newSizeInBytes__, prevSizeInBytes__, copySizeInBytes__);
}
void__ IAllocator__free__(IAllocator__ a__, pointer__ ptr__) {
	(a__).freeFn__((a__).data__, ptr__);
}
uint__ char__hash__(char__ ch__) {
	return (uint__)(unsigned char)(ch__);
}
int__ char__compare__(char__ a__, char__ b__) {
	if (((unsigned char)(a__)) < ((unsigned char)(b__))) {
		return -1;
	} else {
		if (((unsigned char)(a__)) > ((unsigned char)(b__))) {
			return 1;
		}
	}
	return 0;
}
void__ char__writeTo__(char__ ch__, StringBuilder__* sb__) {
	StringBuilder__writeChar__(sb__, ch__);
}
uint__ byte__hash__(byte__ val__) {
	return (uint__)(val__);
}
void__ byte__writeTo__(byte__ val__, StringBuilder__* sb__) {
	ulong__writeTo__((ulong__)(val__), sb__);
}
Args__* top_____parseArgs__(CommandLineArgsParser__* parser__, bool__ isCompiler__) {
	Args__* local0 = (Args__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Args__));
	Args__ local1;
	memset(&local1, 0, sizeof(Args__));
	List__Ptr__SourceFile______* local2 = (List__Ptr__SourceFile______*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Ptr__SourceFile______));
	List__Ptr__SourceFile______ local3;
	memset(&local3, 0, sizeof(List__Ptr__SourceFile______));
	*local2 = local3;
	local1.sources__ = local2;
	*local0 = local1;
	Args__* args__ = local0;
	string__ token__ = CommandLineArgsParser__readToken__(parser__);
	if (string__equals__(token__, mu_____string0)) {
		(args__)->printHelp__ = true__;
	}
	bool__ hasIndent__ = false__;
	bool__ hasMaxErrors__ = false__;
	while (true__) {
		if (!(!string__equals__(token__, mu_____string0))) { break; }
		if (string__startsWith__(token__, mu_____string2)) {
			if (string__equals__(token__, mu_____string83)) {
				token__ = CommandLineArgsParser__readToken__(parser__);
				if (!string__equals__(token__, mu_____string0)) {
					(args__)->top__ = token__;
				} else {
					CommandLineArgsParser__expected__(parser__, mu_____string84);
				}
			} else {
				if (string__equals__(token__, mu_____string85)) {
					token__ = CommandLineArgsParser__readToken__(parser__);
					if (!string__equals__(token__, mu_____string0)) {
						(args__)->outputPath__ = token__;
					} else {
						CommandLineArgsParser__expected__(parser__, mu_____string86);
					}
				} else {
					if (string__equals__(token__, mu_____string87)) {
						Maybe__int____ num__ = top_____parseInt__(parser__);
						if ((num__).hasValue__) {
							if ((((num__).value__)) >= ((0))) {
								(args__)->indent__ = (num__).value__;
								hasIndent__ = true__;
							} else {
								CommandLineArgsParser__error__(parser__, mu_____string90);
							}
						}
					} else {
						if (string__equals__(token__, mu_____string91)) {
							Maybe__int____ num__ = top_____parseInt__(parser__);
							if ((num__).hasValue__) {
								if ((((num__).value__)) > ((0))) {
									(args__)->maxErrors__ = (num__).value__;
									hasMaxErrors__ = true__;
								} else {
									CommandLineArgsParser__error__(parser__, mu_____string92);
								}
							}
						} else {
							if (string__equals__(token__, mu_____string93)) {
								(args__)->printVersion__ = true__;
							} else {
								if (string__equals__(token__, mu_____string94)) {
									(args__)->printHelp__ = true__;
								} else {
									StringBuilder__ local4;
									memset(&local4, 0, sizeof(local4));
									string__ local5 = { (pointer__)"Invalid flag: ", 14 };
									StringBuilder__write__(&local4, local5);
									StringBuilder__write__(&local4, token__);
									CommandLineArgsParser__error__(parser__, StringBuilder__compactToString__(&local4));
								}
							}
						}
					}
				}
			}
		} else {
			SourceFile__* sf__ = top_____tryReadSourceFile__(token__);
			if ((sf__) != (null__)) {
				List__add__Ptr__SourceFile______((args__)->sources__, sf__);
			} else {
				StringBuilder__ local6;
				memset(&local6, 0, sizeof(local6));
				string__ local7 = { (pointer__)"Could not read file: ", 21 };
				StringBuilder__write__(&local6, local7);
				StringBuilder__write__(&local6, token__);
				CommandLineArgsParser__error__(parser__, StringBuilder__compactToString__(&local6));
			}
		}
		token__ = CommandLineArgsParser__readToken__(parser__);
	}
	bool__ local8 = (args__)->printHelp__;
	if (!local8) {
		local8 = (args__)->printVersion__;
	}
	if (local8) {
		return args__;
	}
	if (((((args__)->sources__)->count__)) == ((0))) {
		CommandLineArgsParser__expected__(parser__, mu_____string97);
	}
	if (string__equals__((args__)->top__, mu_____string0)) {
		CommandLineArgsParser__expected__(parser__, mu_____string98);
	}
	bool__ local9 = string__equals__((args__)->outputPath__, mu_____string0);
	if (local9) {
		local9 = isCompiler__;
	}
	if (local9) {
		CommandLineArgsParser__expected__(parser__, mu_____string99);
	}
	bool__ local10 = !(hasIndent__);
	if (local10) {
		local10 = isCompiler__;
	}
	if (local10) {
		CommandLineArgsParser__expected__(parser__, mu_____string100);
	}
	if (!(hasMaxErrors__)) {
		CommandLineArgsParser__expected__(parser__, mu_____string101);
	}
	return args__;
}
uint__ bool32__hash__(bool32__ val__) {
	union { bool32__ from; uint__ to; } local0;
	memset(&local0, 0, sizeof(local0));
	local0.from = val__;
	return local0.to;
}
void__ bool32__writeTo__(bool32__ val__, StringBuilder__* sb__) {
	if (val__) {
		StringBuilder__write__(sb__, mu_____string4);
	} else {
		StringBuilder__write__(sb__, mu_____string5);
	}
}
uint__ pointer__hash__(pointer__ p__) {
	return (uint__)(((usize__)(usize__)(uintptr_t)(p__)) >> (3));
}
ssize__ pointer__subtractSigned__(pointer__ a__, pointer__ b__) {
	union { usize__ from; ssize__ to; } local0;
	memset(&local0, 0, sizeof(local0));
	local0.from = (((usize__)(uintptr_t)(a__))) - (((usize__)(uintptr_t)(b__)));
	return local0.to;
}
usize__ pointer__subtractUnsigned__(pointer__ a__, pointer__ b__) {
	return (((usize__)(uintptr_t)(a__))) - (((usize__)(uintptr_t)(b__)));
}
int__ pointer__compare__(pointer__ a__, pointer__ b__) {
	if ((a__) < (b__)) {
		return -1;
	} else {
		if ((a__) > (b__)) {
			return 1;
		}
	}
	return 0;
}
void__ pointer__writeTo__(pointer__ p__, StringBuilder__* sb__) {
	ulong__writeHexTo__((ulong__)(uintptr_t)(p__), sb__);
}
uint__ cstring__hash__(cstring__ cstr__) {
	return (uint__)(((usize__)(usize__)(uintptr_t)(cstr__)) >> (3));
}
int__ cstring__length__(cstring__ cstr__) {
	pointer__ from__ = (pointer__)(cstr__);
	pointer__ p__ = from__;
	while (true__) {
		if (!(((int__)(*((byte__*)(p__)))) != ((0)))) { break; }
		p__ = (p__) + (1);
	}
	ssize__ local0 = pointer__subtractSigned__(p__, from__);
	mu_____checkedcast(local0 + ((ssize__)0x7fffffff) + 1 <= (ssize__)(0xffffffffu));
	return (int__)(local0);
}
void__ cstring__writeTo__(cstring__ cstr__, StringBuilder__* sb__) {
	StringBuilder__write__(sb__, string__from_cstring__(cstr__));
}
IntRange__ IntRange__cons__(int__ from__, int__ to__) {
	IntRange__ local0;
	memset(&local0, 0, sizeof(IntRange__));
	local0.from__ = from__;
	local0.to__ = to__;
	return local0;
}
uint__ Node__hash__(Node__ n__) {
	return (uint__)(((usize__)(usize__)(uintptr_t)((pointer__)((n__).dataPtr__))) >> (3));
}
Tag__ Tag__cons__(TagKind__ kind__, int__ q__) {
	Tag__ local0;
	memset(&local0, 0, sizeof(Tag__));
	local0.kind__ = kind__;
	local0.q__ = q__;
	return local0;
}
bool__ Tag__isValid__(Tag__ t__) {
	return ((t__).kind__) != (TagKind__unknown__);
}
void__ EmulatorAllocator__block__(EmulatorState__* s__, Block__* st__) {
	{
		List__Node____* local0 = (st__)->contents__;
		int__ local1 = 0;
		while (local1 < local0->count__) {
			Node__ n__ = ((Node__*)(local0->dataPtr__))[local1];
			switch ((n__).id__) {
				case Node_____Ptr__ClockStatement____: {
					ClockStatement__* local2 = (ClockStatement__*)(n__.dataPtr__);
					EmulatorAllocator__block__(s__, (local2)->body__);
					break;
				}
				case Node_____Ptr__IfStatement____: {
					IfStatement__* local3 = (IfStatement__*)(n__.dataPtr__);
					EmulatorAllocator__if___(s__, local3);
					break;
				}
				case Node_____Ptr__AssignStatement____: {
					AssignStatement__* local4 = (AssignStatement__*)(n__.dataPtr__);
					EmulatorAllocator__assign__(s__, local4);
					break;
				}
				case 0:
				default: {
					mu_____nomatch();
				}
			}
			local1 += 1;
		}
	}
}
Value__ EmulatorAllocator__createValue__(EmulatorState__* s__, Tag__ tag__, bool__ allocArray__) {
	bool__ local0 = ((tag__).kind__) == (TagKind__number__);
	if (local0) {
		local0 = (((tag__).q__)) > ((64));
	}
	if (local0) {
		Value__ local1;
		memset(&local1, 0, sizeof(Value__));
		local1.kind__ = ValueKind__byteArray__;
		ulong__ local2;
		if (allocArray__) {
			Array__byte____* local3 = (Array__byte____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__byte____));
			*local3 = Array__cons__byte____((((((tag__).q__)) + ((7)))) / ((8)));
			local2 = (ulong__)(uintptr_t)(local3);
		} else {
			local2 = (ulong__)(0);
		}
		local1.z__ = local2;
		return local1;
	} else {
		if (((tag__).kind__) == (TagKind__number__)) {
			Value__ local4;
			memset(&local4, 0, sizeof(Value__));
			local4.kind__ = ValueKind__ulong___;
			return local4;
		} else {
			mu_____abandon(-1);
			Value__ local5;
			memset(&local5, 0, sizeof(Value__));
			return local5;
		}
	}
}
void__ EmulatorAllocator__call__(EmulatorState__* s__, CallExpression__* e__, string__ name__) {
	{
		List__Ptr__CallArg______* local0 = (e__)->args__;
		int__ local1 = 0;
		while (local1 < local0->count__) {
			CallArg__* arg__ = ((CallArg__**)(local0->dataPtr__))[local1];
			if ((((arg__)->expr__).dataPtr__) != ((pointer__)(null__))) {
				EmulatorAllocator__expression__(s__, (arg__)->expr__);
			}
			local1 += 1;
		}
	}
	if (((e__)->builtin__) != (BuiltinCall__none__)) {
		return;
	}
	Node__ local3 = (e__)->target__;
	mu_____checkedcast(local3.id__ == Node_____Ptr__Token____);
	Node__ local2 = Map__get__string__Node____((s__)->symbols__, ((Token__*)(local3.dataPtr__))->value__);
	mu_____checkedcast(local2.id__ == Node_____Ptr__ModuleDef____);
	ModuleDef__* def__ = (ModuleDef__*)(local2.dataPtr__);
	if (string__equals__(name__, mu_____string0)) {
		Node__ local4;
		local4.dataPtr__ = (pointer__)(def__);
		local4.id__ = local4.dataPtr__ != null__ ? Node_____Ptr__ModuleDef____ : 0;
		int__ id__ = Map__getOrDefault__Node__int____((s__)->nextId__, local4);
		Node__ local5;
		local5.dataPtr__ = (pointer__)(def__);
		local5.id__ = local5.dataPtr__ != null__ ? Node_____Ptr__ModuleDef____ : 0;
		Map__addOrUpdate__Node__int____((s__)->nextId__, local5, ((id__)) + ((1)));
		StringBuilder__ local6;
		memset(&local6, 0, sizeof(local6));
		StringBuilder__write__(&local6, ((def__)->name__)->value__);
		string__ local7 = { (pointer__)"_", 1 };
		StringBuilder__write__(&local6, local7);
		int__writeTo__(id__, &local6);
		name__ = StringBuilder__compactToString__(&local6);
		mu_____assert(((Map__getOrDefault__string__Node____((s__)->symbols__, name__)).dataPtr__) == ((pointer__)(null__)));
		mu_____assert(((Map__getOrDefault__string__Node____((((s__)->inst__)->def__)->symbols__, name__)).dataPtr__) == ((pointer__)(null__)));
	}
	ModuleInstance__* prevInst__ = (s__)->inst__;
	int__ instanceId__ = EmulatorAllocator__module__(s__, def__, name__);
	((s__)->inst__)->caller__ = prevInst__;
	((s__)->inst__)->callExpr__ = e__;
	(s__)->inst__ = prevInst__;
	Array__int____* local8 = ((s__)->inst__)->calls__;
	uint__ local9 = (uint__)((e__)->callId__);
	mu_____boundscheck(local9 < (uint__)local8->count__);
	((int__*)local8->dataPtr__)[local9] = instanceId__;
}
string__ EmulatorAllocator__formatName__(string__ a__, string__ b__) {
	if (string__equals__(a__, mu_____string0)) {
		return b__;
	}
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	StringBuilder__write__(&local0, a__);
	string__ local1 = { (pointer__)".", 1 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, b__);
	return StringBuilder__compactToString__(&local0);
}
void__ EmulatorAllocator__if___(EmulatorState__* s__, IfStatement__* st__) {
	EmulatorAllocator__expression__(s__, (st__)->expr__);
	EmulatorAllocator__block__(s__, (st__)->ifBody__);
	if (((st__)->elseBranch__).id__ == Node_____Ptr__IfStatement____) {
		Node__ local0 = (st__)->elseBranch__;
		mu_____checkedcast(local0.id__ == Node_____Ptr__IfStatement____);
		EmulatorAllocator__if___(s__, (IfStatement__*)(local0.dataPtr__));
	} else {
		if (((st__)->elseBranch__).id__ == Node_____Ptr__Block____) {
			Node__ local1 = (st__)->elseBranch__;
			mu_____checkedcast(local1.id__ == Node_____Ptr__Block____);
			EmulatorAllocator__block__(s__, (Block__*)(local1.dataPtr__));
		}
	}
}
void__ EmulatorAllocator__top__(EmulatorState__* s__, ModuleDef__* def__) {
	{
		int__ i__ = 0;
		while (((i__)) < (((def__)->numRegSlots__))) {
			Value__ local0;
			memset(&local0, 0, sizeof(Value__));
			List__add__Value____((s__)->rs__, local0);
			SlotInfo__ local1;
			memset(&local1, 0, sizeof(SlotInfo__));
			List__add__SlotInfo____((s__)->infos__, local1);
			i__ += 1;
		}
	}
	EmulatorAllocator__module__(s__, def__, mu_____string0);
	mu_____assert(((((s__)->ws__)->count__)) == (((def__)->numRegSlots__)));
}
int__ EmulatorAllocator__module__(EmulatorState__* s__, ModuleDef__* def__, string__ name__) {
	string__ local0;
	if (((s__)->inst__) != (null__)) {
		local0 = EmulatorAllocator__formatName__(((s__)->inst__)->fullName__, name__);
	} else {
		local0 = name__;
	}
	string__ fullName__ = local0;
	ModuleInstance__* local1 = (ModuleInstance__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(ModuleInstance__));
	ModuleInstance__ local2;
	memset(&local2, 0, sizeof(ModuleInstance__));
	local2.def__ = def__;
	local2.localName__ = name__;
	local2.fullName__ = fullName__;
	Array__int____* local3 = (Array__int____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__int____));
	*local3 = Array__cons__int____(((((def__)->symbols__)->count__)) + ((1)));
	local2.localState__ = local3;
	Array__int____* local4 = (Array__int____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__int____));
	*local4 = Array__cons__int____((((def__)->numCalls__)) + ((1)));
	local2.calls__ = local4;
	*local1 = local2;
	(s__)->inst__ = local1;
	{
		int__ i__ = 0;
		while (((i__)) <= ((((def__)->symbols__)->count__))) {
			Array__int____* local5 = ((s__)->inst__)->localState__;
			uint__ local6 = (uint__)(i__);
			mu_____boundscheck(local6 < (uint__)local5->count__);
			((int__*)local5->dataPtr__)[local6] = -1;
			i__ += 1;
		}
	}
	int__ id__ = ((s__)->moduleInstances__)->count__;
	List__add__Ptr__ModuleInstance______((s__)->moduleInstances__, (s__)->inst__);
	{
		List__Ptr__ModuleInputDef______* local7 = (def__)->inputs__;
		int__ local8 = 0;
		while (local8 < local7->count__) {
			ModuleInputDef__* inp__ = ((ModuleInputDef__**)(local7->dataPtr__))[local8];
			Array__int____* local9 = ((s__)->inst__)->localState__;
			uint__ local10 = (uint__)((inp__)->localId__);
			mu_____boundscheck(local10 < (uint__)local9->count__);
			((int__*)local9->dataPtr__)[local10] = ((s__)->rs__)->count__;
			Node__ local11;
			local11.dataPtr__ = (pointer__)(inp__);
			local11.id__ = local11.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
			Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local11);
			bool__ isStatic__ = ((((inp__)->flags__)) & ((ModuleInputFlags__static__))) != (0);
			if (((tag__).kind__) == (TagKind__number__)) {
				List__add__Value____((s__)->rs__, EmulatorAllocator__createValue__(s__, tag__, true__));
				SlotInfo__ local12;
				memset(&local12, 0, sizeof(SlotInfo__));
				local12.name__ = EmulatorAllocator__formatName__(((s__)->inst__)->fullName__, ((inp__)->name__)->value__);
				local12.tag__ = tag__;
				local12.inst__ = (s__)->inst__;
				Node__ local13;
				local13.dataPtr__ = (pointer__)(inp__);
				local13.id__ = local13.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
				local12.node__ = local13;
				local12.field__ = -1;
				local12.isStatic__ = isStatic__;
				List__add__SlotInfo____((s__)->infos__, local12);
			} else {
				if (((tag__).kind__) == (TagKind__struct___)) {
					List__Node____* local15 = (s__)->entities__;
					uint__ local16 = (uint__)((tag__).q__);
					mu_____boundscheck(local16 < (uint__)local15->count__);
					Node__ local14 = ((Node__*)local15->dataPtr__)[local16];
					mu_____checkedcast(local14.id__ == Node_____Ptr__StructDef____);
					StructDef__* struct___ = (StructDef__*)(local14.dataPtr__);
					{
						List__Ptr__FieldDef______* local17 = (struct___)->fields__;
						int__ fi__ = 0;
						while (fi__ < local17->count__) {
							FieldDef__* f__ = ((FieldDef__**)(local17->dataPtr__))[fi__];
							Value__ local18;
							memset(&local18, 0, sizeof(Value__));
							local18.kind__ = ValueKind__ulong___;
							List__add__Value____((s__)->rs__, local18);
							string__ fname__ = EmulatorAllocator__formatName__(EmulatorAllocator__formatName__(((s__)->inst__)->fullName__, ((inp__)->name__)->value__), ((f__)->name__)->value__);
							Node__ local19;
							local19.dataPtr__ = (pointer__)(f__);
							local19.id__ = local19.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
							Tag__ ftag__ = Map__get__Node__Tag____((s__)->typeMap__, local19);
							SlotInfo__ local20;
							memset(&local20, 0, sizeof(SlotInfo__));
							local20.name__ = fname__;
							local20.tag__ = ftag__;
							local20.inst__ = (s__)->inst__;
							Node__ local21;
							local21.dataPtr__ = (pointer__)(inp__);
							local21.id__ = local21.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
							local20.node__ = local21;
							local20.field__ = fi__;
							List__add__SlotInfo____((s__)->infos__, local20);
							fi__ += 1;
						}
					}
				} else {
					mu_____abandon(-1);
					return 0;
				}
			}
			local8 += 1;
		}
	}
	EmulatorAllocator__block__(s__, (def__)->body__);
	return id__;
}
void__ EmulatorAllocator__assign__(EmulatorState__* s__, AssignStatement__* st__) {
	if (((((st__)->flags__)) & ((AssignFlags__reg__))) != (0)) {
		int__ index__ = ((s__)->ws__)->count__;
		Array__int____* local0 = ((s__)->inst__)->localState__;
		uint__ local1 = (uint__)((st__)->localId__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		((int__*)local0->dataPtr__)[local1] = index__;
		Node__ local2;
		local2.dataPtr__ = (pointer__)(st__);
		local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
		Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local2);
		if (((tag__).kind__) == (TagKind__number__)) {
			List__add__Value____((s__)->ws__, EmulatorAllocator__createValue__(s__, tag__, true__));
			List__SlotInfo____* local3 = (s__)->infos__;
			uint__ local4 = (uint__)(index__);
			mu_____boundscheck(local4 < (uint__)local3->count__);
			SlotInfo__ local5;
			memset(&local5, 0, sizeof(SlotInfo__));
			Node__ local6 = (st__)->nameExpr__;
			mu_____checkedcast(local6.id__ == Node_____Ptr__Token____);
			local5.name__ = EmulatorAllocator__formatName__(((s__)->inst__)->fullName__, ((Token__*)(local6.dataPtr__))->value__);
			local5.tag__ = tag__;
			local5.inst__ = (s__)->inst__;
			Node__ local7;
			local7.dataPtr__ = (pointer__)(st__);
			local7.id__ = local7.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
			local5.node__ = local7;
			local5.field__ = -1;
			local5.isReg__ = true__;
			((SlotInfo__*)local3->dataPtr__)[local4] = local5;
		} else {
			if (((tag__).kind__) == (TagKind__struct___)) {
				List__Node____* local9 = (s__)->entities__;
				uint__ local10 = (uint__)((tag__).q__);
				mu_____boundscheck(local10 < (uint__)local9->count__);
				Node__ local8 = ((Node__*)local9->dataPtr__)[local10];
				mu_____checkedcast(local8.id__ == Node_____Ptr__StructDef____);
				StructDef__* def__ = (StructDef__*)(local8.dataPtr__);
				{
					List__Ptr__FieldDef______* local11 = (def__)->fields__;
					int__ fi__ = 0;
					while (fi__ < local11->count__) {
						FieldDef__* f__ = ((FieldDef__**)(local11->dataPtr__))[fi__];
						Value__ local12;
						memset(&local12, 0, sizeof(Value__));
						local12.kind__ = ValueKind__ulong___;
						List__add__Value____((s__)->ws__, local12);
						Node__ local13 = (st__)->nameExpr__;
						mu_____checkedcast(local13.id__ == Node_____Ptr__Token____);
						string__ fname__ = EmulatorAllocator__formatName__(EmulatorAllocator__formatName__(((s__)->inst__)->fullName__, ((Token__*)(local13.dataPtr__))->value__), ((f__)->name__)->value__);
						Node__ local14;
						local14.dataPtr__ = (pointer__)(f__);
						local14.id__ = local14.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
						Tag__ ftag__ = Map__get__Node__Tag____((s__)->typeMap__, local14);
						List__SlotInfo____* local15 = (s__)->infos__;
						uint__ local16 = (uint__)(index__);
						mu_____boundscheck(local16 < (uint__)local15->count__);
						SlotInfo__ local17;
						memset(&local17, 0, sizeof(SlotInfo__));
						local17.name__ = fname__;
						local17.tag__ = ftag__;
						local17.inst__ = (s__)->inst__;
						Node__ local18;
						local18.dataPtr__ = (pointer__)(st__);
						local18.id__ = local18.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
						local17.node__ = local18;
						local17.field__ = fi__;
						local17.isReg__ = true__;
						((SlotInfo__*)local15->dataPtr__)[local16] = local17;
						index__ = ((index__)) + ((1));
						fi__ += 1;
					}
				}
			} else {
				mu_____abandon(-1);
			}
		}
	} else {
		if (((((st__)->flags__)) & ((AssignFlags__wire__))) != (0)) {
			Node__ local19;
			local19.dataPtr__ = (pointer__)(st__);
			local19.id__ = local19.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
			Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local19);
			bool__ isStatic__ = ((((st__)->flags__)) & ((AssignFlags__static__))) != (0);
			if (((tag__).kind__) == (TagKind__number__)) {
				Array__int____* local20 = ((s__)->inst__)->localState__;
				uint__ local21 = (uint__)((st__)->localId__);
				mu_____boundscheck(local21 < (uint__)local20->count__);
				((int__*)local20->dataPtr__)[local21] = ((s__)->rs__)->count__;
				List__add__Value____((s__)->rs__, EmulatorAllocator__createValue__(s__, tag__, true__));
				SlotInfo__ local22;
				memset(&local22, 0, sizeof(SlotInfo__));
				Node__ local23 = (st__)->nameExpr__;
				mu_____checkedcast(local23.id__ == Node_____Ptr__Token____);
				local22.name__ = EmulatorAllocator__formatName__(((s__)->inst__)->fullName__, ((Token__*)(local23.dataPtr__))->value__);
				local22.tag__ = tag__;
				local22.inst__ = (s__)->inst__;
				Node__ local24;
				local24.dataPtr__ = (pointer__)(st__);
				local24.id__ = local24.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
				local22.node__ = local24;
				local22.field__ = -1;
				local22.isStatic__ = isStatic__;
				List__add__SlotInfo____((s__)->infos__, local22);
			} else {
				if (((tag__).kind__) == (TagKind__struct___)) {
					Array__int____* local25 = ((s__)->inst__)->localState__;
					uint__ local26 = (uint__)((st__)->localId__);
					mu_____boundscheck(local26 < (uint__)local25->count__);
					((int__*)local25->dataPtr__)[local26] = ((s__)->rs__)->count__;
					List__Node____* local28 = (s__)->entities__;
					uint__ local29 = (uint__)((tag__).q__);
					mu_____boundscheck(local29 < (uint__)local28->count__);
					Node__ local27 = ((Node__*)local28->dataPtr__)[local29];
					mu_____checkedcast(local27.id__ == Node_____Ptr__StructDef____);
					StructDef__* def__ = (StructDef__*)(local27.dataPtr__);
					{
						List__Ptr__FieldDef______* local30 = (def__)->fields__;
						int__ fi__ = 0;
						while (fi__ < local30->count__) {
							FieldDef__* f__ = ((FieldDef__**)(local30->dataPtr__))[fi__];
							Value__ local31;
							memset(&local31, 0, sizeof(Value__));
							local31.kind__ = ValueKind__ulong___;
							List__add__Value____((s__)->rs__, local31);
							Node__ local32 = (st__)->nameExpr__;
							mu_____checkedcast(local32.id__ == Node_____Ptr__Token____);
							string__ fname__ = EmulatorAllocator__formatName__(EmulatorAllocator__formatName__(((s__)->inst__)->fullName__, ((Token__*)(local32.dataPtr__))->value__), ((f__)->name__)->value__);
							Node__ local33;
							local33.dataPtr__ = (pointer__)(f__);
							local33.id__ = local33.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
							Tag__ ftag__ = Map__get__Node__Tag____((s__)->typeMap__, local33);
							SlotInfo__ local34;
							memset(&local34, 0, sizeof(SlotInfo__));
							local34.name__ = fname__;
							local34.tag__ = ftag__;
							local34.inst__ = (s__)->inst__;
							Node__ local35;
							local35.dataPtr__ = (pointer__)(st__);
							local35.id__ = local35.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
							local34.node__ = local35;
							local34.field__ = fi__;
							local34.isStatic__ = isStatic__;
							List__add__SlotInfo____((s__)->infos__, local34);
							fi__ += 1;
						}
					}
				} else {
					if (((tag__).kind__) == (TagKind__moduleOut__)) {
					} else {
						mu_____abandon(-1);
					}
				}
			}
		}
	}
	bool__ local36 = ((st__)->nameExpr__).id__ == Node_____Ptr__Token____;
	if (local36) {
		local36 = ((st__)->expr__).id__ == Node_____Ptr__CallExpression____;
	}
	if (local36) {
		Node__ local37 = (st__)->expr__;
		mu_____checkedcast(local37.id__ == Node_____Ptr__CallExpression____);
		Node__ local38 = (st__)->nameExpr__;
		mu_____checkedcast(local38.id__ == Node_____Ptr__Token____);
		EmulatorAllocator__call__(s__, (CallExpression__*)(local37.dataPtr__), ((Token__*)(local38.dataPtr__))->value__);
	} else {
		if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
			EmulatorAllocator__expression__(s__, (st__)->expr__);
		}
	}
}
void__ EmulatorAllocator__expression__(EmulatorState__* s__, Node__ e__) {
	switch ((e__).id__) {
		case Node_____Ptr__Token____: {
			Token__* local0 = (Token__*)(e__.dataPtr__);
			{
			}
			break;
		}
		case Node_____Ptr__NumberExpression____: {
			NumberExpression__* local1 = (NumberExpression__*)(e__.dataPtr__);
			{
			}
			break;
		}
		case Node_____Ptr__UnaryOperatorExpression____: {
			UnaryOperatorExpression__* local2 = (UnaryOperatorExpression__*)(e__.dataPtr__);
			{
				EmulatorAllocator__expression__(s__, (local2)->expr__);
			}
			break;
		}
		case Node_____Ptr__BinaryOperatorExpression____: {
			BinaryOperatorExpression__* local3 = (BinaryOperatorExpression__*)(e__.dataPtr__);
			{
				EmulatorAllocator__expression__(s__, (local3)->lhs__);
				EmulatorAllocator__expression__(s__, (local3)->rhs__);
			}
			break;
		}
		case Node_____Ptr__DotExpression____: {
			DotExpression__* local4 = (DotExpression__*)(e__.dataPtr__);
			{
				EmulatorAllocator__expression__(s__, (local4)->lhs__);
				Node__ local5;
				local5.dataPtr__ = (pointer__)((local4)->rhs__);
				local5.id__ = local5.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
				EmulatorAllocator__expression__(s__, local5);
			}
			break;
		}
		case Node_____Ptr__TernaryOperatorExpression____: {
			TernaryOperatorExpression__* local6 = (TernaryOperatorExpression__*)(e__.dataPtr__);
			{
				EmulatorAllocator__expression__(s__, (local6)->conditionExpr__);
				EmulatorAllocator__expression__(s__, (local6)->trueExpr__);
				EmulatorAllocator__expression__(s__, (local6)->falseExpr__);
			}
			break;
		}
		case Node_____Ptr__MatchExpression____: {
			MatchExpression__* local7 = (MatchExpression__*)(e__.dataPtr__);
			{
				EmulatorAllocator__expression__(s__, (local7)->target__);
				{
					List__Ptr__MatchExpressionCase______* local8 = (local7)->cases__;
					int__ local9 = 0;
					while (local9 < local8->count__) {
						MatchExpressionCase__* c__ = ((MatchExpressionCase__**)(local8->dataPtr__))[local9];
						EmulatorAllocator__expression__(s__, (c__)->valueExpr__);
						EmulatorAllocator__expression__(s__, (c__)->resultExpr__);
						local9 += 1;
					}
				}
			}
			break;
		}
		case Node_____Ptr__ParenExpression____: {
			ParenExpression__* local10 = (ParenExpression__*)(e__.dataPtr__);
			{
				EmulatorAllocator__expression__(s__, (local10)->expr__);
			}
			break;
		}
		case Node_____Ptr__IndexExpression____: {
			IndexExpression__* local11 = (IndexExpression__*)(e__.dataPtr__);
			{
				EmulatorAllocator__expression__(s__, (local11)->target__);
				EmulatorAllocator__expression__(s__, (local11)->upperExpr__);
				EmulatorAllocator__expression__(s__, (local11)->lowerExpr__);
			}
			break;
		}
		case Node_____Ptr__BraceExpression____: {
			BraceExpression__* local12 = (BraceExpression__*)(e__.dataPtr__);
			{
				{
					List__Node____* local13 = (local12)->args__;
					int__ local14 = 0;
					while (local14 < local13->count__) {
						Node__ arg__ = ((Node__*)(local13->dataPtr__))[local14];
						EmulatorAllocator__expression__(s__, arg__);
						local14 += 1;
					}
				}
			}
			break;
		}
		case Node_____Ptr__CallExpression____: {
			CallExpression__* local15 = (CallExpression__*)(e__.dataPtr__);
			{
				EmulatorAllocator__call__(s__, local15, mu_____string0);
			}
			break;
		}
		case Node_____Ptr__StructInitializerExpression____: {
			StructInitializerExpression__* local16 = (StructInitializerExpression__*)(e__.dataPtr__);
			{
				{
					List__Ptr__CallArg______* local17 = (local16)->args__;
					int__ local18 = 0;
					while (local18 < local17->count__) {
						CallArg__* arg__ = ((CallArg__**)(local17->dataPtr__))[local18];
						EmulatorAllocator__expression__(s__, (arg__)->expr__);
						local18 += 1;
					}
				}
			}
			break;
		}
		case Node_____Ptr__ArrayExpression____: {
			ArrayExpression__* local19 = (ArrayExpression__*)(e__.dataPtr__);
			{
			}
			break;
		}
		case 0: {
			{
			}
			break;
		}
		default: {
			mu_____nomatch();
		}
	}
}
bool__ string__endsWith__(string__ s__, string__ suffix__) {
	if ((((s__).length__)) < (((suffix__).length__))) {
		return false__;
	}
	int__ from__ = (((s__).length__)) - (((suffix__).length__));
	{
		int__ i__ = 0;
		while (((i__)) < (((suffix__).length__))) {
			string__* local0 = &(s__);
			uint__ local1 = (uint__)(((from__)) + ((i__)));
			mu_____boundscheck(local1 < (uint__)local0->length__);
			string__* local2 = &(suffix__);
			uint__ local3 = (uint__)(i__);
			mu_____boundscheck(local3 < (uint__)local2->length__);
			if ((((char__*)local0->dataPtr__)[local1]) != (((char__*)local2->dataPtr__)[local3])) {
				return false__;
			}
			i__ += 1;
		}
	}
	return true__;
}
int__ string__compare_ignoreCase__(string__ a__, string__ b__) {
	int__ local0 = (a__).length__;
	int__ local1 = (b__).length__;
	int__ len__ = (local0 < local1) ? local0 : local1;
	pointer__ ap__ = (a__).dataPtr__;
	pointer__ bp__ = (b__).dataPtr__;
	{
		int__ i__ = 0;
		while (((i__)) < ((len__))) {
			char__ ach__ = string__toLower___(*((char__*)(ap__)));
			char__ bch__ = string__toLower___(*((char__*)(bp__)));
			if ((ach__) == (bch__)) {
			} else {
				if (((unsigned char)(ach__)) < ((unsigned char)(bch__))) {
					return -1;
				} else {
					return 1;
				}
			}
			ap__ = (ap__) + (1);
			bp__ = (bp__) + (1);
			i__ += 1;
		}
	}
	if ((((a__).length__)) < (((b__).length__))) {
		return -1;
	} else {
		if ((((a__).length__)) > (((b__).length__))) {
			return 1;
		}
	}
	return 0;
}
string__ string__replace__(string__ s__, string__ sub__, string__ replacement__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(StringBuilder__));
	StringBuilder__ rb__ = local0;
	int__ last__ = 0;
	int__ i__ = 0;
	int__ to__ = (((s__).length__)) - (((sub__).length__));
	while (true__) {
		if (!(((i__)) <= ((to__)))) { break; }
		int__ j__ = i__;
		int__ k__ = 0;
		while (true__) {
			if (!(((k__)) < (((sub__).length__)))) { break; }
			string__* local1 = &(s__);
			uint__ local2 = (uint__)(j__);
			mu_____boundscheck(local2 < (uint__)local1->length__);
			string__* local3 = &(sub__);
			uint__ local4 = (uint__)(k__);
			mu_____boundscheck(local4 < (uint__)local3->length__);
			if ((((char__*)local1->dataPtr__)[local2]) == (((char__*)local3->dataPtr__)[local4])) {
				j__ = ((j__)) + ((1));
				k__ = ((k__)) + ((1));
			} else {
				goto label2;
			}
		}
	label2:
		{}
		if (((k__)) == (((sub__).length__))) {
			StringBuilder__write__(&(rb__), string__slice__(s__, last__, i__));
			StringBuilder__write__(&(rb__), replacement__);
			i__ = ((i__)) + (((sub__).length__));
			last__ = i__;
		} else {
			i__ = ((i__)) + ((1));
		}
	}
	StringBuilder__write__(&(rb__), string__slice__(s__, last__, (s__).length__));
	return StringBuilder__compactToString__(&(rb__));
}
char__ string__toLower___(char__ ch__) {
	bool__ local0 = ((unsigned char)('A')) <= ((unsigned char)(ch__));
	if (local0) {
		local0 = ((unsigned char)(ch__)) <= ((unsigned char)('Z'));
	}
	if (local0) {
		return (char__)((ch__) + (32));
	}
	return ch__;
}
uint__ string__hash__(string__ s__) {
	uint__ hash__ = string__fnvOffsetBasis__;
	{
		int__ i__ = 0;
		while (((i__)) < (((s__).length__))) {
			string__* local0 = &(s__);
			byte__ val__ = (byte__)(unsigned char)(((char__*)local0->dataPtr__)[i__]);
			hash__ = ((hash__)) ^ ((uint__)(val__));
			hash__ = ((hash__)) * ((string__fnvPrime__));
			i__ += 1;
		}
	}
	return hash__;
}
string__ string__from_cstring__(cstring__ cstr__) {
	string__ local0;
	memset(&local0, 0, sizeof(string__));
	local0.dataPtr__ = (pointer__)(cstr__);
	local0.length__ = cstring__length__(cstr__);
	return local0;
}
string__ string__slice__(string__ s__, int__ from__, int__ to__) {
	bool__ local1 = ((0)) <= ((from__));
	if (local1) {
		local1 = ((from__)) <= ((to__));
	}
	bool__ local0 = local1;
	if (local0) {
		local0 = ((to__)) <= (((s__).length__));
	}
	mu_____assert(local0);
	string__ local2;
	memset(&local2, 0, sizeof(string__));
	local2.dataPtr__ = ((s__).dataPtr__) + (from__);
	local2.length__ = ((to__)) - ((from__));
	return local2;
}
bool__ string__equals__(string__ a__, string__ b__) {
	if ((((a__).length__)) != (((b__).length__))) {
		return false__;
	}
	pointer__ ap__ = (a__).dataPtr__;
	pointer__ bp__ = (b__).dataPtr__;
	{
		int__ i__ = 0;
		while (((i__)) < (((a__).length__))) {
			char__ ach__ = *((char__*)(ap__));
			char__ bch__ = *((char__*)(bp__));
			if ((ach__) != (bch__)) {
				return false__;
			}
			ap__ = (ap__) + (1);
			bp__ = (bp__) + (1);
			i__ += 1;
		}
	}
	return true__;
}
string__ string__alloc__(pointer__ dataPtr__, int__ length__) {
	if ((dataPtr__) == (null__)) {
		mu_____assert(((length__)) == ((0)));
		string__ local0;
		memset(&local0, 0, sizeof(string__));
		return local0;
	}
	string__ local1;
	memset(&local1, 0, sizeof(string__));
	local1.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, (ssize__)(length__));
	local1.length__ = length__;
	string__ result__ = local1;
	int__ local2 = length__;
	mu_____checkedcast(0 <= local2);
	memcpy((result__).dataPtr__, dataPtr__, (usize__)(local2));
	return result__;
}
int__ string__indexOfChar__(string__ s__, char__ ch__) {
	{
		int__ i__ = 0;
		while (((i__)) < (((s__).length__))) {
			string__* local0 = &(s__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->length__);
			if ((((char__*)local0->dataPtr__)[local1]) == (ch__)) {
				return i__;
			}
			i__ += 1;
		}
	}
	return -1;
}
bool__ string__startsWith_ignoreCase__(string__ s__, string__ prefix__) {
	if ((((s__).length__)) < (((prefix__).length__))) {
		return false__;
	}
	{
		int__ i__ = 0;
		while (((i__)) < (((prefix__).length__))) {
			string__* local0 = &(s__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->length__);
			string__* local2 = &(prefix__);
			uint__ local3 = (uint__)(i__);
			mu_____boundscheck(local3 < (uint__)local2->length__);
			if ((string__toLower___(((char__*)local0->dataPtr__)[local1])) != (string__toLower___(((char__*)local2->dataPtr__)[local3]))) {
				return false__;
			}
			i__ += 1;
		}
	}
	return true__;
}
bool__ string__startsWith__(string__ s__, string__ prefix__) {
	if ((((s__).length__)) < (((prefix__).length__))) {
		return false__;
	}
	{
		int__ i__ = 0;
		while (((i__)) < (((prefix__).length__))) {
			string__* local0 = &(s__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->length__);
			string__* local2 = &(prefix__);
			uint__ local3 = (uint__)(i__);
			mu_____boundscheck(local3 < (uint__)local2->length__);
			if ((((char__*)local0->dataPtr__)[local1]) != (((char__*)local2->dataPtr__)[local3])) {
				return false__;
			}
			i__ += 1;
		}
	}
	return true__;
}
cstring__ string__alloc_cstring__(string__ s__) {
	mu_____assert((((s__).length__)) >= ((0)));
	pointer__ ptr__ = IAllocator__alloc__(top_____currentAllocator__, (ssize__)((((s__).length__)) + ((1))));
	memcpy(ptr__, (s__).dataPtr__, (usize__)((s__).length__));
	*((byte__*)((ptr__) + ((s__).length__))) = (byte__)(0);
	return (cstring__)(ptr__);
}
Array__string____ string__split__(string__ s__, char__ sep__) {
	int__ num__ = 1;
	{
		int__ i__ = 0;
		while (((i__)) < (((s__).length__))) {
			string__* local0 = &(s__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->length__);
			if ((((char__*)local0->dataPtr__)[local1]) == (sep__)) {
				num__ = ((num__)) + ((1));
			}
			i__ += 1;
		}
	}
	Array__string____ result__ = Array__cons__string____(num__);
	int__ from__ = 0;
	int__ j__ = 0;
	{
		int__ i__ = 0;
		while (((i__)) < (((s__).length__))) {
			string__* local2 = &(s__);
			uint__ local3 = (uint__)(i__);
			mu_____boundscheck(local3 < (uint__)local2->length__);
			if ((((char__*)local2->dataPtr__)[local3]) == (sep__)) {
				Array__string____* local4 = &(result__);
				uint__ local5 = (uint__)(j__);
				mu_____boundscheck(local5 < (uint__)local4->count__);
				((string__*)local4->dataPtr__)[local5] = string__slice__(s__, from__, i__);
				from__ = ((i__)) + ((1));
				j__ = ((j__)) + ((1));
			}
			i__ += 1;
		}
	}
	Array__string____* local6 = &(result__);
	uint__ local7 = (uint__)(j__);
	mu_____boundscheck(local7 < (uint__)local6->count__);
	((string__*)local6->dataPtr__)[local7] = string__slice__(s__, from__, (s__).length__);
	return result__;
}
string__ string__repeatChar__(char__ ch__, int__ count__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(StringBuilder__));
	StringBuilder__ rb__ = local0;
	{
		int__ i__ = 0;
		while (((i__)) < ((count__))) {
			StringBuilder__writeChar__(&(rb__), ch__);
			i__ += 1;
		}
	}
	return StringBuilder__compactToString__(&(rb__));
}
int__ string__compare__(string__ a__, string__ b__) {
	int__ local0 = (a__).length__;
	int__ local1 = (b__).length__;
	int__ len__ = (local0 < local1) ? local0 : local1;
	pointer__ ap__ = (a__).dataPtr__;
	pointer__ bp__ = (b__).dataPtr__;
	{
		int__ i__ = 0;
		while (((i__)) < ((len__))) {
			char__ ach__ = *((char__*)(ap__));
			char__ bch__ = *((char__*)(bp__));
			if ((ach__) == (bch__)) {
			} else {
				if (((unsigned char)(ach__)) < ((unsigned char)(bch__))) {
					return -1;
				} else {
					return 1;
				}
			}
			ap__ = (ap__) + (1);
			bp__ = (bp__) + (1);
			i__ += 1;
		}
	}
	if ((((a__).length__)) < (((b__).length__))) {
		return -1;
	} else {
		if ((((a__).length__)) > (((b__).length__))) {
			return 1;
		}
	}
	return 0;
}
string__ string__from__(pointer__ dataPtr__, int__ length__) {
	string__ local0;
	memset(&local0, 0, sizeof(string__));
	local0.dataPtr__ = dataPtr__;
	local0.length__ = length__;
	return local0;
}
string__ string__join__(string__ sep__, Array__string____* items__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(StringBuilder__));
	StringBuilder__ rb__ = local0;
	bool__ insertSep__ = false__;
	{
		Array__string____* local1 = items__;
		int__ local2 = 0;
		while (local2 < local1->count__) {
			string__ it__ = ((string__*)(local1->dataPtr__))[local2];
			if (insertSep__) {
				StringBuilder__write__(&(rb__), sep__);
			} else {
				insertSep__ = true__;
			}
			StringBuilder__write__(&(rb__), it__);
			local2 += 1;
		}
	}
	return StringBuilder__compactToString__(&(rb__));
}
int__ string__indexOf__(string__ s__, string__ sub__) {
	int__ to__ = (((s__).length__)) - (((sub__).length__));
	{
		int__ i__ = 0;
		while (((i__)) <= ((to__))) {
			int__ j__ = i__;
			int__ k__ = 0;
			while (true__) {
				if (!(((k__)) < (((sub__).length__)))) { break; }
				string__* local0 = &(s__);
				uint__ local1 = (uint__)(j__);
				mu_____boundscheck(local1 < (uint__)local0->length__);
				string__* local2 = &(sub__);
				uint__ local3 = (uint__)(k__);
				mu_____boundscheck(local3 < (uint__)local2->length__);
				if ((((char__*)local0->dataPtr__)[local1]) == (((char__*)local2->dataPtr__)[local3])) {
					j__ = ((j__)) + ((1));
					k__ = ((k__)) + ((1));
				} else {
					goto label2;
				}
			}
		label2:
			{}
			if (((k__)) == (((sub__).length__))) {
				return i__;
			}
			i__ += 1;
		}
	}
	return -1;
}
uint__ bool__hash__(bool__ val__) {
	union { bool__ from; uint__ to; } local0;
	memset(&local0, 0, sizeof(local0));
	local0.from = val__;
	return local0.to;
}
void__ bool__writeTo__(bool__ val__, StringBuilder__* sb__) {
	if (val__) {
		StringBuilder__write__(sb__, mu_____string4);
	} else {
		StringBuilder__write__(sb__, mu_____string5);
	}
}
Result__string____ Stdin__tryReadLine__() {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(StringBuilder__));
	StringBuilder__ rb__ = local0;
	int__ blockSize__ = 4096;
	while (true__) {
		if (!(true__)) { break; }
		StringBuilder__reserveForWrite__(&(rb__), blockSize__);
		pointer__ from__ = ((rb__).dataPtr__) + ((rb__).count__);
		pointer__ ptr__ = (pointer__)fgets((char *)from__, blockSize__, (FILE *)CStdlib__stdin__);
		if ((ptr__) == (null__)) {
			StringBuilder__compactToString__(&(rb__));
			if ((((int__)feof((FILE *)CStdlib__stdin__))) != ((0))) {
				return Result__fromError__string____(Stdin__tryReadLine_eof__);
			} else {
				return Result__fromError__string____(Stdin__tryReadLine_ioError__);
			}
		}
		pointer__ p__ = from__;
		while (true__) {
			if (!(((int__)(*((byte__*)(p__)))) != ((0)))) { break; }
			p__ = (p__) + (1);
		}
		ssize__ local1 = pointer__subtractSigned__(p__, from__);
		mu_____checkedcast(local1 + ((ssize__)0x7fffffff) + 1 <= (ssize__)(0xffffffffu));
		int__ len__ = (int__)(local1);
		bool__ local2 = ((0)) < ((len__));
		if (local2) {
			local2 = ((len__)) < ((blockSize__));
		}
		mu_____assert(local2);
		char__ lastChar__ = *((char__*)(((from__) + (len__)) - (1)));
		if ((lastChar__) == ('\n')) {
			len__ = ((len__)) - ((1));
			(rb__).count__ = (((rb__).count__)) + ((len__));
			return Result__fromValue__string____(StringBuilder__compactToString__(&(rb__)));
		} else {
			(rb__).count__ = (((rb__).count__)) + ((len__));
			if (((len__)) < ((((blockSize__)) - ((1))))) {
				return Result__fromValue__string____(StringBuilder__compactToString__(&(rb__)));
			}
		}
	}
}
Result__string____ Result__fromValue__string____(string__ value__) {
	Result__string____ local0;
	memset(&local0, 0, sizeof(Result__string____));
	local0.value__ = value__;
	return local0;
}
Result__string____ Result__fromError__string____(int__ error__) {
	Result__string____ local0;
	memset(&local0, 0, sizeof(Result__string____));
	local0.error__ = error__;
	return local0;
}
string__ Opcode__toString__(Opcode__ op__) {
	if ((op__) == (Opcode__push__)) {
		return mu_____string202;
	} else {
		if ((op__) == (Opcode__pushArray__)) {
			return mu_____string203;
		} else {
			if ((op__) == (Opcode__load__)) {
				return mu_____string204;
			} else {
				if ((op__) == (Opcode__store__)) {
					return mu_____string205;
				} else {
					if ((op__) == (Opcode__mask__)) {
						return mu_____string206;
					} else {
						if ((op__) == (Opcode__index__)) {
							return mu_____string207;
						} else {
							if ((op__) == (Opcode__shlOr__)) {
								return mu_____string208;
							} else {
								if ((op__) == (Opcode__jumpIfZero__)) {
									return mu_____string209;
								} else {
									if ((op__) == (Opcode__jump__)) {
										return mu_____string210;
									} else {
										if ((op__) == (Opcode__nop__)) {
											return mu_____string211;
										} else {
											if ((op__) == (Opcode__dup__)) {
												return mu_____string212;
											} else {
												if ((op__) == (Opcode__discard__)) {
													return mu_____string213;
												} else {
													if ((op__) == (Opcode__neg__)) {
														return mu_____string214;
													} else {
														if ((op__) == (Opcode__invert__)) {
															return mu_____string215;
														} else {
															if ((op__) == (Opcode__add__)) {
																return mu_____string216;
															} else {
																if ((op__) == (Opcode__sub__)) {
																	return mu_____string217;
																} else {
																	if ((op__) == (Opcode__and__)) {
																		return mu_____string218;
																	} else {
																		if ((op__) == (Opcode__or__)) {
																			return mu_____string219;
																		} else {
																			if ((op__) == (Opcode__xor__)) {
																				return mu_____string220;
																			} else {
																				if ((op__) == (Opcode__mul__)) {
																					return mu_____string221;
																				} else {
																					if ((op__) == (Opcode__eq__)) {
																						return mu_____string222;
																					} else {
																						if ((op__) == (Opcode__neq__)) {
																							return mu_____string223;
																						} else {
																							if ((op__) == (Opcode__lt__)) {
																								return mu_____string224;
																							} else {
																								if ((op__) == (Opcode__lte__)) {
																									return mu_____string225;
																								} else {
																									if ((op__) == (Opcode__gt__)) {
																										return mu_____string226;
																									} else {
																										if ((op__) == (Opcode__gte__)) {
																											return mu_____string227;
																										} else {
																											if ((op__) == (Opcode__shl__)) {
																												return mu_____string228;
																											} else {
																												if ((op__) == (Opcode__shr__)) {
																													return mu_____string229;
																												} else {
																													if ((op__) == (Opcode__slice__)) {
																														return mu_____string27;
																													} else {
																														if ((op__) == (Opcode__storeSlice__)) {
																															return mu_____string230;
																														} else {
																															if ((op__) == (Opcode__swizzle__)) {
																																return mu_____string29;
																															} else {
																																return mu_____string49;
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
Maybe__uint____ Maybe__from__uint____(uint__ value__) {
	Maybe__uint____ local0;
	memset(&local0, 0, sizeof(Maybe__uint____));
	local0.value__ = value__;
	local0.hasValue__ = true__;
	return local0;
}
Maybe__string____ Maybe__from__string____(string__ value__) {
	Maybe__string____ local0;
	memset(&local0, 0, sizeof(Maybe__string____));
	local0.value__ = value__;
	local0.hasValue__ = true__;
	return local0;
}
Maybe__long____ Maybe__from__long____(long__ value__) {
	Maybe__long____ local0;
	memset(&local0, 0, sizeof(Maybe__long____));
	local0.value__ = value__;
	local0.hasValue__ = true__;
	return local0;
}
Maybe__int____ Maybe__from__int____(int__ value__) {
	Maybe__int____ local0;
	memset(&local0, 0, sizeof(Maybe__int____));
	local0.value__ = value__;
	local0.hasValue__ = true__;
	return local0;
}
Maybe__ulong____ Maybe__from__ulong____(ulong__ value__) {
	Maybe__ulong____ local0;
	memset(&local0, 0, sizeof(Maybe__ulong____));
	local0.value__ = value__;
	local0.hasValue__ = true__;
	return local0;
}
Maybe__string____ Map__maybeGet__NodeWithCtx__string____(Map__NodeWithCtx__string____* this__, NodeWithCtx__ key__) {
	uint__ h__ = NodeWithCtx__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__NodeWithCtx__string______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__NodeWithCtx__string____* e__ = &(((MapEntry__NodeWithCtx__string____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			Maybe__string____ local2;
			memset(&local2, 0, sizeof(Maybe__string____));
			return local2;
		}
		bool__ local3 = (((e__)->hash__)) == ((h__));
		if (local3) {
			local3 = NodeWithCtx__equals__((e__)->key__, key__);
		}
		if (local3) {
			return Maybe__from__string____((e__)->value__);
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
bool__ Map__containsKey__string__Node____(Map__string__Node____* this__, string__ key__) {
	uint__ h__ = string__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__string__Node______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__string__Node____* e__ = &(((MapEntry__string__Node____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			return false__;
		}
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = string__equals__((e__)->key__, key__);
		}
		if (local2) {
			return true__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
void__ Map__addOrUpdate__Node__int____(Map__Node__int____* this__, Node__ key__, int__ value__) {
	if ((((this__)->count__)) > (((this__)->growThreshold__))) {
		Map__grow__Node__int____(this__);
	}
	uint__ h__ = Node__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__Node__int______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__Node__int____* e__ = &(((MapEntry__Node__int____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			goto label0;
		}
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = (((e__)->key__).dataPtr__) == ((key__).dataPtr__);
		}
		if (local2) {
			(e__)->value__ = value__;
			return;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
label0:
	{}
	Array__MapEntry__Node__int______* local3 = &((this__)->entries__);
	uint__ local4 = (uint__)(b__);
	mu_____boundscheck(local4 < (uint__)local3->count__);
	MapEntry__Node__int____ local5;
	memset(&local5, 0, sizeof(MapEntry__Node__int____));
	local5.hash__ = h__;
	local5.key__ = key__;
	local5.value__ = value__;
	((MapEntry__Node__int____*)local3->dataPtr__)[local4] = local5;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
bool__ Map__tryAdd__NodeWithCtx__string____(Map__NodeWithCtx__string____* this__, NodeWithCtx__ key__, string__ value__) {
	if ((((this__)->count__)) > (((this__)->growThreshold__))) {
		Map__grow__NodeWithCtx__string____(this__);
	}
	uint__ h__ = NodeWithCtx__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__NodeWithCtx__string______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__NodeWithCtx__string____* e__ = &(((MapEntry__NodeWithCtx__string____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			goto label0;
		}
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = NodeWithCtx__equals__((e__)->key__, key__);
		}
		if (local2) {
			return false__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
label0:
	{}
	Array__MapEntry__NodeWithCtx__string______* local3 = &((this__)->entries__);
	uint__ local4 = (uint__)(b__);
	mu_____boundscheck(local4 < (uint__)local3->count__);
	MapEntry__NodeWithCtx__string____ local5;
	memset(&local5, 0, sizeof(MapEntry__NodeWithCtx__string____));
	local5.hash__ = h__;
	local5.key__ = key__;
	local5.value__ = value__;
	((MapEntry__NodeWithCtx__string____*)local3->dataPtr__)[local4] = local5;
	(this__)->count__ = (((this__)->count__)) + ((1));
	return true__;
}
bool__ Map__tryAdd__Node__Value____(Map__Node__Value____* this__, Node__ key__, Value__ value__) {
	if ((((this__)->count__)) > (((this__)->growThreshold__))) {
		Map__grow__Node__Value____(this__);
	}
	uint__ h__ = Node__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__Node__Value______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__Node__Value____* e__ = &(((MapEntry__Node__Value____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			goto label0;
		}
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = (((e__)->key__).dataPtr__) == ((key__).dataPtr__);
		}
		if (local2) {
			return false__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
label0:
	{}
	Array__MapEntry__Node__Value______* local3 = &((this__)->entries__);
	uint__ local4 = (uint__)(b__);
	mu_____boundscheck(local4 < (uint__)local3->count__);
	MapEntry__Node__Value____ local5;
	memset(&local5, 0, sizeof(MapEntry__Node__Value____));
	local5.hash__ = h__;
	local5.key__ = key__;
	local5.value__ = value__;
	((MapEntry__Node__Value____*)local3->dataPtr__)[local4] = local5;
	(this__)->count__ = (((this__)->count__)) + ((1));
	return true__;
}
bool__ Map__tryAdd__Node__Tag____(Map__Node__Tag____* this__, Node__ key__, Tag__ value__) {
	if ((((this__)->count__)) > (((this__)->growThreshold__))) {
		Map__grow__Node__Tag____(this__);
	}
	uint__ h__ = Node__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__Node__Tag______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__Node__Tag____* e__ = &(((MapEntry__Node__Tag____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			goto label0;
		}
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = (((e__)->key__).dataPtr__) == ((key__).dataPtr__);
		}
		if (local2) {
			return false__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
label0:
	{}
	Array__MapEntry__Node__Tag______* local3 = &((this__)->entries__);
	uint__ local4 = (uint__)(b__);
	mu_____boundscheck(local4 < (uint__)local3->count__);
	MapEntry__Node__Tag____ local5;
	memset(&local5, 0, sizeof(MapEntry__Node__Tag____));
	local5.hash__ = h__;
	local5.key__ = key__;
	local5.value__ = value__;
	((MapEntry__Node__Tag____*)local3->dataPtr__)[local4] = local5;
	(this__)->count__ = (((this__)->count__)) + ((1));
	return true__;
}
bool__ Map__tryAdd__string__Node____(Map__string__Node____* this__, string__ key__, Node__ value__) {
	if ((((this__)->count__)) > (((this__)->growThreshold__))) {
		Map__grow__string__Node____(this__);
	}
	uint__ h__ = string__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__string__Node______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__string__Node____* e__ = &(((MapEntry__string__Node____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			goto label0;
		}
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = string__equals__((e__)->key__, key__);
		}
		if (local2) {
			return false__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
label0:
	{}
	Array__MapEntry__string__Node______* local3 = &((this__)->entries__);
	uint__ local4 = (uint__)(b__);
	mu_____boundscheck(local4 < (uint__)local3->count__);
	MapEntry__string__Node____ local5;
	memset(&local5, 0, sizeof(MapEntry__string__Node____));
	local5.hash__ = h__;
	local5.key__ = key__;
	local5.value__ = value__;
	((MapEntry__string__Node____*)local3->dataPtr__)[local4] = local5;
	(this__)->count__ = (((this__)->count__)) + ((1));
	return true__;
}
bool__ Map__tryAdd__string__Ptr__FieldDef______(Map__string__Ptr__FieldDef______* this__, string__ key__, FieldDef__* value__) {
	if ((((this__)->count__)) > (((this__)->growThreshold__))) {
		Map__grow__string__Ptr__FieldDef______(this__);
	}
	uint__ h__ = string__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__string__Ptr__FieldDef________* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__string__Ptr__FieldDef______* e__ = &(((MapEntry__string__Ptr__FieldDef______*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			goto label0;
		}
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = string__equals__((e__)->key__, key__);
		}
		if (local2) {
			return false__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
label0:
	{}
	Array__MapEntry__string__Ptr__FieldDef________* local3 = &((this__)->entries__);
	uint__ local4 = (uint__)(b__);
	mu_____boundscheck(local4 < (uint__)local3->count__);
	MapEntry__string__Ptr__FieldDef______ local5;
	memset(&local5, 0, sizeof(MapEntry__string__Ptr__FieldDef______));
	local5.hash__ = h__;
	local5.key__ = key__;
	local5.value__ = value__;
	((MapEntry__string__Ptr__FieldDef______*)local3->dataPtr__)[local4] = local5;
	(this__)->count__ = (((this__)->count__)) + ((1));
	return true__;
}
void__ Map__add__NodeWithCtx__string____(Map__NodeWithCtx__string____* this__, NodeWithCtx__ key__, string__ value__) {
	mu_____assert(Map__tryAdd__NodeWithCtx__string____(this__, key__, value__));
}
void__ Map__add__Node__Value____(Map__Node__Value____* this__, Node__ key__, Value__ value__) {
	mu_____assert(Map__tryAdd__Node__Value____(this__, key__, value__));
}
void__ Map__add__Node__Tag____(Map__Node__Tag____* this__, Node__ key__, Tag__ value__) {
	mu_____assert(Map__tryAdd__Node__Tag____(this__, key__, value__));
}
FieldDef__* Map__get__string__Ptr__FieldDef______(Map__string__Ptr__FieldDef______* this__, string__ key__) {
	uint__ h__ = string__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__string__Ptr__FieldDef________* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__string__Ptr__FieldDef______* e__ = &(((MapEntry__string__Ptr__FieldDef______*)local0->dataPtr__)[local1]);
		mu_____assert((((e__)->hash__)) != ((uint__)(0)));
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = string__equals__((e__)->key__, key__);
		}
		if (local2) {
			return (e__)->value__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
Value__ Map__get__Node__Value____(Map__Node__Value____* this__, Node__ key__) {
	uint__ h__ = Node__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__Node__Value______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__Node__Value____* e__ = &(((MapEntry__Node__Value____*)local0->dataPtr__)[local1]);
		mu_____assert((((e__)->hash__)) != ((uint__)(0)));
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = (((e__)->key__).dataPtr__) == ((key__).dataPtr__);
		}
		if (local2) {
			return (e__)->value__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
Node__ Map__get__string__Node____(Map__string__Node____* this__, string__ key__) {
	uint__ h__ = string__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__string__Node______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__string__Node____* e__ = &(((MapEntry__string__Node____*)local0->dataPtr__)[local1]);
		mu_____assert((((e__)->hash__)) != ((uint__)(0)));
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = string__equals__((e__)->key__, key__);
		}
		if (local2) {
			return (e__)->value__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
Tag__ Map__get__Node__Tag____(Map__Node__Tag____* this__, Node__ key__) {
	uint__ h__ = Node__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__Node__Tag______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__Node__Tag____* e__ = &(((MapEntry__Node__Tag____*)local0->dataPtr__)[local1]);
		mu_____assert((((e__)->hash__)) != ((uint__)(0)));
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = (((e__)->key__).dataPtr__) == ((key__).dataPtr__);
		}
		if (local2) {
			return (e__)->value__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
Tag__ Map__getOrDefault__Node__Tag____(Map__Node__Tag____* this__, Node__ key__) {
	uint__ h__ = Node__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__Node__Tag______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__Node__Tag____* e__ = &(((MapEntry__Node__Tag____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			Tag__ local2;
			memset(&local2, 0, sizeof(Tag__));
			return local2;
		}
		bool__ local3 = (((e__)->hash__)) == ((h__));
		if (local3) {
			local3 = (((e__)->key__).dataPtr__) == ((key__).dataPtr__);
		}
		if (local3) {
			return (e__)->value__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
Node__ Map__getOrDefault__string__Node____(Map__string__Node____* this__, string__ key__) {
	uint__ h__ = string__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__string__Node______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__string__Node____* e__ = &(((MapEntry__string__Node____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			Node__ local2;
			local2.dataPtr__ = null__;
			local2.id__ = 0;
			return local2;
		}
		bool__ local3 = (((e__)->hash__)) == ((h__));
		if (local3) {
			local3 = string__equals__((e__)->key__, key__);
		}
		if (local3) {
			return (e__)->value__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
int__ Map__getOrDefault__Node__int____(Map__Node__int____* this__, Node__ key__) {
	uint__ h__ = Node__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__Node__int______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__Node__int____* e__ = &(((MapEntry__Node__int____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			return 0;
		}
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = (((e__)->key__).dataPtr__) == ((key__).dataPtr__);
		}
		if (local2) {
			return (e__)->value__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
Value__ Map__getOrDefault__Node__Value____(Map__Node__Value____* this__, Node__ key__) {
	uint__ h__ = Node__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__Node__Value______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__Node__Value____* e__ = &(((MapEntry__Node__Value____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			Value__ local2;
			memset(&local2, 0, sizeof(Value__));
			return local2;
		}
		bool__ local3 = (((e__)->hash__)) == ((h__));
		if (local3) {
			local3 = (((e__)->key__).dataPtr__) == ((key__).dataPtr__);
		}
		if (local3) {
			return (e__)->value__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
FieldDef__* Map__getOrDefault__string__Ptr__FieldDef______(Map__string__Ptr__FieldDef______* this__, string__ key__) {
	uint__ h__ = string__hash__(key__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__string__Ptr__FieldDef________* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__string__Ptr__FieldDef______* e__ = &(((MapEntry__string__Ptr__FieldDef______*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			return null__;
		}
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = string__equals__((e__)->key__, key__);
		}
		if (local2) {
			return (e__)->value__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
MapEntry__string__Ptr__FieldDef______* Map__getEmptyEntry___string__Ptr__FieldDef______(Map__string__Ptr__FieldDef______* this__, uint__ h__) {
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__string__Ptr__FieldDef________* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__string__Ptr__FieldDef______* e__ = &(((MapEntry__string__Ptr__FieldDef______*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			return e__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
MapEntry__Node__Tag____* Map__getEmptyEntry___Node__Tag____(Map__Node__Tag____* this__, uint__ h__) {
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__Node__Tag______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__Node__Tag____* e__ = &(((MapEntry__Node__Tag____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			return e__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
MapEntry__Node__int____* Map__getEmptyEntry___Node__int____(Map__Node__int____* this__, uint__ h__) {
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__Node__int______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__Node__int____* e__ = &(((MapEntry__Node__int____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			return e__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
MapEntry__string__Node____* Map__getEmptyEntry___string__Node____(Map__string__Node____* this__, uint__ h__) {
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__string__Node______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__string__Node____* e__ = &(((MapEntry__string__Node____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			return e__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
MapEntry__Node__Value____* Map__getEmptyEntry___Node__Value____(Map__Node__Value____* this__, uint__ h__) {
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__Node__Value______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__Node__Value____* e__ = &(((MapEntry__Node__Value____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			return e__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
MapEntry__NodeWithCtx__string____* Map__getEmptyEntry___NodeWithCtx__string____(Map__NodeWithCtx__string____* this__, uint__ h__) {
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__MapEntry__NodeWithCtx__string______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		MapEntry__NodeWithCtx__string____* e__ = &(((MapEntry__NodeWithCtx__string____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			return e__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
void__ Map__grow__string__Ptr__FieldDef______(Map__string__Ptr__FieldDef______* this__) {
	int__ newCap__ = CheckedMath__mulPositiveInt__(((this__)->entries__).count__, 2);
	Array__MapEntry__string__Ptr__FieldDef________ prev__ = (this__)->entries__;
	(this__)->entries__ = Array__cons__MapEntry__string__Ptr__FieldDef________(newCap__);
	(this__)->capacityMask__ = (uint__)(((newCap__)) - ((1)));
	(this__)->growThreshold__ = ((((newCap__)) / ((3)))) * ((2));
	{
		int__ i__ = 0;
		while (((i__)) < (((prev__).count__))) {
			Array__MapEntry__string__Ptr__FieldDef________* local0 = &(prev__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->count__);
			MapEntry__string__Ptr__FieldDef______* e__ = &(((MapEntry__string__Ptr__FieldDef______*)local0->dataPtr__)[local1]);
			if ((((e__)->hash__)) != ((uint__)(0))) {
				*(Map__getEmptyEntry___string__Ptr__FieldDef______(this__, (e__)->hash__)) = *(e__);
			}
			i__ += 1;
		}
	}
}
void__ Map__grow__Node__Tag____(Map__Node__Tag____* this__) {
	int__ newCap__ = CheckedMath__mulPositiveInt__(((this__)->entries__).count__, 2);
	Array__MapEntry__Node__Tag______ prev__ = (this__)->entries__;
	(this__)->entries__ = Array__cons__MapEntry__Node__Tag______(newCap__);
	(this__)->capacityMask__ = (uint__)(((newCap__)) - ((1)));
	(this__)->growThreshold__ = ((((newCap__)) / ((3)))) * ((2));
	{
		int__ i__ = 0;
		while (((i__)) < (((prev__).count__))) {
			Array__MapEntry__Node__Tag______* local0 = &(prev__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->count__);
			MapEntry__Node__Tag____* e__ = &(((MapEntry__Node__Tag____*)local0->dataPtr__)[local1]);
			if ((((e__)->hash__)) != ((uint__)(0))) {
				*(Map__getEmptyEntry___Node__Tag____(this__, (e__)->hash__)) = *(e__);
			}
			i__ += 1;
		}
	}
}
void__ Map__grow__Node__int____(Map__Node__int____* this__) {
	int__ newCap__ = CheckedMath__mulPositiveInt__(((this__)->entries__).count__, 2);
	Array__MapEntry__Node__int______ prev__ = (this__)->entries__;
	(this__)->entries__ = Array__cons__MapEntry__Node__int______(newCap__);
	(this__)->capacityMask__ = (uint__)(((newCap__)) - ((1)));
	(this__)->growThreshold__ = ((((newCap__)) / ((3)))) * ((2));
	{
		int__ i__ = 0;
		while (((i__)) < (((prev__).count__))) {
			Array__MapEntry__Node__int______* local0 = &(prev__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->count__);
			MapEntry__Node__int____* e__ = &(((MapEntry__Node__int____*)local0->dataPtr__)[local1]);
			if ((((e__)->hash__)) != ((uint__)(0))) {
				*(Map__getEmptyEntry___Node__int____(this__, (e__)->hash__)) = *(e__);
			}
			i__ += 1;
		}
	}
}
void__ Map__grow__string__Node____(Map__string__Node____* this__) {
	int__ newCap__ = CheckedMath__mulPositiveInt__(((this__)->entries__).count__, 2);
	Array__MapEntry__string__Node______ prev__ = (this__)->entries__;
	(this__)->entries__ = Array__cons__MapEntry__string__Node______(newCap__);
	(this__)->capacityMask__ = (uint__)(((newCap__)) - ((1)));
	(this__)->growThreshold__ = ((((newCap__)) / ((3)))) * ((2));
	{
		int__ i__ = 0;
		while (((i__)) < (((prev__).count__))) {
			Array__MapEntry__string__Node______* local0 = &(prev__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->count__);
			MapEntry__string__Node____* e__ = &(((MapEntry__string__Node____*)local0->dataPtr__)[local1]);
			if ((((e__)->hash__)) != ((uint__)(0))) {
				*(Map__getEmptyEntry___string__Node____(this__, (e__)->hash__)) = *(e__);
			}
			i__ += 1;
		}
	}
}
void__ Map__grow__Node__Value____(Map__Node__Value____* this__) {
	int__ newCap__ = CheckedMath__mulPositiveInt__(((this__)->entries__).count__, 2);
	Array__MapEntry__Node__Value______ prev__ = (this__)->entries__;
	(this__)->entries__ = Array__cons__MapEntry__Node__Value______(newCap__);
	(this__)->capacityMask__ = (uint__)(((newCap__)) - ((1)));
	(this__)->growThreshold__ = ((((newCap__)) / ((3)))) * ((2));
	{
		int__ i__ = 0;
		while (((i__)) < (((prev__).count__))) {
			Array__MapEntry__Node__Value______* local0 = &(prev__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->count__);
			MapEntry__Node__Value____* e__ = &(((MapEntry__Node__Value____*)local0->dataPtr__)[local1]);
			if ((((e__)->hash__)) != ((uint__)(0))) {
				*(Map__getEmptyEntry___Node__Value____(this__, (e__)->hash__)) = *(e__);
			}
			i__ += 1;
		}
	}
}
void__ Map__grow__NodeWithCtx__string____(Map__NodeWithCtx__string____* this__) {
	int__ newCap__ = CheckedMath__mulPositiveInt__(((this__)->entries__).count__, 2);
	Array__MapEntry__NodeWithCtx__string______ prev__ = (this__)->entries__;
	(this__)->entries__ = Array__cons__MapEntry__NodeWithCtx__string______(newCap__);
	(this__)->capacityMask__ = (uint__)(((newCap__)) - ((1)));
	(this__)->growThreshold__ = ((((newCap__)) / ((3)))) * ((2));
	{
		int__ i__ = 0;
		while (((i__)) < (((prev__).count__))) {
			Array__MapEntry__NodeWithCtx__string______* local0 = &(prev__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->count__);
			MapEntry__NodeWithCtx__string____* e__ = &(((MapEntry__NodeWithCtx__string____*)local0->dataPtr__)[local1]);
			if ((((e__)->hash__)) != ((uint__)(0))) {
				*(Map__getEmptyEntry___NodeWithCtx__string____(this__, (e__)->hash__)) = *(e__);
			}
			i__ += 1;
		}
	}
}
Map__Node__Tag____ Map__create__Node__Tag____() {
	int__ cap__ = 8;
	Map__Node__Tag____ local0;
	memset(&local0, 0, sizeof(Map__Node__Tag____));
	local0.entries__ = Array__cons__MapEntry__Node__Tag______(cap__);
	local0.count__ = 0;
	local0.capacityMask__ = (uint__)(((cap__)) - ((1)));
	local0.growThreshold__ = ((((cap__)) / ((3)))) * ((2));
	return local0;
}
Map__NodeWithCtx__string____ Map__create__NodeWithCtx__string____() {
	int__ cap__ = 8;
	Map__NodeWithCtx__string____ local0;
	memset(&local0, 0, sizeof(Map__NodeWithCtx__string____));
	local0.entries__ = Array__cons__MapEntry__NodeWithCtx__string______(cap__);
	local0.count__ = 0;
	local0.capacityMask__ = (uint__)(((cap__)) - ((1)));
	local0.growThreshold__ = ((((cap__)) / ((3)))) * ((2));
	return local0;
}
Map__string__Node____ Map__create__string__Node____() {
	int__ cap__ = 8;
	Map__string__Node____ local0;
	memset(&local0, 0, sizeof(Map__string__Node____));
	local0.entries__ = Array__cons__MapEntry__string__Node______(cap__);
	local0.count__ = 0;
	local0.capacityMask__ = (uint__)(((cap__)) - ((1)));
	local0.growThreshold__ = ((((cap__)) / ((3)))) * ((2));
	return local0;
}
Map__Node__int____ Map__create__Node__int____() {
	int__ cap__ = 8;
	Map__Node__int____ local0;
	memset(&local0, 0, sizeof(Map__Node__int____));
	local0.entries__ = Array__cons__MapEntry__Node__int______(cap__);
	local0.count__ = 0;
	local0.capacityMask__ = (uint__)(((cap__)) - ((1)));
	local0.growThreshold__ = ((((cap__)) / ((3)))) * ((2));
	return local0;
}
Map__Node__Value____ Map__create__Node__Value____() {
	int__ cap__ = 8;
	Map__Node__Value____ local0;
	memset(&local0, 0, sizeof(Map__Node__Value____));
	local0.entries__ = Array__cons__MapEntry__Node__Value______(cap__);
	local0.count__ = 0;
	local0.capacityMask__ = (uint__)(((cap__)) - ((1)));
	local0.growThreshold__ = ((((cap__)) / ((3)))) * ((2));
	return local0;
}
Map__string__Ptr__FieldDef______ Map__create__string__Ptr__FieldDef______() {
	int__ cap__ = 8;
	Map__string__Ptr__FieldDef______ local0;
	memset(&local0, 0, sizeof(Map__string__Ptr__FieldDef______));
	local0.entries__ = Array__cons__MapEntry__string__Ptr__FieldDef________(cap__);
	local0.count__ = 0;
	local0.capacityMask__ = (uint__)(((cap__)) - ((1)));
	local0.growThreshold__ = ((((cap__)) / ((3)))) * ((2));
	return local0;
}
uint__ long__hash__(long__ val__) {
	return (uint__)(val__);
}
Maybe__long____ long__tryParse__(string__ s__) {
	if (string__equals__(s__, mu_____string0)) {
		Maybe__long____ local0;
		memset(&local0, 0, sizeof(Maybe__long____));
		return local0;
	}
	string__* local1 = &(s__);
	uint__ local2 = (uint__)(0);
	mu_____boundscheck(local2 < (uint__)local1->length__);
	if ((((char__*)local1->dataPtr__)[local2]) != ('-')) {
		long__ result__ = 0LL;
		{
			int__ i__ = 0;
			while (((i__)) < (((s__).length__))) {
				string__* local3 = &(s__);
				uint__ local4 = (uint__)(i__);
				mu_____boundscheck(local4 < (uint__)local3->length__);
				char__ ch__ = ((char__*)local3->dataPtr__)[local4];
				bool__ local5 = ((unsigned char)(ch__)) >= ((unsigned char)('0'));
				if (local5) {
					local5 = ((unsigned char)(ch__)) <= ((unsigned char)('9'));
				}
				if (!(local5)) {
					Maybe__long____ local6;
					memset(&local6, 0, sizeof(Maybe__long____));
					return local6;
				}
				int__ val__ = ((int__)(ch__)) - ((int__)('0'));
				if (((result__)) > ((((((long__maxValue__)) - ((long__)(val__)))) / ((long__)(10))))) {
					Maybe__long____ local7;
					memset(&local7, 0, sizeof(Maybe__long____));
					return local7;
				}
				result__ = ((((result__)) * ((long__)(10)))) + ((long__)(val__));
				i__ += 1;
			}
		}
		return Maybe__from__long____(result__);
	} else {
		if ((((s__).length__)) == ((1))) {
			Maybe__long____ local8;
			memset(&local8, 0, sizeof(Maybe__long____));
			return local8;
		}
		long__ result__ = 0LL;
		{
			int__ i__ = 1;
			while (((i__)) < (((s__).length__))) {
				string__* local9 = &(s__);
				uint__ local10 = (uint__)(i__);
				mu_____boundscheck(local10 < (uint__)local9->length__);
				char__ ch__ = ((char__*)local9->dataPtr__)[local10];
				bool__ local11 = ((unsigned char)(ch__)) >= ((unsigned char)('0'));
				if (local11) {
					local11 = ((unsigned char)(ch__)) <= ((unsigned char)('9'));
				}
				if (!(local11)) {
					Maybe__long____ local12;
					memset(&local12, 0, sizeof(Maybe__long____));
					return local12;
				}
				int__ val__ = ((int__)(ch__)) - ((int__)('0'));
				if (((result__)) < ((((((long__minValue__)) + ((long__)(val__)))) / ((long__)(10))))) {
					Maybe__long____ local13;
					memset(&local13, 0, sizeof(Maybe__long____));
					return local13;
				}
				result__ = ((((result__)) * ((long__)(10)))) - ((long__)(val__));
				i__ += 1;
			}
		}
		return Maybe__from__long____(result__);
	}
}
int__ long__compare__(long__ a__, long__ b__) {
	if (((a__)) < ((b__))) {
		return -1;
	} else {
		if (((a__)) > ((b__))) {
			return 1;
		}
	}
	return 0;
}
void__ long__writeTo__(long__ val__, StringBuilder__* sb__) {
	if (((val__)) == ((long__)(0))) {
		StringBuilder__write__(sb__, mu_____string1);
		return;
	}
	if (((val__)) < ((long__)(0))) {
		StringBuilder__write__(sb__, mu_____string2);
		if (((val__)) == ((long__minValue__))) {
			ulong__writeTo__((((ulong__)(long__maxValue__))) + ((ulong__)(1)), sb__);
			return;
		}
		val__ = -(val__);
	}
	ulong__writeTo__((ulong__)(val__), sb__);
}
Maybe__long____ long__tryParseHex__(string__ s__) {
	Maybe__ulong____ result__ = ulong__tryParseHex__(s__);
	if (!((result__).hasValue__)) {
		Maybe__long____ local0;
		memset(&local0, 0, sizeof(Maybe__long____));
		return local0;
	}
	if ((((result__).value__)) > (((ulong__)(long__maxValue__)))) {
		Maybe__long____ local1;
		memset(&local1, 0, sizeof(Maybe__long____));
		return local1;
	}
	return Maybe__from__long____((long__)((result__).value__));
}
Maybe__int____ top_____parseInt__(CommandLineArgsParser__* parser__) {
	string__ token__ = CommandLineArgsParser__readToken__(parser__);
	if (string__equals__(token__, mu_____string0)) {
		CommandLineArgsParser__expected__(parser__, mu_____string88);
		Maybe__int____ local0;
		memset(&local0, 0, sizeof(Maybe__int____));
		return local0;
	}
	Maybe__int____ val__ = int__tryParse__(token__);
	if (!((val__).hasValue__)) {
		CommandLineArgsParser__error__(parser__, mu_____string89);
	}
	return val__;
}
uint__ int__hash__(int__ val__) {
	return (uint__)(val__);
}
Maybe__int____ int__tryParse__(string__ s__) {
	Maybe__long____ pr__ = long__tryParse__(s__);
	bool__ local1 = (pr__).hasValue__;
	if (local1) {
		local1 = ((long__)(int__minValue__)) <= (((pr__).value__));
	}
	bool__ local0 = local1;
	if (local0) {
		local0 = (((pr__).value__)) <= ((long__)(int__maxValue__));
	}
	if (local0) {
		return Maybe__from__int____((int__)((pr__).value__));
	}
	Maybe__int____ local2;
	memset(&local2, 0, sizeof(Maybe__int____));
	return local2;
}
int__ int__compare__(int__ a__, int__ b__) {
	if (((a__)) < ((b__))) {
		return -1;
	} else {
		if (((a__)) > ((b__))) {
			return 1;
		}
	}
	return 0;
}
void__ int__writeTo__(int__ val__, StringBuilder__* sb__) {
	long__writeTo__((long__)(val__), sb__);
}
uint__ usize__hash__(usize__ val__) {
	return (uint__)(val__);
}
void__ usize__writeTo__(usize__ val__, StringBuilder__* sb__) {
	ulong__writeTo__((ulong__)(val__), sb__);
}
void__ ArenaAllocator__restoreState__(ArenaAllocator__* a__, pointer__ state__) {
	bool__ local0 = ((a__)->from__) <= (state__);
	if (local0) {
		local0 = (state__) <= ((a__)->to__);
	}
	mu_____assert(local0);
	(a__)->current__ = state__;
}
pointer__ ArenaAllocator__alloc__(ArenaAllocator__* a__, ssize__ numBytes__) {
	ssize__ runway__ = pointer__subtractSigned__((a__)->to__, (a__)->current__);
	mu_____assert((((usize__)(numBytes__))) <= (((usize__)(runway__))));
	numBytes__ = ((((numBytes__)) + ((ssize__)(7)))) & ((ssize__)(~(7)));
	pointer__ ptr__ = (a__)->current__;
	(a__)->current__ = ((a__)->current__) + (numBytes__);
	return ptr__;
}
pointer__ ArenaAllocator__realloc__(ArenaAllocator__* a__, pointer__ ptr__, ssize__ newSizeInBytes__, ssize__ prevSizeInBytes__, ssize__ copySizeInBytes__) {
	mu_____assert((((usize__)(prevSizeInBytes__))) <= (((usize__)(((ssize__maxValue__)) - ((ssize__)(7))))));
	prevSizeInBytes__ = ((((prevSizeInBytes__)) + ((ssize__)(7)))) & ((ssize__)(~(7)));
	bool__ local0 = ((ptr__) + (prevSizeInBytes__)) == ((a__)->current__);
	if (local0) {
		local0 = ((prevSizeInBytes__)) > ((ssize__)(0));
	}
	if (local0) {
		if (((newSizeInBytes__)) > ((prevSizeInBytes__))) {
			ArenaAllocator__alloc__(a__, ((newSizeInBytes__)) - ((prevSizeInBytes__)));
		} else {
			mu_____assert(((newSizeInBytes__)) >= ((ssize__)(0)));
			newSizeInBytes__ = ((((newSizeInBytes__)) + ((ssize__)(7)))) & ((ssize__)(~(7)));
			(a__)->current__ = (ptr__) + (newSizeInBytes__);
		}
		return ptr__;
	}
	pointer__ newPtr__ = ArenaAllocator__alloc__(a__, newSizeInBytes__);
	ssize__ local2 = copySizeInBytes__;
	ssize__ local3 = newSizeInBytes__;
	ssize__ local1 = (local2 < local3) ? local2 : local3;
	mu_____checkedcast(0 <= local1);
	memcpy(newPtr__, ptr__, (usize__)(local1));
	return newPtr__;
}
ArenaAllocator__ ArenaAllocator__cons__(ssize__ capacity__) {
	pointer__ from__ = IAllocator__alloc__(top_____currentAllocator__, capacity__);
	mu_____assert((((((usize__)(uintptr_t)(from__))) & ((usize__)(7)))) == ((usize__)(0)));
	ArenaAllocator__ local0;
	memset(&local0, 0, sizeof(ArenaAllocator__));
	local0.from__ = from__;
	local0.current__ = from__;
	local0.to__ = (from__) + (capacity__);
	return local0;
}
IAllocator__ ArenaAllocator__iAllocator_escaping__(ArenaAllocator__* a__) {
	IAllocator__ local0;
	memset(&local0, 0, sizeof(IAllocator__));
	local0.data__ = (pointer__)(a__);
	local0.allocFn__ = (fun__pointer__ssize__pointer____)(&ArenaAllocator__alloc__);
	local0.reallocFn__ = (fun__pointer__pointer__ssize__ssize__ssize__pointer____)(&ArenaAllocator__realloc__);
	return local0;
}
pointer__ ArenaAllocator__pushState__(ArenaAllocator__* a__) {
	return (a__)->current__;
}
bool__ File__tryReadToStringBuilder__(string__ path__, StringBuilder__* out__) {
	pointer__ fp__ = (pointer__)fopen(string__alloc_cstring__(path__), (cstring__)((mu_____string8).dataPtr__));
	if ((fp__) == (null__)) {
		return false__;
	}
	uint__ blockSize__ = 4096u;
	while (true__) {
		if (!(true__)) { break; }
		StringBuilder__reserveForWrite__(out__, (int__)(blockSize__));
		usize__ read__ = (usize__)fread(((out__)->dataPtr__) + ((out__)->count__), (usize__)(1), (usize__)(blockSize__), (FILE *)fp__);
		if (((read__)) > ((usize__)(0))) {
			mu_____assert(((read__)) <= ((usize__)(blockSize__)));
			usize__ local0 = read__;
			mu_____checkedcast(local0 <= (usize__)(0x7fffffff));
			(out__)->count__ = (((out__)->count__)) + (((int__)(local0)));
		} else {
			goto label0;
		}
	}
label0:
	{}
	if ((((int__)feof((FILE *)fp__))) == ((0))) {
		return false__;
	}
	if ((((int__)fclose((FILE *)fp__))) != ((0))) {
		return false__;
	}
	return true__;
}
bool__ File__tryWriteString__(string__ path__, string__ data__) {
	pointer__ fp__ = (pointer__)fopen(string__alloc_cstring__(path__), (cstring__)((mu_____string9).dataPtr__));
	if ((fp__) == (null__)) {
		return false__;
	}
	uint__ blockSize__ = 4096u;
	uint__ len__ = (uint__)((data__).length__);
	uint__ i__ = 0u;
	while (true__) {
		if (!(((i__)) < ((len__)))) { break; }
		uint__ local0 = blockSize__;
		uint__ local1 = ((len__)) - ((i__));
		uint__ size__ = (local0 < local1) ? local0 : local1;
		usize__ written__ = (usize__)fwrite(((data__).dataPtr__) + (i__), (usize__)(1), (usize__)(size__), (FILE *)fp__);
		if (((written__)) > ((usize__)(0))) {
			mu_____assert(((written__)) <= ((usize__)(size__)));
			i__ = ((i__)) + (((uint__)(written__)));
		} else {
			return false__;
		}
	}
	if ((((int__)fclose((FILE *)fp__))) != ((0))) {
		return false__;
	}
	return true__;
}
uint__ ulong__hash__(ulong__ val__) {
	return (uint__)(val__);
}
Maybe__ulong____ ulong__tryParse__(string__ s__) {
	if (string__equals__(s__, mu_____string0)) {
		Maybe__ulong____ local0;
		memset(&local0, 0, sizeof(Maybe__ulong____));
		return local0;
	}
	ulong__ result__ = 0uLL;
	ulong__ threshold__ = 1844674407370955161uLL;
	{
		int__ i__ = 0;
		while (((i__)) < (((s__).length__))) {
			string__* local1 = &(s__);
			uint__ local2 = (uint__)(i__);
			mu_____boundscheck(local2 < (uint__)local1->length__);
			char__ ch__ = ((char__*)local1->dataPtr__)[local2];
			bool__ local3 = ((unsigned char)(ch__)) >= ((unsigned char)('0'));
			if (local3) {
				local3 = ((unsigned char)(ch__)) <= ((unsigned char)('9'));
			}
			if (!(local3)) {
				Maybe__ulong____ local4;
				memset(&local4, 0, sizeof(Maybe__ulong____));
				return local4;
			}
			int__ val__ = ((int__)(ch__)) - ((int__)('0'));
			if (((result__)) >= ((threshold__))) {
				if (((val__)) > ((5))) {
					Maybe__ulong____ local5;
					memset(&local5, 0, sizeof(Maybe__ulong____));
					return local5;
				} else {
					if (((result__)) > ((threshold__))) {
						Maybe__ulong____ local6;
						memset(&local6, 0, sizeof(Maybe__ulong____));
						return local6;
					}
				}
			}
			result__ = ((((result__)) * ((ulong__)(10)))) + (((ulong__)(val__)));
			i__ += 1;
		}
	}
	return Maybe__from__ulong____(result__);
}
int__ ulong__compare__(ulong__ a__, ulong__ b__) {
	if (((a__)) < ((b__))) {
		return -1;
	} else {
		if (((a__)) > ((b__))) {
			return 1;
		}
	}
	return 0;
}
void__ ulong__writeTo__(ulong__ val__, StringBuilder__* sb__) {
	if (((val__)) == ((ulong__)(0))) {
		StringBuilder__write__(sb__, mu_____string1);
		return;
	}
	int__ from__ = (sb__)->count__;
	while (true__) {
		if (!(((val__)) > ((ulong__)(0)))) { break; }
		ulong__ digit__ = ((val__)) % ((ulong__)(10));
		StringBuilder__writeChar__(sb__, (char__)(('0') + (digit__)));
		val__ = ((val__)) / ((ulong__)(10));
	}
	StringBuilder__reverseSlice__(sb__, from__, (sb__)->count__);
}
Maybe__ulong____ ulong__tryParseHex__(string__ s__) {
	bool__ local0 = string__equals__(s__, mu_____string0);
	if (!local0) {
		local0 = (((s__).length__)) > ((16));
	}
	if (local0) {
		Maybe__ulong____ local1;
		memset(&local1, 0, sizeof(Maybe__ulong____));
		return local1;
	}
	ulong__ result__ = 0uLL;
	{
		int__ i__ = 0;
		while (((i__)) < (((s__).length__))) {
			string__* local2 = &(s__);
			uint__ local3 = (uint__)(i__);
			mu_____boundscheck(local3 < (uint__)local2->length__);
			char__ ch__ = ((char__*)local2->dataPtr__)[local3];
			int__ val__ = 0;
			bool__ local4 = ((unsigned char)(ch__)) >= ((unsigned char)('0'));
			if (local4) {
				local4 = ((unsigned char)(ch__)) <= ((unsigned char)('9'));
			}
			if (local4) {
				val__ = ((int__)(ch__)) - ((int__)('0'));
			} else {
				bool__ local5 = ((unsigned char)(ch__)) >= ((unsigned char)('A'));
				if (local5) {
					local5 = ((unsigned char)(ch__)) <= ((unsigned char)('F'));
				}
				if (local5) {
					val__ = ((((int__)(ch__)) - ((int__)('A')))) + ((10));
				} else {
					bool__ local6 = ((unsigned char)(ch__)) >= ((unsigned char)('a'));
					if (local6) {
						local6 = ((unsigned char)(ch__)) <= ((unsigned char)('f'));
					}
					if (local6) {
						val__ = ((((int__)(ch__)) - ((int__)('a')))) + ((10));
					} else {
						Maybe__ulong____ local7;
						memset(&local7, 0, sizeof(Maybe__ulong____));
						return local7;
					}
				}
			}
			result__ = ((((result__)) * ((ulong__)(16)))) + (((ulong__)(val__)));
			i__ += 1;
		}
	}
	return Maybe__from__ulong____(result__);
}
void__ ulong__writeHexTo__(ulong__ val__, StringBuilder__* sb__) {
	if (((val__)) == ((ulong__)(0))) {
		StringBuilder__write__(sb__, mu_____string1);
		return;
	}
	int__ from__ = (sb__)->count__;
	while (true__) {
		if (!(((val__)) > ((ulong__)(0)))) { break; }
		ulong__ digit__ = ((val__)) & ((ulong__)(15));
		if (((digit__)) < ((ulong__)(10))) {
			StringBuilder__writeChar__(sb__, (char__)(('0') + (digit__)));
		} else {
			StringBuilder__writeChar__(sb__, (char__)(((char__)(('a') + (digit__))) - (10)));
		}
		val__ = ((ulong__)val__) >> (4);
	}
	StringBuilder__reverseSlice__(sb__, from__, (sb__)->count__);
}
void__ Emulator__reset__(EmulatorState__* s__) {
	EmulatorRunner__run__(s__, (s__)->resetProgram__);
	Emulator__commitValues__(s__);
}
void__ Emulator__commitValues__(EmulatorState__* s__) {
	{
		int__ i__ = 0;
		while (((i__)) < ((((s__)->ws__)->count__))) {
			List__Value____* local0 = (s__)->rs__;
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->count__);
			List__Value____* local2 = (s__)->ws__;
			uint__ local3 = (uint__)(i__);
			mu_____boundscheck(local3 < (uint__)local2->count__);
			((Value__*)local0->dataPtr__)[local1] = ((Value__*)local2->dataPtr__)[local3];
			i__ += 1;
		}
	}
}
EmulatorState__* Emulator__init__(Compilation__* comp__, ModuleDef__* top__) {
	EmulatorState__* local0 = (EmulatorState__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(EmulatorState__));
	EmulatorState__ local1;
	memset(&local1, 0, sizeof(EmulatorState__));
	local1.comp__ = comp__;
	local1.symbols__ = (comp__)->symbols__;
	local1.typeMap__ = (comp__)->typeMap__;
	local1.constMap__ = (comp__)->constMap__;
	local1.entities__ = (comp__)->entities__;
	local1.errors__ = (comp__)->errors__;
	List__Ptr__ModuleInstance______* local2 = (List__Ptr__ModuleInstance______*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Ptr__ModuleInstance______));
	List__Ptr__ModuleInstance______ local3;
	memset(&local3, 0, sizeof(List__Ptr__ModuleInstance______));
	*local2 = local3;
	local1.moduleInstances__ = local2;
	Map__Node__int____* local4 = (Map__Node__int____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Map__Node__int____));
	*local4 = Map__create__Node__int____();
	local1.nextId__ = local4;
	List__Value____* local5 = (List__Value____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Value____));
	List__Value____ local6;
	memset(&local6, 0, sizeof(List__Value____));
	*local5 = local6;
	local1.rs__ = local5;
	List__Value____* local7 = (List__Value____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Value____));
	List__Value____ local8;
	memset(&local8, 0, sizeof(List__Value____));
	*local7 = local8;
	local1.ws__ = local7;
	List__SlotInfo____* local9 = (List__SlotInfo____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__SlotInfo____));
	List__SlotInfo____ local10;
	memset(&local10, 0, sizeof(List__SlotInfo____));
	*local9 = local10;
	local1.infos__ = local9;
	List__int____* local11 = (List__int____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__int____));
	List__int____ local12;
	memset(&local12, 0, sizeof(List__int____));
	*local11 = local12;
	local1.evalOrder__ = local11;
	local1.evalCtxField__ = -1;
	local1.evalCtxOutput__ = -1;
	List__Instruction____* local13 = (List__Instruction____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Instruction____));
	List__Instruction____ local14;
	memset(&local14, 0, sizeof(List__Instruction____));
	*local13 = local14;
	local1.resetProgram__ = local13;
	List__Instruction____* local15 = (List__Instruction____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Instruction____));
	List__Instruction____ local16;
	memset(&local16, 0, sizeof(List__Instruction____));
	*local15 = local16;
	local1.stepProgram__ = local15;
	List__Value____* local17 = (List__Value____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Value____));
	List__Value____ local18;
	memset(&local18, 0, sizeof(List__Value____));
	*local17 = local18;
	local1.stack__ = local17;
	local1.cycle__ = (long__)(-1);
	*local0 = local1;
	EmulatorState__* s__ = local0;
	EmulatorAllocator__top__(s__, top__);
	Emulator__commitValues__(s__);
	EmulatorOrderCalculator__comp__(s__);
	if (((((s__)->errors__)->count__)) > ((0))) {
		return s__;
	}
	(s__)->tape__ = (s__)->resetProgram__;
	{
		List__int____* local19 = (s__)->evalOrder__;
		int__ local20 = 0;
		while (local20 < local19->count__) {
			int__ si__ = ((int__*)(local19->dataPtr__))[local20];
			List__SlotInfo____* local22 = (s__)->infos__;
			uint__ local23 = (uint__)(si__);
			mu_____boundscheck(local23 < (uint__)local22->count__);
			bool__ local21 = (((SlotInfo__*)local22->dataPtr__)[local23]).isStatic__;
			if (!local21) {
				List__SlotInfo____* local24 = (s__)->infos__;
				uint__ local25 = (uint__)(si__);
				mu_____boundscheck(local25 < (uint__)local24->count__);
				local21 = (((SlotInfo__*)local24->dataPtr__)[local25]).isReg__;
			}
			if (local21) {
				EmulatorStep__slot__(s__, si__);
			}
			local20 += 1;
		}
	}
	if ((((((s__)->comp__)->flags__)) & ((CompilationFlags__simulate__))) != (0)) {
		(s__)->tape__ = (s__)->stepProgram__;
		{
			List__int____* local26 = (s__)->evalOrder__;
			int__ local27 = 0;
			while (local27 < local26->count__) {
				int__ si__ = ((int__*)(local26->dataPtr__))[local27];
				List__SlotInfo____* local29 = (s__)->infos__;
				uint__ local30 = (uint__)(si__);
				mu_____boundscheck(local30 < (uint__)local29->count__);
				bool__ local28 = !((((SlotInfo__*)local29->dataPtr__)[local30]).isStatic__);
				if (local28) {
					List__SlotInfo____* local31 = (s__)->infos__;
					uint__ local32 = (uint__)(si__);
					mu_____boundscheck(local32 < (uint__)local31->count__);
					local28 = !((((SlotInfo__*)local31->dataPtr__)[local32]).isReg__);
				}
				if (local28) {
					EmulatorStep__slot__(s__, si__);
				}
				local27 += 1;
			}
		}
		{
			List__Ptr__ModuleInstance______* local33 = (s__)->moduleInstances__;
			int__ local34 = 0;
			while (local34 < local33->count__) {
				ModuleInstance__* mi__ = ((ModuleInstance__**)(local33->dataPtr__))[local34];
				EmulatorStep__module__(s__, mi__);
				bool__ local35 = (((s__)->evalCtxField__)) == ((-1));
				if (local35) {
					local35 = (((s__)->evalCtxOutput__)) == ((-1));
				}
				mu_____assert(local35);
				local34 += 1;
			}
		}
	}
	return s__;
}
void__ Emulator__step__(EmulatorState__* s__, string__ clk__, ulong__ val__) {
	List__Ptr__ModuleInstance______* local0 = (s__)->moduleInstances__;
	uint__ local1 = (uint__)(0);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	EmulatorRunner__setInput__(s__, ((ModuleInstance__**)local0->dataPtr__)[local1], clk__, val__);
	EmulatorRunner__run__(s__, (s__)->stepProgram__);
}
void__ CommandLineArgsParser__error__(CommandLineArgsParser__* self__, string__ text__) {
	Array__string____* local0 = (self__)->args__;
	uint__ local1 = (uint__)((((self__)->index__)) - ((1)));
	mu_____boundscheck(local1 < (uint__)local0->count__);
	string__ arg__ = ((string__*)local0->dataPtr__)[local1];
	CommandLineArgsParserError__ local2;
	memset(&local2, 0, sizeof(CommandLineArgsParserError__));
	local2.index__ = (((self__)->index__)) - ((1));
	local2.innerSpan__ = IntRange__cons__(0, (arg__).length__);
	local2.text__ = text__;
	List__add__CommandLineArgsParserError____((self__)->errors__, local2);
}
string__ CommandLineArgsParser__readToken__(CommandLineArgsParser__* self__) {
	if ((((self__)->index__)) >= ((((self__)->args__)->count__))) {
		return mu_____string0;
	}
	Array__string____* local0 = (self__)->args__;
	uint__ local1 = (uint__)((self__)->index__);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	string__ result__ = ((string__*)local0->dataPtr__)[local1];
	(self__)->index__ = (((self__)->index__)) + ((1));
	return result__;
}
string__ CommandLineArgsParser__getErrorDesc__(CommandLineArgsParserError__ e__, CommandLineInfo__ info__) {
	IntRange__ local0;
	memset(&local0, 0, sizeof(IntRange__));
	IntRange__ span__ = local0;
	int__ extraSpaces__ = 0;
	if ((((e__).index__)) >= ((((info__).argSpans__)->count__))) {
		Array__IntRange____* local1 = (info__).argSpans__;
		uint__ local2 = (uint__)(((((info__).argSpans__)->count__)) - ((1)));
		mu_____boundscheck(local2 < (uint__)local1->count__);
		int__ at__ = (((IntRange__*)local1->dataPtr__)[local2]).to__;
		span__ = IntRange__cons__(at__, at__);
		extraSpaces__ = 1;
	} else {
		Array__IntRange____* local3 = (info__).argSpans__;
		uint__ local4 = (uint__)((e__).index__);
		mu_____boundscheck(local4 < (uint__)local3->count__);
		int__ offset__ = (((IntRange__*)local3->dataPtr__)[local4]).from__;
		span__ = IntRange__cons__(((offset__)) + ((((e__).innerSpan__).from__)), ((offset__)) + ((((e__).innerSpan__).to__)));
	}
	int__ indent__ = ((CommandLineArgsParser__getNumColumns___(string__slice__((info__).text__, 0, (span__).from__), 4))) + ((extraSpaces__));
	int__ width__ = ((CommandLineArgsParser__getNumColumns___(string__slice__((info__).text__, (span__).from__, (span__).to__), 4))) + ((extraSpaces__));
	StringBuilder__ local5;
	memset(&local5, 0, sizeof(local5));
	StringBuilder__write__(&local5, (e__).text__);
	string__ local6 = { (pointer__)"\x0a""", 1 };
	StringBuilder__write__(&local5, local6);
	StringBuilder__write__(&local5, string__replace__((info__).text__, mu_____string81, mu_____string82));
	string__ local7 = { (pointer__)"\x0a""", 1 };
	StringBuilder__write__(&local5, local7);
	StringBuilder__write__(&local5, string__repeatChar__(' ', indent__));
	int__ local8 = 1;
	int__ local9 = width__;
	StringBuilder__write__(&local5, string__repeatChar__('~', (local8 > local9) ? local8 : local9));
	return StringBuilder__compactToString__(&local5);
}
CommandLineArgsParser__ CommandLineArgsParser__from__(Array__string____* args__, List__CommandLineArgsParserError____* errors__) {
	mu_____assert((((args__)->count__)) >= ((1)));
	CommandLineArgsParser__ local0;
	memset(&local0, 0, sizeof(CommandLineArgsParser__));
	local0.index__ = 1;
	local0.args__ = args__;
	local0.errors__ = errors__;
	return local0;
}
CommandLineInfo__ CommandLineArgsParser__getCommandLineInfo__(CommandLineArgsParser__* self__) {
	CommandLineInfo__ local0;
	memset(&local0, 0, sizeof(CommandLineInfo__));
	Array__IntRange____* local1 = (Array__IntRange____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__IntRange____));
	*local1 = Array__cons__IntRange____(((self__)->args__)->count__);
	local0.argSpans__ = local1;
	CommandLineInfo__ result__ = local0;
	StringBuilder__* local2 = (StringBuilder__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(StringBuilder__));
	StringBuilder__ local3;
	memset(&local3, 0, sizeof(StringBuilder__));
	*local2 = local3;
	StringBuilder__* sb__ = local2;
	bool__ insertSep__ = false__;
	{
		int__ i__ = 0;
		while (((i__)) < ((((self__)->args__)->count__))) {
			if (insertSep__) {
				StringBuilder__write__(sb__, mu_____string78);
			} else {
				insertSep__ = true__;
			}
			Array__string____* local4 = (self__)->args__;
			uint__ local5 = (uint__)(i__);
			mu_____boundscheck(local5 < (uint__)local4->count__);
			string__ a__ = ((string__*)local4->dataPtr__)[local5];
			int__ from__ = (sb__)->count__;
			int__ delta__ = 0;
			if (((string__indexOfChar__(a__, ' '))) >= ((0))) {
				StringBuilder__write__(sb__, mu_____string79);
				StringBuilder__write__(sb__, a__);
				StringBuilder__write__(sb__, mu_____string79);
				delta__ = 1;
			} else {
				StringBuilder__write__(sb__, a__);
			}
			Array__IntRange____* local6 = (result__).argSpans__;
			uint__ local7 = (uint__)(i__);
			mu_____boundscheck(local7 < (uint__)local6->count__);
			((IntRange__*)local6->dataPtr__)[local7] = IntRange__cons__(((from__)) + ((delta__)), (((sb__)->count__)) - ((delta__)));
			i__ += 1;
		}
	}
	(result__).text__ = StringBuilder__toString__(sb__);
	return result__;
}
void__ CommandLineArgsParser__expected__(CommandLineArgsParser__* self__, string__ text__) {
	CommandLineArgsParserError__ local0;
	memset(&local0, 0, sizeof(CommandLineArgsParserError__));
	local0.index__ = (self__)->index__;
	StringBuilder__ local1;
	memset(&local1, 0, sizeof(local1));
	string__ local2 = { (pointer__)"Expected: ", 10 };
	StringBuilder__write__(&local1, local2);
	StringBuilder__write__(&local1, text__);
	local0.text__ = StringBuilder__compactToString__(&local1);
	List__add__CommandLineArgsParserError____((self__)->errors__, local0);
}
int__ CommandLineArgsParser__getNumColumns___(string__ s__, int__ tabSize__) {
	int__ cols__ = 0;
	{
		int__ i__ = 0;
		while (((i__)) < (((s__).length__))) {
			string__* local0 = &(s__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->length__);
			if ((((char__*)local0->dataPtr__)[local1]) == ('\t')) {
				cols__ = ((cols__)) + ((tabSize__));
			} else {
				cols__ = ((cols__)) + ((1));
			}
			i__ += 1;
		}
	}
	return cols__;
}
void__ CrashHandler__enable__() {
}
void__ TypeChecker__expectedConstant__(TypeCheckerState__* s__, Node__ e__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), mu_____string144));
}
void__ TypeChecker__badBinaryOp__(TypeCheckerState__* s__, Token__* op__, Tag__ lhs__, Tag__ rhs__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Cannot apply operator ", 22 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, (op__)->value__);
	string__ local2 = { (pointer__)" to arguments of type ", 22 };
	StringBuilder__write__(&local0, local2);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, lhs__));
	string__ local3 = { (pointer__)" and ", 5 };
	StringBuilder__write__(&local0, local3);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, rhs__));
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (op__)->span__, StringBuilder__compactToString__(&local0)));
}
void__ TypeChecker__moduleInput__(TypeCheckerState__* s__, ModuleInputDef__* input__) {
	if ((((((s__)->module__)->flags__)) & ((ModuleFlags__top__))) != (0)) {
		if (((((input__)->flags__)) & ((ModuleInputFlags__static__))) != (0)) {
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((input__)->name__)->span__, mu_____string186));
		}
	}
	if (((input__)->type__) != (null__)) {
		Node__ local0;
		local0.dataPtr__ = (pointer__)(input__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
		Tag__ tag__ = TypeChecker__typename__(s__, local0, (input__)->type__);
		if (Tag__isValid__(tag__)) {
			bool__ local1 = ((tag__).kind__) == (TagKind__number__);
			if (!local1) {
				local1 = (((s__)->module__)->blackboxKeyword__) == (null__);
			}
			if (local1) {
			} else {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((input__)->type__)->span__, mu_____string187));
			}
			((s__)->module__)->numInputSlots__ = ((((s__)->module__)->numInputSlots__)) + ((TypeChecker__numSlots__((s__)->comp__, tag__)));
		}
	}
}
bool__ TypeChecker__isValidEntityName__(string__ s__) {
	string__* local0 = &(s__);
	uint__ local1 = (uint__)(0);
	mu_____boundscheck(local1 < (uint__)local0->length__);
	return (((char__*)local0->dataPtr__)[local1]) != ('$');
}
void__ TypeChecker__statementNotAllowedInsideBlackbox__(TypeCheckerState__* s__, Node__ e__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), mu_____string108));
}
void__ TypeChecker__unit__(TypeCheckerState__* s__, CodeUnit__* unit__) {
	(s__)->unit__ = unit__;
	{
		List__Node____* local0 = (unit__)->contents__;
		int__ local1 = 0;
		while (local1 < local0->count__) {
			Node__ n__ = ((Node__*)(local0->dataPtr__))[local1];
			switch ((n__).id__) {
				case Node_____Ptr__ConstDef____: {
					ConstDef__* local2 = (ConstDef__*)(n__.dataPtr__);
					TypeChecker__const__(s__, local2);
					break;
				}
				case Node_____Ptr__StructDef____: {
					StructDef__* local3 = (StructDef__*)(n__.dataPtr__);
					TypeChecker__struct___(s__, local3);
					break;
				}
				case Node_____Ptr__ModuleDef____: {
					ModuleDef__* local4 = (ModuleDef__*)(n__.dataPtr__);
					TypeChecker__module__(s__, local4);
					break;
				}
				default: {
					{
					}
					break;
				}
				case 0: {
					mu_____nomatch();
				}
			}
			local1 += 1;
		}
	}
}
void__ TypeChecker__expectedFixedNumber__(TypeCheckerState__* s__, Node__ e__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), mu_____string134));
}
int__ TypeChecker__highestBit__(ulong__ n__) {
	int__ result__ = 0;
	while (true__) {
		if (!(((n__)) != ((ulong__)(0)))) { break; }
		n__ = ((ulong__)n__) >> (1);
		result__ = ((result__)) + ((1));
	}
	return result__;
}
void__ TypeChecker__badUnify__(TypeCheckerState__* s__, Token__* token__, Tag__ te__, Tag__ fe__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Cannot unify values of type ", 28 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, te__));
	string__ local2 = { (pointer__)" and ", 5 };
	StringBuilder__write__(&local0, local2);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, fe__));
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (token__)->span__, StringBuilder__compactToString__(&local0)));
}
bool__ TypeChecker__canConvertFreeConst__(TypeCheckerState__* s__, Value__ val__, int__ width__) {
	if (((val__).kind__) == (ValueKind__ulong___)) {
		return ((TypeChecker__highestBit__((val__).z__))) <= ((width__));
	}
	return false__;
}
Tag__ TypeChecker__tag__(TypeCheckerState__* s__, string__ name__) {
	string__* local0 = &(name__);
	uint__ local1 = (uint__)(0);
	mu_____boundscheck(local1 < (uint__)local0->length__);
	if ((((char__*)local0->dataPtr__)[local1]) == ('$')) {
		Maybe__int____ pr__ = int__tryParse__(string__slice__(name__, 1, (name__).length__));
		bool__ local2 = (pr__).hasValue__;
		if (local2) {
			local2 = (((pr__).value__)) > ((0));
		}
		if (local2) {
			Tag__ local3;
			memset(&local3, 0, sizeof(Tag__));
			local3.kind__ = TagKind__number__;
			local3.q__ = (pr__).value__;
			return local3;
		}
	} else {
		Node__ sym__ = Map__getOrDefault__string__Node____((s__)->symbols__, name__);
		bool__ local4 = ((sym__).dataPtr__) != ((pointer__)(null__));
		if (local4) {
			local4 = (sym__).id__ == Node_____Ptr__StructDef____;
		}
		if (local4) {
			Tag__ local5;
			memset(&local5, 0, sizeof(Tag__));
			local5.kind__ = TagKind__struct___;
			Node__ local6 = sym__;
			mu_____checkedcast(local6.id__ == Node_____Ptr__StructDef____);
			local5.q__ = ((StructDef__*)(local6.dataPtr__))->id__;
			return local5;
		}
	}
	Tag__ local7;
	memset(&local7, 0, sizeof(Tag__));
	return local7;
}
void__ TypeChecker__reg__(TypeCheckerState__* s__, AssignStatement__* st__) {
	if (((st__)->outKeyword__) != (null__)) {
		(st__)->outputIndex__ = (((s__)->module__)->outputs__)->count__;
		List__add__Ptr__AssignStatement______(((s__)->module__)->outputs__, st__);
	}
	if ((((s__)->module__)->blackboxKeyword__) != (null__)) {
		Node__ local0;
		local0.dataPtr__ = (pointer__)((st__)->regKeyword__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		TypeChecker__statementNotAllowedInsideBlackbox__(s__, local0);
	}
	if (((st__)->nameExpr__).id__ == Node_____Ptr__Token____) {
		Node__ local1 = (st__)->nameExpr__;
		mu_____checkedcast(local1.id__ == Node_____Ptr__Token____);
		if (TypeChecker__isValidEntityName_nonStatic__(((Token__*)(local1.dataPtr__))->value__)) {
		} else {
			TypeChecker__invalidNamePrefix_nonStatic__(s__, (st__)->nameExpr__);
		}
	} else {
		if ((((st__)->nameExpr__).dataPtr__) != ((pointer__)(null__))) {
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((st__)->nameExpr__), mu_____string110));
		}
	}
	if (((st__)->op__) != (null__)) {
		if (string__equals__(((st__)->op__)->value__, mu_____string111)) {
			if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
			} else {
				List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, (((st__)->op__)->span__).to__, mu_____string25));
			}
		} else {
			if (string__equals__(((st__)->op__)->value__, mu_____string44)) {
				(st__)->flags__ = (((st__)->flags__)) | ((AssignFlags__regUpdate__));
				if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
					if ((s__)->inClock__) {
					} else {
						IntRange__ local2;
						if (((st__)->outKeyword__) != (null__)) {
							local2 = ((st__)->outKeyword__)->span__;
						} else {
							local2 = RangeFinder__find__((st__)->nameExpr__);
						}
						List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, local2, mu_____string112));
					}
				} else {
					List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, (((st__)->op__)->span__).to__, mu_____string25));
				}
			} else {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((st__)->op__)->span__, mu_____string113));
			}
		}
	} else {
		if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((st__)->expr__), mu_____string22));
		}
	}
	if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
		if (((st__)->type__) != (null__)) {
			Node__ local3;
			local3.dataPtr__ = (pointer__)(st__);
			local3.id__ = local3.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
			Tag__ tag__ = TypeChecker__typename__(s__, local3, (st__)->type__);
			if (((((st__)->flags__)) & ((AssignFlags__regUpdate__))) != (0)) {
				(st__)->flags__ = (((st__)->flags__)) | ((AssignFlags__typeCheckDone__));
			}
			(s__)->isStaticExpr__ = ((((st__)->flags__)) & ((AssignFlags__regUpdate__))) == (0);
			TypeCheckResult__ rhs__ = TypeChecker__expressionWithGap__(s__, (st__)->expr__, ((st__)->type__) != (null__), tag__);
			(s__)->isStaticExpr__ = false__;
			bool__ local4 = ((st__)->op__) != (null__);
			if (local4) {
				local4 = Tag__isValid__(tag__);
			}
			if (local4) {
				if (TypeChecker__isFixedNumberOrStruct__(tag__)) {
					if (Tag__isValid__((rhs__).tag__)) {
						if (TypeChecker__canAssign__(s__, (rhs__).tag__, (rhs__).value__, tag__)) {
							((s__)->module__)->numRegSlots__ = ((((s__)->module__)->numRegSlots__)) + ((TypeChecker__numSlots__((s__)->comp__, tag__)));
						} else {
							TypeChecker__badAssign__(s__, (st__)->op__, (rhs__).tag__, tag__);
						}
					}
				} else {
					Node__ local5;
					local5.dataPtr__ = (pointer__)((st__)->type__);
					local5.id__ = local5.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
					TypeChecker__expectedFixedNumberOrStruct__(s__, local5);
				}
			}
		} else {
			(s__)->isStaticExpr__ = ((((st__)->flags__)) & ((AssignFlags__regUpdate__))) == (0);
			TypeCheckResult__ rhs__ = TypeChecker__expression__(s__, (st__)->expr__);
			(s__)->isStaticExpr__ = false__;
			if (Tag__isValid__((rhs__).tag__)) {
				if (TypeChecker__isFixedNumberOrStruct__((rhs__).tag__)) {
					Node__ local6;
					local6.dataPtr__ = (pointer__)(st__);
					local6.id__ = local6.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
					Map__add__Node__Tag____((s__)->typeMap__, local6, (rhs__).tag__);
					((s__)->module__)->numRegSlots__ = ((((s__)->module__)->numRegSlots__)) + ((TypeChecker__numSlots__((s__)->comp__, (rhs__).tag__)));
				} else {
					TypeChecker__expectedFixedNumberOrStructExpression__(s__, (st__)->expr__);
				}
			}
		}
	} else {
		if (((st__)->type__) != (null__)) {
			Node__ local7;
			local7.dataPtr__ = (pointer__)(st__);
			local7.id__ = local7.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
			Tag__ tag__ = TypeChecker__typename__(s__, local7, (st__)->type__);
			if (Tag__isValid__(tag__)) {
				if (TypeChecker__isFixedNumberOrStruct__(tag__)) {
					((s__)->module__)->numRegSlots__ = ((((s__)->module__)->numRegSlots__)) + ((TypeChecker__numSlots__((s__)->comp__, tag__)));
				} else {
					Node__ local8;
					local8.dataPtr__ = (pointer__)((st__)->type__);
					local8.id__ = local8.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
					TypeChecker__expectedFixedNumberOrStruct__(s__, local8);
				}
			}
		} else {
			List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, (RangeFinder__find__((st__)->nameExpr__)).to__, mu_____string121));
		}
	}
}
void__ TypeChecker__fieldDef__(TypeCheckerState__* s__, FieldDef__* def__) {
	if (Map__tryAdd__string__Ptr__FieldDef______(((s__)->struct___)->symbols__, ((def__)->name__)->value__, def__)) {
		(def__)->fieldIndex__ = (((((s__)->struct___)->symbols__)->count__)) - ((1));
	} else {
		TypeChecker__duplicateSymbol__(s__, (def__)->name__);
	}
	if (!(TypeChecker__isValidEntityName_nonStatic__(((def__)->name__)->value__))) {
		Node__ local0;
		local0.dataPtr__ = (pointer__)((def__)->name__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		TypeChecker__invalidNamePrefix_nonStatic__(s__, local0);
	}
	if (((def__)->type__) != (null__)) {
		Node__ local1;
		local1.dataPtr__ = (pointer__)(def__);
		local1.id__ = local1.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
		Tag__ tag__ = TypeChecker__typename__(s__, local1, (def__)->type__);
		if (Tag__isValid__(tag__)) {
			bool__ local2 = ((tag__).kind__) == (TagKind__number__);
			if (local2) {
				local2 = (((tag__).q__)) > ((0));
			}
			if (local2) {
				if ((((tag__).q__)) <= ((64))) {
				} else {
					List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((def__)->type__)->span__, mu_____string133));
				}
			} else {
				Node__ local3;
				local3.dataPtr__ = (pointer__)((def__)->type__);
				local3.id__ = local3.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
				TypeChecker__expectedFixedNumber__(s__, local3);
			}
		}
	}
}
void__ TypeChecker__ensureAssignDone__(TypeCheckerState__* s__, AssignStatement__* st__, Node__ reference__) {
	mu_____assert(((((st__)->flags__)) & ((((AssignFlags__reg__)) | ((AssignFlags__wire__))))) != (0));
	if (((((st__)->flags__)) & ((AssignFlags__typeCheckDone__))) != (0)) {
	} else {
		if (((((st__)->flags__)) & ((AssignFlags__typeCheckStarted__))) == (0)) {
			TypeCheckerContext__ prev__ = TypeChecker__pushContext__(s__, ((st__)->module__)->unit__, (st__)->module__);
			TypeChecker__assign__(s__, st__);
			TypeChecker__restoreContext__(s__, prev__);
		} else {
			string__ local0;
			if (((((st__)->flags__)) & ((AssignFlags__reg__))) != (0)) {
				local0 = mu_____string146;
			} else {
				local0 = mu_____string147;
			}
			string__ kind__ = local0;
			StringBuilder__ local1;
			memset(&local1, 0, sizeof(local1));
			string__ local2 = { (pointer__)"Recursive reference to ", 23 };
			StringBuilder__write__(&local1, local2);
			StringBuilder__write__(&local1, kind__);
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(reference__), StringBuilder__compactToString__(&local1)));
		}
	}
}
void__ TypeChecker__wire__(TypeCheckerState__* s__, AssignStatement__* st__) {
	if (((st__)->outKeyword__) != (null__)) {
		(st__)->outputIndex__ = (((s__)->module__)->outputs__)->count__;
		List__add__Ptr__AssignStatement______(((s__)->module__)->outputs__, st__);
	}
	bool__ local0 = (((s__)->module__)->blackboxKeyword__) != (null__);
	if (local0) {
		local0 = ((st__)->outKeyword__) == (null__);
	}
	if (local0) {
		List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, (RangeFinder__find__((st__)->nameExpr__)).from__, mu_____string122));
	}
	if (((st__)->nameExpr__).id__ == Node_____Ptr__Token____) {
		if (((st__)->outKeyword__) == (null__)) {
			Node__ local1 = (st__)->nameExpr__;
			mu_____checkedcast(local1.id__ == Node_____Ptr__Token____);
			if (TypeChecker__isValidEntityName__(((Token__*)(local1.dataPtr__))->value__)) {
			} else {
				TypeChecker__invalidNamePrefix__(s__, (st__)->nameExpr__);
			}
		} else {
			Node__ local2 = (st__)->nameExpr__;
			mu_____checkedcast(local2.id__ == Node_____Ptr__Token____);
			if (TypeChecker__isValidEntityName_nonStatic__(((Token__*)(local2.dataPtr__))->value__)) {
			} else {
				TypeChecker__invalidNamePrefix_nonStatic__(s__, (st__)->nameExpr__);
			}
		}
	} else {
		if ((((st__)->nameExpr__).dataPtr__) != ((pointer__)(null__))) {
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((st__)->nameExpr__), mu_____string110));
		}
	}
	if ((((s__)->module__)->blackboxKeyword__) == (null__)) {
		if (((st__)->op__) != (null__)) {
			if (string__equals__(((st__)->op__)->value__, mu_____string74)) {
				if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
				} else {
					List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, (((st__)->op__)->span__).to__, mu_____string25));
				}
			} else {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((st__)->op__)->span__, mu_____string123));
			}
		} else {
			Node__ local3;
			if (((st__)->type__) != (null__)) {
				Node__ local4;
				local4.dataPtr__ = (pointer__)((st__)->type__);
				local4.id__ = local4.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
				local3 = local4;
			} else {
				Node__ local5;
				if ((((st__)->nameExpr__).dataPtr__) != ((pointer__)(null__))) {
					local5 = (st__)->nameExpr__;
				} else {
					Node__ local6;
					local6.dataPtr__ = (pointer__)((st__)->outKeyword__);
					local6.id__ = local6.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
					local5 = local6;
				}
				local3 = local5;
			}
			List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, (RangeFinder__find__(local3)).to__, mu_____string123));
		}
		if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
			if (((st__)->type__) != (null__)) {
				Node__ local7;
				local7.dataPtr__ = (pointer__)(st__);
				local7.id__ = local7.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
				Tag__ tag__ = TypeChecker__typename__(s__, local7, (st__)->type__);
				(s__)->isStaticExpr__ = ((((st__)->flags__)) & ((AssignFlags__static__))) != (0);
				TypeCheckResult__ rhs__ = TypeChecker__expressionWithGap__(s__, (st__)->expr__, ((st__)->type__) != (null__), tag__);
				(s__)->isStaticExpr__ = false__;
				bool__ local8 = ((st__)->op__) != (null__);
				if (local8) {
					local8 = Tag__isValid__(tag__);
				}
				if (local8) {
					if (TypeChecker__isFixedNumberOrStruct__(tag__)) {
						if (TypeChecker__canAssign__(s__, (rhs__).tag__, (rhs__).value__, tag__)) {
						} else {
							TypeChecker__badAssign__(s__, (st__)->op__, (rhs__).tag__, tag__);
						}
					} else {
						Node__ local9;
						local9.dataPtr__ = (pointer__)((st__)->type__);
						local9.id__ = local9.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
						TypeChecker__expectedFixedNumberOrStruct__(s__, local9);
					}
				}
			} else {
				(s__)->isStaticExpr__ = ((((st__)->flags__)) & ((AssignFlags__static__))) != (0);
				TypeCheckResult__ rhs__ = TypeChecker__expression__(s__, (st__)->expr__);
				(s__)->isStaticExpr__ = false__;
				if (Tag__isValid__((rhs__).tag__)) {
					if (TypeChecker__isFixedNumberOrStructOrModuleOut__((rhs__).tag__)) {
						Node__ local10;
						local10.dataPtr__ = (pointer__)(st__);
						local10.id__ = local10.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
						Map__add__Node__Tag____((s__)->typeMap__, local10, (rhs__).tag__);
						bool__ local11 = (((rhs__).tag__).kind__) == (TagKind__moduleOut__);
						if (local11) {
							local11 = ((st__)->outKeyword__) != (null__);
						}
						if (local11) {
							List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((st__)->outKeyword__)->span__, mu_____string124));
						}
					} else {
						if (((((st__)->flags__)) & ((AssignFlags__static__))) != (0)) {
							TypeChecker__expectedFixedNumberOrStructExpression__(s__, (st__)->expr__);
						} else {
							List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((st__)->expr__), mu_____string125));
						}
					}
				}
			}
		}
	} else {
		if (((st__)->type__) != (null__)) {
			Node__ local12;
			local12.dataPtr__ = (pointer__)(st__);
			local12.id__ = local12.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
			Tag__ tag__ = TypeChecker__typename__(s__, local12, (st__)->type__);
			if (((tag__).kind__) == (TagKind__number__)) {
			} else {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((st__)->type__)->span__, mu_____string126));
			}
		} else {
			Node__ local13;
			if ((((st__)->nameExpr__).dataPtr__) != ((pointer__)(null__))) {
				local13 = (st__)->nameExpr__;
			} else {
				Node__ local14;
				local14.dataPtr__ = (pointer__)((st__)->outKeyword__);
				local14.id__ = local14.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
				local13 = local14;
			}
			List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, (RangeFinder__find__(local13)).to__, mu_____string121));
		}
		if (((st__)->op__) != (null__)) {
			if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, IntRange__cons__((((st__)->op__)->span__).from__, (RangeFinder__find__((st__)->expr__)).to__), mu_____string127));
			} else {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((st__)->op__)->span__, mu_____string127));
			}
		} else {
			if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((st__)->expr__), mu_____string127));
			}
		}
	}
}
void__ TypeChecker__if___(TypeCheckerState__* s__, IfStatement__* st__) {
	if (!((s__)->inClock__)) {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((st__)->ifKeyword__)->span__, mu_____string112));
	}
	if ((((s__)->module__)->blackboxKeyword__) != (null__)) {
		Node__ local0;
		local0.dataPtr__ = (pointer__)((st__)->ifKeyword__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		TypeChecker__statementNotAllowedInsideBlackbox__(s__, local0);
	}
	TypeCheckResult__ local1;
	if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
		local1 = TypeChecker__expression__(s__, (st__)->expr__);
	} else {
		TypeCheckResult__ local2;
		memset(&local2, 0, sizeof(TypeCheckResult__));
		local1 = local2;
	}
	TypeCheckResult__ cond__ = local1;
	if (Tag__isValid__((cond__).tag__)) {
		bool__ local3 = (((cond__).tag__).kind__) == (TagKind__number__);
		if (local3) {
			local3 = ((((cond__).tag__).q__)) == ((1));
		}
		if (local3) {
		} else {
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((st__)->expr__), mu_____string136));
		}
	}
	TypeChecker__block__(s__, (st__)->ifBody__);
	if (((st__)->elseBranch__).id__ == Node_____Ptr__IfStatement____) {
		Node__ local4 = (st__)->elseBranch__;
		mu_____checkedcast(local4.id__ == Node_____Ptr__IfStatement____);
		TypeChecker__if___(s__, (IfStatement__*)(local4.dataPtr__));
	} else {
		if (((st__)->elseBranch__).id__ == Node_____Ptr__Block____) {
			Node__ local5 = (st__)->elseBranch__;
			mu_____checkedcast(local5.id__ == Node_____Ptr__Block____);
			TypeChecker__block__(s__, (Block__*)(local5.dataPtr__));
		}
	}
}
void__ TypeChecker__badConstConversion__(TypeCheckerState__* s__, Node__ e__, Tag__ from__, Tag__ to__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Cannot convert constant of type ", 32 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, from__));
	string__ local2 = { (pointer__)" to ", 4 };
	StringBuilder__write__(&local0, local2);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, to__));
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), StringBuilder__compactToString__(&local0)));
}
void__ TypeChecker__module__(TypeCheckerState__* s__, ModuleDef__* def__) {
	if (((((def__)->flags__)) & ((ModuleFlags__typeCheckDone__))) != (0)) {
		return;
	}
	(def__)->flags__ = (((def__)->flags__)) | ((ModuleFlags__typeCheckStarted__));
	(s__)->module__ = def__;
	if (!(TypeChecker__isValidEntityName_nonStatic__(((def__)->name__)->value__))) {
		Node__ local0;
		local0.dataPtr__ = (pointer__)((def__)->name__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		TypeChecker__invalidNamePrefix_nonStatic__(s__, local0);
	}
	bool__ local1 = ((def__)->blackboxKeyword__) != (null__);
	if (local1) {
		local1 = (((((s__)->comp__)->flags__)) & ((CompilationFlags__simulate__))) != (0);
	}
	if (local1) {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((def__)->blackboxKeyword__)->span__, mu_____string185));
	}
	{
		List__Ptr__ModuleInputDef______* local2 = (def__)->inputs__;
		int__ local3 = 0;
		while (local3 < local2->count__) {
			ModuleInputDef__* inp__ = ((ModuleInputDef__**)(local2->dataPtr__))[local3];
			TypeChecker__moduleInput__(s__, inp__);
			local3 += 1;
		}
	}
	TypeChecker__block__(s__, (def__)->body__);
	(def__)->flags__ = (((def__)->flags__)) | ((ModuleFlags__typeCheckDone__));
}
void__ TypeChecker__ensureStructDone__(TypeCheckerState__* s__, StructDef__* def__) {
	if (((((def__)->flags__)) & ((StructFlags__typeCheckDone__))) != (0)) {
		TypeCheckerContext__ prev__ = TypeChecker__pushContext__(s__, (def__)->unit__, null__);
		TypeChecker__struct___(s__, def__);
		TypeChecker__restoreContext__(s__, prev__);
	}
}
void__ TypeChecker__ensureModuleDone__(TypeCheckerState__* s__, ModuleDef__* def__, Node__ location__) {
	if (((((def__)->flags__)) & ((ModuleFlags__typeCheckDone__))) != (0)) {
	} else {
		if (((((def__)->flags__)) & ((ModuleFlags__typeCheckStarted__))) == (0)) {
			TypeCheckerContext__ prev__ = TypeChecker__pushContext__(s__, (def__)->unit__, (s__)->module__);
			TypeChecker__module__(s__, def__);
			TypeChecker__restoreContext__(s__, prev__);
		} else {
			StringBuilder__ local0;
			memset(&local0, 0, sizeof(local0));
			string__ local1 = { (pointer__)"Recursive reference to module: ", 31 };
			StringBuilder__write__(&local0, local1);
			StringBuilder__write__(&local0, ((def__)->name__)->value__);
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(location__), StringBuilder__compactToString__(&local0)));
		}
	}
}
TypeCheckResult__ TypeChecker__number__(TypeCheckerState__* s__, NumberExpression__* e__) {
	if (((((e__)->flags__)) & ((NumberFlags__valid__))) != (0)) {
		if (((((e__)->flags__)) & ((NumberFlags__dontCare__))) == (0)) {
			TypeCheckResult__ local0;
			memset(&local0, 0, sizeof(TypeCheckResult__));
			Tag__ local1;
			memset(&local1, 0, sizeof(Tag__));
			local1.kind__ = TagKind__number__;
			local1.q__ = (e__)->width__;
			local0.tag__ = local1;
			Value__ local2;
			memset(&local2, 0, sizeof(Value__));
			local2.kind__ = ValueKind__ulong___;
			local2.z__ = (e__)->value__;
			local0.value__ = local2;
			return local0;
		} else {
			if ((s__)->allowDontCare__) {
				if ((((e__)->width__)) > ((0))) {
					TypeCheckResult__ local3;
					memset(&local3, 0, sizeof(TypeCheckResult__));
					Tag__ local4;
					memset(&local4, 0, sizeof(Tag__));
					local4.kind__ = TagKind__number__;
					local4.q__ = (e__)->width__;
					local3.tag__ = local4;
					return local3;
				} else {
					mu_____assert((((e__)->value__)) == ((ulong__)(0)));
					bool__ local6 = (s__)->gap__;
					if (local6) {
						local6 = (((s__)->gapTag__).kind__) == (TagKind__number__);
					}
					bool__ local5 = local6;
					if (local5) {
						local5 = ((((s__)->gapTag__).q__)) > ((0));
					}
					if (local5) {
						TypeCheckResult__ local7;
						memset(&local7, 0, sizeof(TypeCheckResult__));
						Tag__ local8;
						memset(&local8, 0, sizeof(Tag__));
						local8.kind__ = TagKind__number__;
						local8.q__ = ((s__)->gapTag__).q__;
						local7.tag__ = local8;
						return local7;
					} else {
						List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((e__)->token__)->span__, mu_____string151));
					}
				}
			} else {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((e__)->token__)->span__, mu_____string151));
			}
		}
	}
	TypeCheckResult__ local9;
	memset(&local9, 0, sizeof(TypeCheckResult__));
	return local9;
}
TypeCheckResult__ TypeChecker__dot__(TypeCheckerState__* s__, DotExpression__* e__) {
	TypeCheckResult__ local0;
	memset(&local0, 0, sizeof(TypeCheckResult__));
	TypeCheckResult__ result__ = local0;
	TypeCheckResult__ lhs__ = TypeChecker__expression__(s__, (e__)->lhs__);
	if (Tag__isValid__((lhs__).tag__)) {
		if ((((lhs__).tag__).kind__) == (TagKind__moduleOut__)) {
			List__Node____* local2 = ((s__)->comp__)->entities__;
			uint__ local3 = (uint__)(((lhs__).tag__).q__);
			mu_____boundscheck(local3 < (uint__)local2->count__);
			Node__ local1 = ((Node__*)local2->dataPtr__)[local3];
			mu_____checkedcast(local1.id__ == Node_____Ptr__ModuleDef____);
			ModuleDef__* def__ = (ModuleDef__*)(local1.dataPtr__);
			mu_____assert(((((def__)->flags__)) & ((ModuleFlags__typeCheckStarted__))) != (0));
			if (((e__)->rhs__) != (null__)) {
				Node__ output__ = Map__getOrDefault__string__Node____((def__)->symbols__, ((e__)->rhs__)->value__);
				bool__ local4 = (output__).id__ == Node_____Ptr__AssignStatement____;
				if (local4) {
					Node__ local5 = output__;
					mu_____checkedcast(local5.id__ == Node_____Ptr__AssignStatement____);
					local4 = (((AssignStatement__*)(local5.dataPtr__))->outKeyword__) != (null__);
				}
				if (local4) {
					(result__).tag__ = Map__getOrDefault__Node__Tag____((s__)->typeMap__, output__);
				} else {
					StringBuilder__ local6;
					memset(&local6, 0, sizeof(local6));
					string__ local7 = { (pointer__)"Undefined output: ", 18 };
					StringBuilder__write__(&local6, local7);
					StringBuilder__write__(&local6, ((def__)->name__)->value__);
					string__ local8 = { (pointer__)".", 1 };
					StringBuilder__write__(&local6, local8);
					StringBuilder__write__(&local6, ((e__)->rhs__)->value__);
					List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((e__)->rhs__)->span__, StringBuilder__compactToString__(&local6)));
				}
			}
		} else {
			if ((((lhs__).tag__).kind__) == (TagKind__struct___)) {
				List__Node____* local10 = ((s__)->comp__)->entities__;
				uint__ local11 = (uint__)(((lhs__).tag__).q__);
				mu_____boundscheck(local11 < (uint__)local10->count__);
				Node__ local9 = ((Node__*)local10->dataPtr__)[local11];
				mu_____checkedcast(local9.id__ == Node_____Ptr__StructDef____);
				StructDef__* def__ = (StructDef__*)(local9.dataPtr__);
				TypeChecker__ensureStructDone__(s__, def__);
				if (((e__)->rhs__) != (null__)) {
					FieldDef__* field__ = Map__getOrDefault__string__Ptr__FieldDef______((def__)->symbols__, ((e__)->rhs__)->value__);
					if ((field__) != (null__)) {
						Node__ local12;
						local12.dataPtr__ = (pointer__)(field__);
						local12.id__ = local12.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
						(result__).tag__ = Map__getOrDefault__Node__Tag____((s__)->typeMap__, local12);
					} else {
						StringBuilder__ local13;
						memset(&local13, 0, sizeof(local13));
						string__ local14 = { (pointer__)"Undefined field: ", 17 };
						StringBuilder__write__(&local13, local14);
						StringBuilder__write__(&local13, ((def__)->name__)->value__);
						string__ local15 = { (pointer__)".", 1 };
						StringBuilder__write__(&local13, local15);
						StringBuilder__write__(&local13, ((e__)->rhs__)->value__);
						List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((e__)->rhs__)->span__, StringBuilder__compactToString__(&local13)));
					}
				}
			} else {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->lhs__), mu_____string162));
			}
		}
	}
	return result__;
}
TypeCheckResult__ TypeChecker__structInit__(TypeCheckerState__* s__, StructInitializerExpression__* e__) {
	Token__* target__ = (Token__*)(null__);
	StructDef__* def__ = (StructDef__*)(null__);
	bool__ local0 = ((e__)->target__).id__ == Node_____Ptr__Token____;
	if (local0) {
		Node__ local1 = (e__)->target__;
		mu_____checkedcast(local1.id__ == Node_____Ptr__Token____);
		local0 = (((Token__*)(local1.dataPtr__))->type__) == (TokenType__identifier__);
	}
	if (local0) {
		Node__ local2 = (e__)->target__;
		mu_____checkedcast(local2.id__ == Node_____Ptr__Token____);
		target__ = (Token__*)(local2.dataPtr__);
		Node__ node__ = Map__getOrDefault__string__Node____((s__)->symbols__, (target__)->value__);
		if ((node__).id__ == Node_____Ptr__StructDef____) {
			Node__ local3 = node__;
			mu_____checkedcast(local3.id__ == Node_____Ptr__StructDef____);
			def__ = (StructDef__*)(local3.dataPtr__);
			TypeChecker__ensureStructDone__(s__, def__);
		} else {
			if (((node__).dataPtr__) != ((pointer__)(null__))) {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (target__)->span__, mu_____string191));
			} else {
				TypeChecker__badSymbol__(s__, target__);
			}
		}
	} else {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->target__), mu_____string191));
	}
	if ((def__) != (null__)) {
		Array__int____* local4 = (Array__int____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__int____));
		*local4 = Array__cons__int____(((def__)->fields__)->count__);
		(e__)->fieldIndexToArgIndex__ = local4;
		{
			int__ i__ = 0;
			while (((i__)) < ((((def__)->fields__)->count__))) {
				Array__int____* local5 = (e__)->fieldIndexToArgIndex__;
				uint__ local6 = (uint__)(i__);
				mu_____boundscheck(local6 < (uint__)local5->count__);
				((int__*)local5->dataPtr__)[local6] = -1;
				i__ += 1;
			}
		}
		{
			List__Ptr__CallArg______* local7 = (e__)->args__;
			int__ i__ = 0;
			while (i__ < local7->count__) {
				CallArg__* arg__ = ((CallArg__**)(local7->dataPtr__))[i__];
				Tag__ local8;
				memset(&local8, 0, sizeof(Tag__));
				Tag__ tag__ = local8;
				if (((arg__)->name__) != (null__)) {
					FieldDef__* field__ = Map__getOrDefault__string__Ptr__FieldDef______((def__)->symbols__, ((arg__)->name__)->value__);
					if ((field__) != (null__)) {
						Array__int____* local9 = (e__)->fieldIndexToArgIndex__;
						uint__ local10 = (uint__)((field__)->fieldIndex__);
						mu_____boundscheck(local10 < (uint__)local9->count__);
						if (((((int__*)local9->dataPtr__)[local10])) == ((-1))) {
							Array__int____* local11 = (e__)->fieldIndexToArgIndex__;
							uint__ local12 = (uint__)((field__)->fieldIndex__);
							mu_____boundscheck(local12 < (uint__)local11->count__);
							((int__*)local11->dataPtr__)[local12] = i__;
						} else {
							List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((arg__)->name__)->span__, mu_____string192));
						}
						Node__ local13;
						local13.dataPtr__ = (pointer__)(field__);
						local13.id__ = local13.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
						tag__ = Map__getOrDefault__Node__Tag____((s__)->typeMap__, local13);
					} else {
						StringBuilder__ local14;
						memset(&local14, 0, sizeof(local14));
						string__ local15 = { (pointer__)"Undefined field: ", 17 };
						StringBuilder__write__(&local14, local15);
						StringBuilder__write__(&local14, ((def__)->name__)->value__);
						string__ local16 = { (pointer__)".", 1 };
						StringBuilder__write__(&local14, local16);
						StringBuilder__write__(&local14, ((arg__)->name__)->value__);
						List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((arg__)->name__)->span__, StringBuilder__compactToString__(&local14)));
					}
				}
				if ((((arg__)->expr__).dataPtr__) != ((pointer__)(null__))) {
					TypeCheckResult__ rhs__ = TypeChecker__expressionWithGap__(s__, (arg__)->expr__, true__, tag__);
					if (!(TypeChecker__canAssign__(s__, (rhs__).tag__, (rhs__).value__, tag__))) {
						TypeChecker__badAssign__(s__, (arg__)->colon__, (rhs__).tag__, tag__);
					}
					if (((arg__)->name__) == (null__)) {
						List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, (RangeFinder__find__((arg__)->expr__)).from__, mu_____string193));
					}
				}
				i__ += 1;
			}
		}
		TypeCheckResult__ local17;
		memset(&local17, 0, sizeof(TypeCheckResult__));
		Tag__ local18;
		memset(&local18, 0, sizeof(Tag__));
		local18.kind__ = TagKind__struct___;
		local18.q__ = (def__)->id__;
		local17.tag__ = local18;
		return local17;
	} else {
		{
			List__Ptr__CallArg______* local19 = (e__)->args__;
			int__ local20 = 0;
			while (local20 < local19->count__) {
				CallArg__* arg__ = ((CallArg__**)(local19->dataPtr__))[local20];
				if ((((arg__)->expr__).dataPtr__) != ((pointer__)(null__))) {
					TypeChecker__expression__(s__, (arg__)->expr__);
				}
				local20 += 1;
			}
		}
		TypeCheckResult__ local21;
		memset(&local21, 0, sizeof(TypeCheckResult__));
		return local21;
	}
}
bool__ TypeChecker__isFixedNumberOrStructOrModuleOut__(Tag__ tag__) {
	bool__ local2 = ((tag__).kind__) == (TagKind__number__);
	if (local2) {
		local2 = (((tag__).q__)) > ((0));
	}
	bool__ local1 = local2;
	if (!local1) {
		local1 = ((tag__).kind__) == (TagKind__struct___);
	}
	bool__ local0 = local1;
	if (!local0) {
		local0 = ((tag__).kind__) == (TagKind__moduleOut__);
	}
	return local0;
}
void__ TypeChecker__badConversion__(TypeCheckerState__* s__, Node__ e__, Tag__ from__, Tag__ to__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Cannot convert ", 15 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, from__));
	string__ local2 = { (pointer__)" to ", 4 };
	StringBuilder__write__(&local0, local2);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, to__));
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), StringBuilder__compactToString__(&local0)));
}
int__ TypeChecker__unpackWidth__(Tag__ tag__) {
	mu_____assert(((tag__).kind__) == (TagKind__number__));
	mu_____assert((((tag__).q__)) > ((0)));
	return (tag__).q__;
}
TypeCheckResult__ TypeChecker__array__(TypeCheckerState__* s__, ArrayExpression__* e__) {
	Array__byte____* local0 = (Array__byte____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__byte____));
	*local0 = List__slice__byte____((e__)->data__, 0, ((e__)->data__)->count__);
	Array__byte____* data__ = local0;
	int__ width__ = (((data__)->count__)) * ((8));
	TypeCheckResult__ local1;
	memset(&local1, 0, sizeof(TypeCheckResult__));
	Tag__ local2;
	memset(&local2, 0, sizeof(Tag__));
	local2.kind__ = TagKind__number__;
	local2.q__ = width__;
	local1.tag__ = local2;
	Value__ local3;
	if (((width__)) > ((64))) {
		local3 = EmulatorRunner__packArray__(data__);
	} else {
		local3 = EmulatorRunner__packULong__(data__);
	}
	local1.value__ = local3;
	return local1;
}
void__ TypeChecker__unsupportedUnaryOp__(TypeCheckerState__* s__, Token__* op__, Tag__ tag__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Unsupported expression: cannot apply operator ", 46 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, (op__)->value__);
	string__ local2 = { (pointer__)" to argument of type ", 21 };
	StringBuilder__write__(&local0, local2);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, tag__));
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (op__)->span__, StringBuilder__compactToString__(&local0)));
}
void__ TypeChecker__badUnaryOp__(TypeCheckerState__* s__, Token__* op__, Tag__ tag__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Cannot apply operator ", 22 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, (op__)->value__);
	string__ local2 = { (pointer__)" to argument of type ", 21 };
	StringBuilder__write__(&local0, local2);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, tag__));
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (op__)->span__, StringBuilder__compactToString__(&local0)));
}
TypeCheckResult__ TypeChecker__call__(TypeCheckerState__* s__, CallExpression__* e__) {
	if (((e__)->builtin__) == (BuiltinCall__rep__)) {
		return TypeChecker__rep__(s__, e__);
	} else {
		if (((e__)->builtin__) == (BuiltinCall__slice__)) {
			return TypeChecker__slice__(s__, e__);
		} else {
			if (((e__)->builtin__) == (BuiltinCall__chunk__)) {
				return TypeChecker__chunk__(s__, e__);
			} else {
				if (((e__)->builtin__) == (BuiltinCall__swizzle__)) {
					return TypeChecker__swizzle__(s__, e__);
				}
			}
		}
	}
	if ((s__)->isStaticExpr__) {
		Node__ local0;
		local0.dataPtr__ = (pointer__)(e__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__CallExpression____ : 0;
		TypeChecker__expectedStaticConstant__(s__, local0);
		TypeCheckResult__ local1;
		memset(&local1, 0, sizeof(TypeCheckResult__));
		return local1;
	}
	Token__* target__ = (Token__*)(null__);
	ModuleDef__* def__ = (ModuleDef__*)(null__);
	bool__ local2 = ((e__)->target__).id__ == Node_____Ptr__Token____;
	if (local2) {
		Node__ local3 = (e__)->target__;
		mu_____checkedcast(local3.id__ == Node_____Ptr__Token____);
		local2 = (((Token__*)(local3.dataPtr__))->type__) == (TokenType__identifier__);
	}
	if (local2) {
		Node__ local4 = (e__)->target__;
		mu_____checkedcast(local4.id__ == Node_____Ptr__Token____);
		target__ = (Token__*)(local4.dataPtr__);
		Node__ node__ = Map__getOrDefault__string__Node____((s__)->symbols__, (target__)->value__);
		if ((node__).id__ == Node_____Ptr__ModuleDef____) {
			Node__ local5 = node__;
			mu_____checkedcast(local5.id__ == Node_____Ptr__ModuleDef____);
			def__ = (ModuleDef__*)(local5.dataPtr__);
			((s__)->module__)->numCalls__ = ((((s__)->module__)->numCalls__)) + ((1));
			(e__)->callId__ = ((s__)->module__)->numCalls__;
			Node__ local6;
			local6.dataPtr__ = (pointer__)(target__);
			local6.id__ = local6.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
			TypeChecker__ensureModuleDone__(s__, def__, local6);
			((s__)->module__)->numRegSlots__ = ((((s__)->module__)->numRegSlots__)) + (((def__)->numRegSlots__));
		} else {
			if (((node__).dataPtr__) != ((pointer__)(null__))) {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (target__)->span__, mu_____string189));
			} else {
				TypeChecker__badSymbol__(s__, target__);
			}
		}
	} else {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->target__), mu_____string190));
	}
	QueuedCallArgs__ local7;
	memset(&local7, 0, sizeof(QueuedCallArgs__));
	local7.e__ = e__;
	local7.def__ = def__;
	local7.context__ = (s__)->module__;
	List__add__QueuedCallArgs____((s__)->queue__, local7);
	TypeCheckResult__ local8;
	if ((def__) != (null__)) {
		TypeCheckResult__ local9;
		memset(&local9, 0, sizeof(TypeCheckResult__));
		Tag__ local10;
		memset(&local10, 0, sizeof(Tag__));
		local10.kind__ = TagKind__moduleOut__;
		local10.q__ = (def__)->id__;
		local9.tag__ = local10;
		local8 = local9;
	} else {
		TypeCheckResult__ local11;
		memset(&local11, 0, sizeof(TypeCheckResult__));
		local8 = local11;
	}
	return local8;
}
void__ TypeChecker__badAssign__(TypeCheckerState__* s__, Token__* at__, Tag__ from__, Tag__ to__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Cannot assign ", 14 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, from__));
	string__ local2 = { (pointer__)" to ", 4 };
	StringBuilder__write__(&local0, local2);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, to__));
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (at__)->span__, StringBuilder__compactToString__(&local0)));
}
TypeCheckResult__ TypeChecker__index__(TypeCheckerState__* s__, IndexExpression__* e__) {
	TypeCheckResult__ local0;
	memset(&local0, 0, sizeof(TypeCheckResult__));
	TypeCheckResult__ result__ = local0;
	TypeCheckResult__ target__ = TypeChecker__expression__(s__, (e__)->target__);
	bool__ targetValid__ = false__;
	if (Tag__isValid__((target__).tag__)) {
		bool__ local1 = (((target__).tag__).kind__) == (TagKind__number__);
		if (local1) {
			local1 = ((((target__).tag__).q__)) > ((0));
		}
		if (local1) {
			if (((((target__).tag__).q__)) <= ((64))) {
				targetValid__ = true__;
			} else {
				StringBuilder__ local2;
				memset(&local2, 0, sizeof(local2));
				string__ local3 = { (pointer__)"Unsupported expression: cannot index argument of type ", 54 };
				StringBuilder__write__(&local2, local3);
				StringBuilder__write__(&local2, TypeChecker__tagString__((s__)->comp__, (target__).tag__));
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((e__)->openBracket__)->span__, StringBuilder__compactToString__(&local2)));
			}
		} else {
			StringBuilder__ local4;
			memset(&local4, 0, sizeof(local4));
			string__ local5 = { (pointer__)"Cannot index argument of type ", 30 };
			StringBuilder__write__(&local4, local5);
			StringBuilder__write__(&local4, TypeChecker__tagString__((s__)->comp__, (target__).tag__));
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((e__)->openBracket__)->span__, StringBuilder__compactToString__(&local4)));
		}
	}
	if ((((e__)->upperExpr__).dataPtr__) != ((pointer__)(null__))) {
		TypeCheckResult__ upper__ = TypeChecker__expression__(s__, (e__)->upperExpr__);
		bool__ upperValid__ = false__;
		if (Tag__isValid__((upper__).tag__)) {
			bool__ local6 = (((upper__).tag__).kind__) == (TagKind__number__);
			if (local6) {
				local6 = (((upper__).value__).kind__) == (ValueKind__ulong___);
			}
			if (local6) {
				if (targetValid__) {
					if (((((upper__).value__).z__)) < (((ulong__)(((target__).tag__).q__)))) {
						upperValid__ = true__;
					} else {
						List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->upperExpr__), mu_____string170));
					}
				}
			} else {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->upperExpr__), mu_____string166));
			}
		}
		if ((((e__)->lowerExpr__).dataPtr__) != ((pointer__)(null__))) {
			TypeCheckResult__ lower__ = TypeChecker__expression__(s__, (e__)->lowerExpr__);
			if (Tag__isValid__((lower__).tag__)) {
				bool__ local7 = (((lower__).tag__).kind__) == (TagKind__number__);
				if (local7) {
					local7 = (((lower__).value__).kind__) == (ValueKind__ulong___);
				}
				if (local7) {
					if (targetValid__) {
						if (((((lower__).value__).z__)) < (((ulong__)(((target__).tag__).q__)))) {
							if (upperValid__) {
								if (((((lower__).value__).z__)) <= ((((upper__).value__).z__))) {
									Tag__ local8;
									memset(&local8, 0, sizeof(Tag__));
									local8.kind__ = TagKind__number__;
									local8.q__ = (((((int__)(((upper__).value__).z__))) - (((int__)(((lower__).value__).z__))))) + ((1));
									(result__).tag__ = local8;
								} else {
									List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->lowerExpr__), mu_____string171));
								}
							}
						} else {
							List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->lowerExpr__), mu_____string170));
						}
					}
				} else {
					List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->lowerExpr__), mu_____string166));
				}
			}
		} else {
			Tag__ local9;
			memset(&local9, 0, sizeof(Tag__));
			local9.kind__ = TagKind__number__;
			local9.q__ = 1;
			(result__).tag__ = local9;
		}
	}
	return result__;
}
void__ TypeChecker__badSymbol__(TypeCheckerState__* s__, Token__* token__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Undefined symbol: ", 18 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, (token__)->value__);
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (token__)->span__, StringBuilder__compactToString__(&local0)));
}
void__ TypeChecker__invalidNamePrefix__(TypeCheckerState__* s__, Node__ e__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), mu_____string105));
}
void__ TypeChecker__builtinArgs__(TypeCheckerState__* s__, CallExpression__* e__, int__ count__) {
	if (((((e__)->args__)->count__)) != ((count__))) {
		StringBuilder__ local0;
		memset(&local0, 0, sizeof(local0));
		string__ local1 = { (pointer__)"Expected: ", 10 };
		StringBuilder__write__(&local0, local1);
		int__writeTo__(count__, &local0);
		string__ local2 = { (pointer__)" args but got ", 14 };
		StringBuilder__write__(&local0, local2);
		int__writeTo__(((e__)->args__)->count__, &local0);
		string__ local3 = { (pointer__)" args", 5 };
		StringBuilder__write__(&local0, local3);
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((e__)->openParen__)->span__, StringBuilder__compactToString__(&local0)));
	}
	{
		List__Ptr__CallArg______* local4 = (e__)->args__;
		int__ i__ = 0;
		while (i__ < local4->count__) {
			CallArg__* arg__ = ((CallArg__**)(local4->dataPtr__))[i__];
			if (((arg__)->name__) != (null__)) {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((arg__)->name__)->span__, mu_____string25));
			}
			if (((i__)) >= ((count__))) {
				TypeChecker__expression__(s__, (arg__)->expr__);
			}
			i__ += 1;
		}
	}
}
TypeCheckResult__ TypeChecker__ternaryOperator__(TypeCheckerState__* s__, TernaryOperatorExpression__* e__) {
	TypeCheckResult__ local0;
	memset(&local0, 0, sizeof(TypeCheckResult__));
	TypeCheckResult__ result__ = local0;
	TypeCheckResult__ cond__ = TypeChecker__expression__(s__, (e__)->conditionExpr__);
	if (Tag__isValid__((cond__).tag__)) {
		bool__ local1 = (((cond__).tag__).kind__) == (TagKind__number__);
		if (local1) {
			local1 = ((((cond__).tag__).q__)) == ((1));
		}
		if (local1) {
		} else {
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->conditionExpr__), mu_____string136));
		}
	}
	TypeCheckResult__ local2;
	if ((((e__)->trueExpr__).dataPtr__) != ((pointer__)(null__))) {
		local2 = TypeChecker__expressionContinueGap__(s__, (e__)->trueExpr__);
	} else {
		TypeCheckResult__ local3;
		memset(&local3, 0, sizeof(TypeCheckResult__));
		local2 = local3;
	}
	TypeCheckResult__ te__ = local2;
	TypeCheckResult__ local4;
	if ((((e__)->falseExpr__).dataPtr__) != ((pointer__)(null__))) {
		local4 = TypeChecker__expressionContinueGap__(s__, (e__)->falseExpr__);
	} else {
		TypeCheckResult__ local5;
		memset(&local5, 0, sizeof(TypeCheckResult__));
		local4 = local5;
	}
	TypeCheckResult__ fe__ = local4;
	bool__ local7 = (s__)->gap__;
	if (local7) {
		local7 = (((s__)->gapTag__).kind__) == (TagKind__number__);
	}
	bool__ local6 = local7;
	if (local6) {
		local6 = ((((s__)->gapTag__).q__)) > ((0));
	}
	if (local6) {
		if (Tag__isValid__((te__).tag__)) {
			if (TypeChecker__canAssign__(s__, (te__).tag__, (te__).value__, (s__)->gapTag__)) {
			} else {
				TypeChecker__badConversion__(s__, (e__)->trueExpr__, (te__).tag__, (s__)->gapTag__);
			}
		}
		if (Tag__isValid__((fe__).tag__)) {
			if (TypeChecker__canAssign__(s__, (fe__).tag__, (fe__).value__, (s__)->gapTag__)) {
			} else {
				TypeChecker__badConversion__(s__, (e__)->falseExpr__, (fe__).tag__, (s__)->gapTag__);
			}
		}
		(result__).tag__ = (s__)->gapTag__;
	} else {
		bool__ local8 = Tag__isValid__((te__).tag__);
		if (local8) {
			local8 = Tag__isValid__((fe__).tag__);
		}
		if (local8) {
			bool__ local9 = (((te__).tag__).kind__) == (TagKind__number__);
			if (local9) {
				local9 = (((fe__).tag__).kind__) == (TagKind__number__);
			}
			if (local9) {
				bool__ local10 = ((((te__).tag__).q__)) > ((0));
				if (!local10) {
					local10 = ((((fe__).tag__).q__)) > ((0));
				}
				if (local10) {
					if (((((te__).tag__).q__)) == ((0))) {
						if (TypeChecker__canConvertFreeConst__(s__, (te__).value__, ((fe__).tag__).q__)) {
							Tag__ local11;
							memset(&local11, 0, sizeof(Tag__));
							local11.kind__ = TagKind__number__;
							local11.q__ = ((fe__).tag__).q__;
							(result__).tag__ = local11;
						} else {
							TypeChecker__badBinaryOperandConversion__(s__, RangeFinder__find__((e__)->trueExpr__), (fe__).tag__);
						}
					} else {
						if (((((fe__).tag__).q__)) == ((0))) {
							if (TypeChecker__canConvertFreeConst__(s__, (fe__).value__, ((te__).tag__).q__)) {
								Tag__ local12;
								memset(&local12, 0, sizeof(Tag__));
								local12.kind__ = TagKind__number__;
								local12.q__ = ((te__).tag__).q__;
								(result__).tag__ = local12;
							} else {
								TypeChecker__badBinaryOperandConversion__(s__, RangeFinder__find__((e__)->falseExpr__), (te__).tag__);
							}
						} else {
							if (((((te__).tag__).q__)) == ((((fe__).tag__).q__))) {
								Tag__ local13;
								memset(&local13, 0, sizeof(Tag__));
								local13.kind__ = TagKind__number__;
								local13.q__ = ((te__).tag__).q__;
								(result__).tag__ = local13;
							} else {
								TypeChecker__badUnify__(s__, (e__)->question__, (te__).tag__, (fe__).tag__);
							}
						}
					}
				} else {
					Tag__ local14;
					memset(&local14, 0, sizeof(Tag__));
					local14.kind__ = TagKind__number__;
					(result__).tag__ = local14;
				}
			} else {
				TypeChecker__badUnify__(s__, (e__)->question__, (te__).tag__, (fe__).tag__);
			}
		}
	}
	return result__;
}
void__ TypeChecker__expectedFixedNumberOrStruct__(TypeCheckerState__* s__, Node__ e__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), mu_____string119));
}
TypeCheckResult__ TypeChecker__token__(TypeCheckerState__* s__, Token__* e__) {
	Node__ local0;
	if (((s__)->module__) != (null__)) {
		local0 = Map__getOrDefault__string__Node____(((s__)->module__)->symbols__, (e__)->value__);
	} else {
		Node__ local1;
		local1.dataPtr__ = null__;
		local1.id__ = 0;
		local0 = local1;
	}
	Node__ sym__ = local0;
	switch ((sym__).id__) {
		case Node_____Ptr__ModuleInputDef____: {
			ModuleInputDef__* local2 = (ModuleInputDef__*)(sym__.dataPtr__);
			{
				bool__ local3 = !((s__)->isStaticExpr__);
				if (!local3) {
					local3 = ((((local2)->flags__)) & ((ModuleInputFlags__static__))) != (0);
				}
				if (local3) {
					TypeCheckResult__ local4;
					memset(&local4, 0, sizeof(TypeCheckResult__));
					Node__ local5;
					local5.dataPtr__ = (pointer__)(local2);
					local5.id__ = local5.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
					local4.tag__ = Map__getOrDefault__Node__Tag____((s__)->typeMap__, local5);
					return local4;
				} else {
					Node__ local6;
					local6.dataPtr__ = (pointer__)(e__);
					local6.id__ = local6.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
					TypeChecker__expectedStaticConstant__(s__, local6);
					TypeCheckResult__ local7;
					memset(&local7, 0, sizeof(TypeCheckResult__));
					return local7;
				}
			}
			break;
		}
		case Node_____Ptr__AssignStatement____: {
			AssignStatement__* local8 = (AssignStatement__*)(sym__.dataPtr__);
			{
				bool__ local9 = !((s__)->isStaticExpr__);
				if (!local9) {
					local9 = ((((local8)->flags__)) & ((AssignFlags__static__))) != (0);
				}
				if (local9) {
					Node__ local10;
					local10.dataPtr__ = (pointer__)(e__);
					local10.id__ = local10.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
					TypeChecker__ensureAssignDone__(s__, local8, local10);
					TypeCheckResult__ local11;
					memset(&local11, 0, sizeof(TypeCheckResult__));
					Node__ local12;
					local12.dataPtr__ = (pointer__)(local8);
					local12.id__ = local12.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
					local11.tag__ = Map__getOrDefault__Node__Tag____((s__)->typeMap__, local12);
					return local11;
				} else {
					Node__ local13;
					local13.dataPtr__ = (pointer__)(e__);
					local13.id__ = local13.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
					TypeChecker__expectedStaticConstant__(s__, local13);
					TypeCheckResult__ local14;
					memset(&local14, 0, sizeof(TypeCheckResult__));
					return local14;
				}
			}
			break;
		}
		case 0:
		default: {
			{
				sym__ = Map__getOrDefault__string__Node____((s__)->symbols__, (e__)->value__);
				switch ((sym__).id__) {
					case Node_____Ptr__ConstDef____: {
						ConstDef__* local15 = (ConstDef__*)(sym__.dataPtr__);
						{
							Node__ local16;
							local16.dataPtr__ = (pointer__)(e__);
							local16.id__ = local16.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
							TypeChecker__ensureConstDone__(s__, local15, local16);
							TypeCheckResult__ local17;
							memset(&local17, 0, sizeof(TypeCheckResult__));
							Node__ local18;
							local18.dataPtr__ = (pointer__)(local15);
							local18.id__ = local18.dataPtr__ != null__ ? Node_____Ptr__ConstDef____ : 0;
							local17.tag__ = Map__getOrDefault__Node__Tag____((s__)->typeMap__, local18);
							local17.value__ = Map__getOrDefault__Node__Value____((s__)->constMap__, (local15)->expr__);
							return local17;
						}
						break;
					}
					default: {
						List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (e__)->span__, mu_____string150));
						break;
					}
					case 0: {
						TypeChecker__badSymbol__(s__, e__);
						break;
					}
				}
			}
			break;
		}
	}
	TypeCheckResult__ local19;
	memset(&local19, 0, sizeof(TypeCheckResult__));
	return local19;
}
TypeCheckerContext__ TypeChecker__pushContext__(TypeCheckerState__* s__, CodeUnit__* unit__, ModuleDef__* def__) {
	TypeCheckerContext__ local0;
	memset(&local0, 0, sizeof(TypeCheckerContext__));
	local0.unit__ = (s__)->unit__;
	local0.module__ = (s__)->module__;
	local0.inClock__ = (s__)->inClock__;
	local0.isStaticExpr__ = (s__)->isStaticExpr__;
	local0.allowDontCare__ = (s__)->allowDontCare__;
	TypeCheckerContext__ result__ = local0;
	(s__)->unit__ = unit__;
	(s__)->module__ = def__;
	(s__)->inClock__ = false__;
	(s__)->isStaticExpr__ = false__;
	(s__)->allowDontCare__ = false__;
	return result__;
}
TypeCheckResult__ TypeChecker__brace__(TypeCheckerState__* s__, BraceExpression__* e__) {
	bool__ allValid__ = true__;
	int__ bits__ = 0;
	{
		List__Node____* local0 = (e__)->args__;
		int__ local1 = 0;
		while (local1 < local0->count__) {
			Node__ arg__ = ((Node__*)(local0->dataPtr__))[local1];
			bool__ prevAllowDontCare__ = (s__)->allowDontCare__;
			(s__)->allowDontCare__ = (arg__).id__ == Node_____Ptr__NumberExpression____;
			TypeCheckResult__ atr__ = TypeChecker__expression__(s__, arg__);
			(s__)->allowDontCare__ = prevAllowDontCare__;
			if (Tag__isValid__((atr__).tag__)) {
				bool__ local2 = (((atr__).tag__).kind__) == (TagKind__number__);
				if (local2) {
					local2 = ((((atr__).tag__).q__)) > ((0));
				}
				if (local2) {
					bits__ = ((bits__)) + ((((atr__).tag__).q__));
				} else {
					List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(arg__), mu_____string142));
				}
			} else {
				allValid__ = false__;
			}
			local1 += 1;
		}
	}
	if (((bits__)) > ((64))) {
		Node__ local3;
		local3.dataPtr__ = (pointer__)(e__);
		local3.id__ = local3.dataPtr__ != null__ ? Node_____Ptr__BraceExpression____ : 0;
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(local3), mu_____string172));
	}
	TypeCheckResult__ local4;
	if (allValid__) {
		TypeCheckResult__ local5;
		memset(&local5, 0, sizeof(TypeCheckResult__));
		Tag__ local6;
		memset(&local6, 0, sizeof(Tag__));
		local6.kind__ = TagKind__number__;
		local6.q__ = bits__;
		local5.tag__ = local6;
		local4 = local5;
	} else {
		TypeCheckResult__ local7;
		memset(&local7, 0, sizeof(TypeCheckResult__));
		local4 = local7;
	}
	return local4;
}
void__ TypeChecker__badGapArgument__(TypeCheckerState__* s__, Token__* op__, Tag__ arg__, Tag__ target__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Cannot apply operator ", 22 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, (op__)->value__);
	string__ local2 = { (pointer__)" to argument of type ", 21 };
	StringBuilder__write__(&local0, local2);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, arg__));
	string__ local3 = { (pointer__)" and target of type ", 20 };
	StringBuilder__write__(&local0, local3);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, target__));
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (op__)->span__, StringBuilder__compactToString__(&local0)));
}
int__ TypeChecker__unpackInt__(Value__ value__) {
	mu_____assert(((value__).kind__) == (ValueKind__ulong___));
	mu_____assert((((value__).z__)) <= (((ulong__)(int__maxValue__))));
	return (int__)((value__).z__);
}
void__ TypeChecker__badGap__(TypeCheckerState__* s__, Token__* op__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Cannot apply operator ", 22 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, (op__)->value__);
	string__ local2 = { (pointer__)" because target type is inferred", 32 };
	StringBuilder__write__(&local0, local2);
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (op__)->span__, StringBuilder__compactToString__(&local0)));
}
TypeCheckResult__ TypeChecker__expressionContinueGap__(TypeCheckerState__* s__, Node__ e__) {
	TypeCheckResult__ tr__ = TypeChecker__expressionInner__(s__, e__);
	if ((((tr__).tag__).kind__) != (TagKind__unknown__)) {
		Map__add__Node__Tag____((s__)->typeMap__, e__, (tr__).tag__);
	}
	if ((((tr__).value__).kind__) != (ValueKind__none__)) {
		Map__add__Node__Value____((s__)->constMap__, e__, (tr__).value__);
	}
	return tr__;
}
TypeCheckResult__ TypeChecker__unaryOperator__(TypeCheckerState__* s__, UnaryOperatorExpression__* e__) {
	TypeCheckResult__ local0;
	memset(&local0, 0, sizeof(TypeCheckResult__));
	TypeCheckResult__ result__ = local0;
	TypeCheckResult__ local1;
	if ((((e__)->expr__).dataPtr__) != ((pointer__)(null__))) {
		local1 = TypeChecker__expression__(s__, (e__)->expr__);
	} else {
		TypeCheckResult__ local2;
		memset(&local2, 0, sizeof(TypeCheckResult__));
		local1 = local2;
	}
	TypeCheckResult__ arg__ = local1;
	bool__ valid__ = Tag__isValid__((arg__).tag__);
	string__ op__ = ((e__)->op__)->value__;
	bool__ local4 = string__equals__(op__, mu_____string2);
	if (!local4) {
		local4 = string__equals__(op__, mu_____string57);
	}
	bool__ local3 = local4;
	if (!local3) {
		local3 = string__equals__(op__, mu_____string20);
	}
	if (local3) {
		if (valid__) {
			if ((((arg__).tag__).kind__) == (TagKind__number__)) {
				bool__ local5 = string__equals__(op__, mu_____string2);
				if (!local5) {
					local5 = string__equals__(op__, mu_____string57);
				}
				if (local5) {
					if (((((arg__).tag__).q__)) <= ((64))) {
						(result__).tag__ = (arg__).tag__;
					} else {
						TypeChecker__unsupportedUnaryOp__(s__, (e__)->op__, (arg__).tag__);
					}
					bool__ local6 = Tag__isValid__((result__).tag__);
					if (local6) {
						local6 = (((arg__).value__).kind__) == (ValueKind__ulong___);
					}
					if (local6) {
						if (string__equals__(op__, mu_____string2)) {
							Value__ local7;
							memset(&local7, 0, sizeof(Value__));
							local7.kind__ = ValueKind__ulong___;
							local7.z__ = -(((arg__).value__).z__);
							(result__).value__ = local7;
						} else {
							if (string__equals__(op__, mu_____string57)) {
								Value__ local8;
								memset(&local8, 0, sizeof(Value__));
								local8.kind__ = ValueKind__ulong___;
								local8.z__ = ~(((arg__).value__).z__);
								(result__).value__ = local8;
							}
						}
						bool__ local9 = ((((result__).tag__).q__)) > ((0));
						if (local9) {
							local9 = ((((result__).tag__).q__)) < ((64));
						}
						if (local9) {
							((result__).value__).z__ = ((((result__).value__).z__)) & ((((((ulong__)1uLL) << (((result__).tag__).q__))) - ((ulong__)(1))));
						}
					}
				} else {
					if (string__equals__(op__, mu_____string20)) {
						if (((((arg__).tag__).q__)) > ((0))) {
							if ((s__)->gap__) {
								if (Tag__isValid__((s__)->gapTag__)) {
									bool__ local10 = (((s__)->gapTag__).kind__) == (TagKind__number__);
									if (local10) {
										local10 = ((((s__)->gapTag__).q__)) > ((((arg__).tag__).q__));
									}
									if (local10) {
										(result__).tag__ = (s__)->gapTag__;
									} else {
										TypeChecker__badGapArgument__(s__, (e__)->op__, (arg__).tag__, (s__)->gapTag__);
									}
								}
							} else {
								TypeChecker__badGap__(s__, (e__)->op__);
							}
						} else {
							TypeChecker__badUnaryOp__(s__, (e__)->op__, (arg__).tag__);
						}
						bool__ local11 = Tag__isValid__((result__).tag__);
						if (local11) {
							local11 = (((arg__).value__).kind__) != (ValueKind__none__);
						}
						if (local11) {
							(result__).value__ = (arg__).value__;
						}
					}
				}
			} else {
				TypeChecker__badUnaryOp__(s__, (e__)->op__, (arg__).tag__);
			}
		}
	} else {
		StringBuilder__ local12;
		memset(&local12, 0, sizeof(local12));
		string__ local13 = { (pointer__)"Invalid unary operator: ", 24 };
		StringBuilder__write__(&local12, local13);
		StringBuilder__write__(&local12, op__);
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((e__)->op__)->span__, StringBuilder__compactToString__(&local12)));
	}
	return result__;
}
void__ TypeChecker__invalidNamePrefix_nonStatic__(TypeCheckerState__* s__, Node__ e__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), mu_____string109));
}
TypeCheckResult__ TypeChecker__chunk__(TypeCheckerState__* s__, CallExpression__* e__) {
	if (((s__)->module__) == (null__)) {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->target__), mu_____string175));
	}
	if (!((s__)->isStaticExpr__)) {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->target__), mu_____string176));
	}
	TypeChecker__builtinArgs__(s__, e__, 3);
	TypeCheckResult__ arrayArg__ = TypeChecker__fixedNumberArg__(s__, e__, 0);
	TypeCheckResult__ indexArg__ = TypeChecker__constantArg__(s__, e__, 1);
	TypeCheckResult__ numChunksArg__ = TypeChecker__constantArg__(s__, e__, 2);
	TypeCheckResult__ local0;
	memset(&local0, 0, sizeof(TypeCheckResult__));
	TypeCheckResult__ result__ = local0;
	bool__ local2 = Tag__isValid__((arrayArg__).tag__);
	if (local2) {
		local2 = Tag__isValid__((indexArg__).tag__);
	}
	bool__ local1 = local2;
	if (local1) {
		local1 = Tag__isValid__((numChunksArg__).tag__);
	}
	if (local1) {
		int__ numBits__ = TypeChecker__unpackWidth__((arrayArg__).tag__);
		Maybe__int____ index__ = TypeChecker__tryUnpackInt__((indexArg__).value__);
		Maybe__int____ numChunks__ = TypeChecker__tryUnpackInt__((numChunksArg__).value__);
		bool__ local4 = (numChunks__).hasValue__;
		if (local4) {
			local4 = (((numChunks__).value__)) > ((0));
		}
		bool__ local3 = local4;
		if (local3) {
			local3 = ((((numBits__)) % (((numChunks__).value__)))) == ((0));
		}
		if (local3) {
			Tag__ local5;
			memset(&local5, 0, sizeof(Tag__));
			local5.kind__ = TagKind__number__;
			local5.q__ = ((numBits__)) / (((numChunks__).value__));
			(result__).tag__ = local5;
			if ((index__).hasValue__) {
				if ((((index__).value__)) < (((numChunks__).value__))) {
				} else {
					List__Ptr__CallArg______* local6 = (e__)->args__;
					uint__ local7 = (uint__)(1);
					mu_____boundscheck(local7 < (uint__)local6->count__);
					List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((((CallArg__**)local6->dataPtr__)[local7])->expr__), mu_____string177));
				}
			}
		} else {
			List__Ptr__CallArg______* local8 = (e__)->args__;
			uint__ local9 = (uint__)(2);
			mu_____boundscheck(local9 < (uint__)local8->count__);
			StringBuilder__ local10;
			memset(&local10, 0, sizeof(local10));
			string__ local11 = { (pointer__)"Expected: constant; must be a divisor of target type ", 53 };
			StringBuilder__write__(&local10, local11);
			StringBuilder__write__(&local10, TypeChecker__tagString__((s__)->comp__, (arrayArg__).tag__));
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((((CallArg__**)local8->dataPtr__)[local9])->expr__), StringBuilder__compactToString__(&local10)));
		}
	}
	return result__;
}
void__ TypeChecker__regUpdate__(TypeCheckerState__* s__, AssignStatement__* st__) {
	if (!((s__)->inClock__)) {
		IntRange__ local0;
		if (((st__)->outKeyword__) != (null__)) {
			local0 = ((st__)->outKeyword__)->span__;
		} else {
			local0 = RangeFinder__find__((st__)->nameExpr__);
		}
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, local0, mu_____string112));
	}
	if ((((s__)->module__)->blackboxKeyword__) != (null__)) {
		Node__ local1;
		if (((st__)->outKeyword__) != (null__)) {
			Node__ local2;
			local2.dataPtr__ = (pointer__)((st__)->outKeyword__);
			local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
			local1 = local2;
		} else {
			local1 = (st__)->nameExpr__;
		}
		TypeChecker__statementNotAllowedInsideBlackbox__(s__, local1);
	}
	if (((st__)->outKeyword__) != (null__)) {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((st__)->outKeyword__)->span__, mu_____string128));
	}
	if (((st__)->type__) != (null__)) {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((st__)->type__)->span__, mu_____string129));
	}
	if ((((st__)->expr__).dataPtr__) == ((pointer__)(null__))) {
		List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, (((st__)->op__)->span__).to__, mu_____string25));
	}
	Node__ nameExpr__ = (st__)->nameExpr__;
	switch ((nameExpr__).id__) {
		case Node_____Ptr__Token____: {
			Token__* local3 = (Token__*)(nameExpr__.dataPtr__);
			{
				Token__* nameToken__ = local3;
				Tag__ local4;
				memset(&local4, 0, sizeof(Tag__));
				Tag__ tag__ = local4;
				Node__ sym__ = Map__getOrDefault__string__Node____(((s__)->module__)->symbols__, (nameToken__)->value__);
				if (((sym__).dataPtr__) != ((pointer__)(null__))) {
					bool__ local5 = (sym__).id__ == Node_____Ptr__AssignStatement____;
					if (local5) {
						Node__ local6 = sym__;
						mu_____checkedcast(local6.id__ == Node_____Ptr__AssignStatement____);
						local5 = (((((AssignStatement__*)(local6.dataPtr__))->flags__)) & ((AssignFlags__reg__))) != (0);
					}
					if (local5) {
						Node__ local7 = sym__;
						mu_____checkedcast(local7.id__ == Node_____Ptr__AssignStatement____);
						AssignStatement__* reg__ = (AssignStatement__*)(local7.dataPtr__);
						(st__)->localId__ = (reg__)->localId__;
						Node__ local8;
						local8.dataPtr__ = (pointer__)(nameToken__);
						local8.id__ = local8.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
						TypeChecker__ensureAssignDone__(s__, reg__, local8);
						Node__ local9;
						local9.dataPtr__ = (pointer__)(reg__);
						local9.id__ = local9.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
						tag__ = Map__getOrDefault__Node__Tag____((s__)->typeMap__, local9);
					} else {
						List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (nameToken__)->span__, mu_____string130));
					}
				} else {
					TypeChecker__badSymbol__(s__, nameToken__);
				}
				if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
					TypeCheckResult__ rhs__ = TypeChecker__expressionWithGap__(s__, (st__)->expr__, true__, tag__);
					if (TypeChecker__canAssign__(s__, (rhs__).tag__, (rhs__).value__, tag__)) {
					} else {
						TypeChecker__badAssign__(s__, (st__)->op__, (rhs__).tag__, tag__);
					}
				}
			}
			break;
		}
		case Node_____Ptr__DotExpression____: {
			DotExpression__* local10 = (DotExpression__*)(nameExpr__.dataPtr__);
			{
				DotExpression__* dot__ = local10;
				if (((dot__)->lhs__).id__ == Node_____Ptr__Token____) {
					Tag__ local11;
					memset(&local11, 0, sizeof(Tag__));
					Tag__ tag__ = local11;
					Node__ local12 = (dot__)->lhs__;
					mu_____checkedcast(local12.id__ == Node_____Ptr__Token____);
					Token__* nameToken__ = (Token__*)(local12.dataPtr__);
					Node__ sym__ = Map__getOrDefault__string__Node____(((s__)->module__)->symbols__, (nameToken__)->value__);
					if (((sym__).dataPtr__) != ((pointer__)(null__))) {
						bool__ local13 = (sym__).id__ == Node_____Ptr__AssignStatement____;
						if (local13) {
							Node__ local14 = sym__;
							mu_____checkedcast(local14.id__ == Node_____Ptr__AssignStatement____);
							local13 = (((((AssignStatement__*)(local14.dataPtr__))->flags__)) & ((AssignFlags__reg__))) != (0);
						}
						if (local13) {
							Node__ local15 = sym__;
							mu_____checkedcast(local15.id__ == Node_____Ptr__AssignStatement____);
							AssignStatement__* reg__ = (AssignStatement__*)(local15.dataPtr__);
							(st__)->localId__ = (reg__)->localId__;
							Node__ local16;
							local16.dataPtr__ = (pointer__)(nameToken__);
							local16.id__ = local16.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
							TypeChecker__ensureAssignDone__(s__, reg__, local16);
							Node__ local17;
							local17.dataPtr__ = (pointer__)(reg__);
							local17.id__ = local17.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
							Tag__ regTag__ = Map__getOrDefault__Node__Tag____((s__)->typeMap__, local17);
							bool__ local18 = ((dot__)->rhs__) != (null__);
							if (local18) {
								local18 = Tag__isValid__(regTag__);
							}
							if (local18) {
								if (((regTag__).kind__) == (TagKind__struct___)) {
									List__Node____* local20 = ((s__)->comp__)->entities__;
									uint__ local21 = (uint__)((regTag__).q__);
									mu_____boundscheck(local21 < (uint__)local20->count__);
									Node__ local19 = ((Node__*)local20->dataPtr__)[local21];
									mu_____checkedcast(local19.id__ == Node_____Ptr__StructDef____);
									StructDef__* def__ = (StructDef__*)(local19.dataPtr__);
									TypeChecker__ensureStructDone__(s__, def__);
									FieldDef__* field__ = Map__getOrDefault__string__Ptr__FieldDef______((def__)->symbols__, ((dot__)->rhs__)->value__);
									if ((field__) != (null__)) {
										Node__ local22;
										local22.dataPtr__ = (pointer__)(field__);
										local22.id__ = local22.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
										tag__ = Map__getOrDefault__Node__Tag____((s__)->typeMap__, local22);
										(st__)->lhsFieldIndex__ = (field__)->fieldIndex__;
									} else {
										StringBuilder__ local23;
										memset(&local23, 0, sizeof(local23));
										string__ local24 = { (pointer__)"Undefined field: ", 17 };
										StringBuilder__write__(&local23, local24);
										StringBuilder__write__(&local23, ((def__)->name__)->value__);
										string__ local25 = { (pointer__)".", 1 };
										StringBuilder__write__(&local23, local25);
										StringBuilder__write__(&local23, ((dot__)->rhs__)->value__);
										List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((dot__)->rhs__)->span__, StringBuilder__compactToString__(&local23)));
									}
								} else {
									List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (nameToken__)->span__, mu_____string138));
								}
							}
						} else {
							List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (nameToken__)->span__, mu_____string130));
						}
					} else {
						TypeChecker__badSymbol__(s__, nameToken__);
					}
					if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
						TypeCheckResult__ rhs__ = TypeChecker__expressionWithGap__(s__, (st__)->expr__, true__, tag__);
						if (TypeChecker__canAssign__(s__, (rhs__).tag__, (rhs__).value__, tag__)) {
						} else {
							TypeChecker__badAssign__(s__, (st__)->op__, (rhs__).tag__, tag__);
						}
					}
				} else {
					Node__ local26;
					local26.dataPtr__ = (pointer__)(dot__);
					local26.id__ = local26.dataPtr__ != null__ ? Node_____Ptr__DotExpression____ : 0;
					TypeChecker__unsupportedRegUpdate__(s__, local26);
				}
			}
			break;
		}
		case Node_____Ptr__CallExpression____: {
			CallExpression__* local27 = (CallExpression__*)(nameExpr__.dataPtr__);
			{
				CallExpression__* call__ = local27;
				if (((call__)->builtin__) == (BuiltinCall__slice__)) {
					TypeChecker__assignSlice__(s__, st__, call__);
				} else {
					Node__ local28;
					local28.dataPtr__ = (pointer__)(call__);
					local28.id__ = local28.dataPtr__ != null__ ? Node_____Ptr__CallExpression____ : 0;
					TypeChecker__unsupportedRegUpdate__(s__, local28);
				}
			}
			break;
		}
		default: {
			{
				TypeChecker__unsupportedRegUpdate__(s__, nameExpr__);
			}
			break;
		}
		case 0: {
			{
			}
			break;
		}
	}
}
void__ TypeChecker__expectedFixedNumberExpression__(TypeCheckerState__* s__, Node__ e__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), mu_____string142));
}
void__ TypeChecker__assign__(TypeCheckerState__* s__, AssignStatement__* st__) {
	if (((((st__)->flags__)) & ((AssignFlags__typeCheckDone__))) != (0)) {
		return;
	}
	(st__)->flags__ = (((st__)->flags__)) | ((AssignFlags__typeCheckStarted__));
	if (((((st__)->flags__)) & ((AssignFlags__reg__))) != (0)) {
		TypeChecker__reg__(s__, st__);
	} else {
		if (((((st__)->flags__)) & ((AssignFlags__wire__))) != (0)) {
			TypeChecker__wire__(s__, st__);
		} else {
			if (((((st__)->flags__)) & ((AssignFlags__regUpdate__))) != (0)) {
				TypeChecker__regUpdate__(s__, st__);
			} else {
				mu_____abandon(-1);
			}
		}
	}
	(st__)->flags__ = (((st__)->flags__)) | ((AssignFlags__typeCheckDone__));
}
TypeCheckResult__ TypeChecker__binaryOperator__(TypeCheckerState__* s__, BinaryOperatorExpression__* e__) {
	TypeCheckResult__ local0;
	memset(&local0, 0, sizeof(TypeCheckResult__));
	TypeCheckResult__ result__ = local0;
	TypeCheckResult__ lhs__ = TypeChecker__expression__(s__, (e__)->lhs__);
	TypeCheckResult__ local1;
	if ((((e__)->rhs__).dataPtr__) != ((pointer__)(null__))) {
		local1 = TypeChecker__expression__(s__, (e__)->rhs__);
	} else {
		TypeCheckResult__ local2;
		memset(&local2, 0, sizeof(TypeCheckResult__));
		local1 = local2;
	}
	TypeCheckResult__ rhs__ = local1;
	bool__ local3 = Tag__isValid__((lhs__).tag__);
	if (local3) {
		local3 = Tag__isValid__((rhs__).tag__);
	}
	bool__ valid__ = local3;
	string__ op__ = ((e__)->op__)->value__;
	bool__ local7 = string__equals__(op__, mu_____string39);
	if (!local7) {
		local7 = string__equals__(op__, mu_____string2);
	}
	bool__ local6 = local7;
	if (!local6) {
		local6 = string__equals__(op__, mu_____string46);
	}
	bool__ local5 = local6;
	if (!local5) {
		local5 = string__equals__(op__, mu_____string48);
	}
	bool__ local4 = local5;
	if (!local4) {
		local4 = string__equals__(op__, mu_____string47);
	}
	if (local4) {
		if (valid__) {
			bool__ local8 = (((lhs__).tag__).kind__) == (TagKind__number__);
			if (local8) {
				local8 = (((rhs__).tag__).kind__) == (TagKind__number__);
			}
			if (local8) {
				bool__ local9 = ((((lhs__).tag__).q__)) > ((64));
				if (!local9) {
					local9 = ((((rhs__).tag__).q__)) > ((64));
				}
				if (local9) {
					TypeChecker__unsupportedBinaryOp__(s__, (e__)->op__, (lhs__).tag__, (rhs__).tag__);
				} else {
					bool__ local10 = ((((lhs__).tag__).q__)) > ((0));
					if (!local10) {
						local10 = ((((rhs__).tag__).q__)) > ((0));
					}
					if (local10) {
						if (((((lhs__).tag__).q__)) == ((0))) {
							if (TypeChecker__canConvertFreeConst__(s__, (lhs__).value__, ((rhs__).tag__).q__)) {
								Tag__ local11;
								memset(&local11, 0, sizeof(Tag__));
								local11.kind__ = TagKind__number__;
								local11.q__ = ((rhs__).tag__).q__;
								(result__).tag__ = local11;
							} else {
								TypeChecker__badBinaryOperandConversion__(s__, RangeFinder__find__((e__)->lhs__), (rhs__).tag__);
							}
						} else {
							if (((((rhs__).tag__).q__)) == ((0))) {
								if (TypeChecker__canConvertFreeConst__(s__, (rhs__).value__, ((lhs__).tag__).q__)) {
									Tag__ local12;
									memset(&local12, 0, sizeof(Tag__));
									local12.kind__ = TagKind__number__;
									local12.q__ = ((lhs__).tag__).q__;
									(result__).tag__ = local12;
								} else {
									TypeChecker__badBinaryOperandConversion__(s__, RangeFinder__find__((e__)->rhs__), (lhs__).tag__);
								}
							} else {
								if (((((lhs__).tag__).q__)) == ((((rhs__).tag__).q__))) {
									Tag__ local13;
									memset(&local13, 0, sizeof(Tag__));
									local13.kind__ = TagKind__number__;
									local13.q__ = ((lhs__).tag__).q__;
									(result__).tag__ = local13;
								} else {
									TypeChecker__badBinaryOp__(s__, (e__)->op__, (lhs__).tag__, (rhs__).tag__);
								}
							}
						}
					} else {
						Tag__ local14;
						memset(&local14, 0, sizeof(Tag__));
						local14.kind__ = TagKind__number__;
						(result__).tag__ = local14;
					}
				}
				bool__ local16 = Tag__isValid__((result__).tag__);
				if (local16) {
					local16 = (((lhs__).value__).kind__) == (ValueKind__ulong___);
				}
				bool__ local15 = local16;
				if (local15) {
					local15 = (((rhs__).value__).kind__) == (ValueKind__ulong___);
				}
				if (local15) {
					if (string__equals__(op__, mu_____string39)) {
						Value__ local17;
						memset(&local17, 0, sizeof(Value__));
						local17.kind__ = ValueKind__ulong___;
						local17.z__ = ((((lhs__).value__).z__)) + ((((rhs__).value__).z__));
						(result__).value__ = local17;
					} else {
						if (string__equals__(op__, mu_____string2)) {
							Value__ local18;
							memset(&local18, 0, sizeof(Value__));
							local18.kind__ = ValueKind__ulong___;
							local18.z__ = ((((lhs__).value__).z__)) - ((((rhs__).value__).z__));
							(result__).value__ = local18;
						} else {
							if (string__equals__(op__, mu_____string46)) {
								Value__ local19;
								memset(&local19, 0, sizeof(Value__));
								local19.kind__ = ValueKind__ulong___;
								local19.z__ = ((((lhs__).value__).z__)) & ((((rhs__).value__).z__));
								(result__).value__ = local19;
							} else {
								if (string__equals__(op__, mu_____string48)) {
									Value__ local20;
									memset(&local20, 0, sizeof(Value__));
									local20.kind__ = ValueKind__ulong___;
									local20.z__ = ((((lhs__).value__).z__)) | ((((rhs__).value__).z__));
									(result__).value__ = local20;
								} else {
									if (string__equals__(op__, mu_____string48)) {
										Value__ local21;
										memset(&local21, 0, sizeof(Value__));
										local21.kind__ = ValueKind__ulong___;
										local21.z__ = ((((lhs__).value__).z__)) ^ ((((rhs__).value__).z__));
										(result__).value__ = local21;
									}
								}
							}
						}
					}
					bool__ local22 = ((((result__).tag__).q__)) > ((0));
					if (local22) {
						local22 = ((((result__).tag__).q__)) < ((64));
					}
					if (local22) {
						((result__).value__).z__ = ((((result__).value__).z__)) & ((((((ulong__)1uLL) << (((result__).tag__).q__))) - ((ulong__)(1))));
					}
				}
			} else {
				TypeChecker__badBinaryOp__(s__, (e__)->op__, (lhs__).tag__, (rhs__).tag__);
			}
		}
	} else {
		bool__ local27 = string__equals__(op__, mu_____string40);
		if (!local27) {
			local27 = string__equals__(op__, mu_____string41);
		}
		bool__ local26 = local27;
		if (!local26) {
			local26 = string__equals__(op__, mu_____string42);
		}
		bool__ local25 = local26;
		if (!local25) {
			local25 = string__equals__(op__, mu_____string44);
		}
		bool__ local24 = local25;
		if (!local24) {
			local24 = string__equals__(op__, mu_____string43);
		}
		bool__ local23 = local24;
		if (!local23) {
			local23 = string__equals__(op__, mu_____string45);
		}
		if (local23) {
			if (valid__) {
				bool__ local28 = (((lhs__).tag__).kind__) == (TagKind__number__);
				if (local28) {
					local28 = (((rhs__).tag__).kind__) == (TagKind__number__);
				}
				if (local28) {
					bool__ local29 = ((((lhs__).tag__).q__)) > ((64));
					if (!local29) {
						local29 = ((((rhs__).tag__).q__)) > ((64));
					}
					if (local29) {
						TypeChecker__unsupportedBinaryOp__(s__, (e__)->op__, (lhs__).tag__, (rhs__).tag__);
					} else {
						bool__ local30 = ((((lhs__).tag__).q__)) > ((0));
						if (!local30) {
							local30 = ((((rhs__).tag__).q__)) > ((0));
						}
						if (local30) {
							if (((((lhs__).tag__).q__)) == ((0))) {
								if (TypeChecker__canConvertFreeConst__(s__, (lhs__).value__, ((rhs__).tag__).q__)) {
									Tag__ local31;
									memset(&local31, 0, sizeof(Tag__));
									local31.kind__ = TagKind__number__;
									local31.q__ = 1;
									(result__).tag__ = local31;
								} else {
									TypeChecker__badBinaryOperandConversion__(s__, RangeFinder__find__((e__)->lhs__), (rhs__).tag__);
								}
							} else {
								if (((((rhs__).tag__).q__)) == ((0))) {
									if (TypeChecker__canConvertFreeConst__(s__, (rhs__).value__, ((lhs__).tag__).q__)) {
										Tag__ local32;
										memset(&local32, 0, sizeof(Tag__));
										local32.kind__ = TagKind__number__;
										local32.q__ = 1;
										(result__).tag__ = local32;
									} else {
										TypeChecker__badBinaryOperandConversion__(s__, RangeFinder__find__((e__)->rhs__), (lhs__).tag__);
									}
								} else {
									if (((((lhs__).tag__).q__)) == ((((rhs__).tag__).q__))) {
										Tag__ local33;
										memset(&local33, 0, sizeof(Tag__));
										local33.kind__ = TagKind__number__;
										local33.q__ = 1;
										(result__).tag__ = local33;
									} else {
										TypeChecker__badBinaryOp__(s__, (e__)->op__, (lhs__).tag__, (rhs__).tag__);
									}
								}
							}
						} else {
							Tag__ local34;
							memset(&local34, 0, sizeof(Tag__));
							local34.kind__ = TagKind__number__;
							local34.q__ = 1;
							(result__).tag__ = local34;
						}
					}
					bool__ local36 = Tag__isValid__((result__).tag__);
					if (local36) {
						local36 = (((lhs__).value__).kind__) == (ValueKind__ulong___);
					}
					bool__ local35 = local36;
					if (local35) {
						local35 = (((rhs__).value__).kind__) == (ValueKind__ulong___);
					}
					if (local35) {
						if (string__equals__(op__, mu_____string40)) {
							Value__ local37;
							memset(&local37, 0, sizeof(Value__));
							local37.kind__ = ValueKind__ulong___;
							ulong__ local38;
							if (((((lhs__).value__).z__)) == ((((rhs__).value__).z__))) {
								local38 = 1uLL;
							} else {
								local38 = (ulong__)(0);
							}
							local37.z__ = local38;
							(result__).value__ = local37;
						} else {
							if (string__equals__(op__, mu_____string41)) {
								Value__ local39;
								memset(&local39, 0, sizeof(Value__));
								local39.kind__ = ValueKind__ulong___;
								ulong__ local40;
								if (((((lhs__).value__).z__)) != ((((rhs__).value__).z__))) {
									local40 = 1uLL;
								} else {
									local40 = (ulong__)(0);
								}
								local39.z__ = local40;
								(result__).value__ = local39;
							} else {
								if (string__equals__(op__, mu_____string42)) {
									Value__ local41;
									memset(&local41, 0, sizeof(Value__));
									local41.kind__ = ValueKind__ulong___;
									ulong__ local42;
									if (((((lhs__).value__).z__)) < ((((rhs__).value__).z__))) {
										local42 = 1uLL;
									} else {
										local42 = (ulong__)(0);
									}
									local41.z__ = local42;
									(result__).value__ = local41;
								} else {
									if (string__equals__(op__, mu_____string44)) {
										Value__ local43;
										memset(&local43, 0, sizeof(Value__));
										local43.kind__ = ValueKind__ulong___;
										ulong__ local44;
										if (((((lhs__).value__).z__)) <= ((((rhs__).value__).z__))) {
											local44 = 1uLL;
										} else {
											local44 = (ulong__)(0);
										}
										local43.z__ = local44;
										(result__).value__ = local43;
									} else {
										if (string__equals__(op__, mu_____string43)) {
											Value__ local45;
											memset(&local45, 0, sizeof(Value__));
											local45.kind__ = ValueKind__ulong___;
											ulong__ local46;
											if (((((lhs__).value__).z__)) > ((((rhs__).value__).z__))) {
												local46 = 1uLL;
											} else {
												local46 = (ulong__)(0);
											}
											local45.z__ = local46;
											(result__).value__ = local45;
										} else {
											if (string__equals__(op__, mu_____string45)) {
												Value__ local47;
												memset(&local47, 0, sizeof(Value__));
												local47.kind__ = ValueKind__ulong___;
												ulong__ local48;
												if (((((lhs__).value__).z__)) >= ((((rhs__).value__).z__))) {
													local48 = 1uLL;
												} else {
													local48 = (ulong__)(0);
												}
												local47.z__ = local48;
												(result__).value__ = local47;
											}
										}
									}
								}
							}
						}
					}
				} else {
					TypeChecker__badBinaryOp__(s__, (e__)->op__, (lhs__).tag__, (rhs__).tag__);
				}
			}
		} else {
			if (string__equals__(op__, mu_____string36)) {
				if (valid__) {
					bool__ local49 = (((lhs__).tag__).kind__) == (TagKind__number__);
					if (local49) {
						local49 = (((rhs__).tag__).kind__) == (TagKind__number__);
					}
					if (local49) {
						bool__ local50 = ((((lhs__).tag__).q__)) > ((64));
						if (!local50) {
							local50 = ((((rhs__).tag__).q__)) > ((64));
						}
						if (local50) {
							TypeChecker__unsupportedBinaryOp__(s__, (e__)->op__, (lhs__).tag__, (rhs__).tag__);
						} else {
							Tag__ local51;
							memset(&local51, 0, sizeof(Tag__));
							local51.kind__ = TagKind__number__;
							(result__).tag__ = local51;
						}
						bool__ local53 = Tag__isValid__((result__).tag__);
						if (local53) {
							local53 = (((lhs__).value__).kind__) == (ValueKind__ulong___);
						}
						bool__ local52 = local53;
						if (local52) {
							local52 = (((rhs__).value__).kind__) == (ValueKind__ulong___);
						}
						if (local52) {
							Value__ local54;
							memset(&local54, 0, sizeof(Value__));
							local54.kind__ = ValueKind__ulong___;
							local54.z__ = ((((lhs__).value__).z__)) * ((((rhs__).value__).z__));
							(result__).value__ = local54;
						}
					} else {
						TypeChecker__badBinaryOp__(s__, (e__)->op__, (lhs__).tag__, (rhs__).tag__);
					}
				}
			} else {
				bool__ local55 = string__equals__(op__, mu_____string37);
				if (!local55) {
					local55 = string__equals__(op__, mu_____string38);
				}
				if (local55) {
					if (valid__) {
						bool__ local56 = (((lhs__).tag__).kind__) == (TagKind__number__);
						if (local56) {
							local56 = (((rhs__).tag__).kind__) == (TagKind__number__);
						}
						if (local56) {
							bool__ local57 = ((((lhs__).tag__).q__)) > ((64));
							if (!local57) {
								local57 = ((((rhs__).tag__).q__)) > ((64));
							}
							if (local57) {
								TypeChecker__unsupportedBinaryOp__(s__, (e__)->op__, (lhs__).tag__, (rhs__).tag__);
							} else {
								(result__).tag__ = (lhs__).tag__;
							}
							bool__ local59 = Tag__isValid__((result__).tag__);
							if (local59) {
								local59 = (((lhs__).value__).kind__) == (ValueKind__ulong___);
							}
							bool__ local58 = local59;
							if (local58) {
								local58 = (((rhs__).value__).kind__) == (ValueKind__ulong___);
							}
							if (local58) {
								if (string__equals__(op__, mu_____string37)) {
									Value__ local60;
									memset(&local60, 0, sizeof(Value__));
									local60.kind__ = ValueKind__ulong___;
									local60.z__ = ((ulong__)((lhs__).value__).z__) << (((rhs__).value__).z__);
									(result__).value__ = local60;
								} else {
									if (string__equals__(op__, mu_____string38)) {
										Value__ local61;
										memset(&local61, 0, sizeof(Value__));
										local61.kind__ = ValueKind__ulong___;
										local61.z__ = ((ulong__)((lhs__).value__).z__) >> (((rhs__).value__).z__);
										(result__).value__ = local61;
									}
								}
								bool__ local62 = ((((result__).tag__).q__)) > ((0));
								if (local62) {
									local62 = ((((result__).tag__).q__)) < ((64));
								}
								if (local62) {
									((result__).value__).z__ = ((((result__).value__).z__)) & ((((((ulong__)1uLL) << (((result__).tag__).q__))) - ((ulong__)(1))));
								}
							}
						} else {
							TypeChecker__badBinaryOp__(s__, (e__)->op__, (lhs__).tag__, (rhs__).tag__);
						}
					}
				} else {
					StringBuilder__ local63;
					memset(&local63, 0, sizeof(local63));
					string__ local64 = { (pointer__)"Invalid binary operator: ", 25 };
					StringBuilder__write__(&local63, local64);
					StringBuilder__write__(&local63, op__);
					List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((e__)->op__)->span__, StringBuilder__compactToString__(&local63)));
				}
			}
		}
	}
	return result__;
}
Tag__ TypeChecker__typename__(TypeCheckerState__* s__, Node__ node__, Token__* name__) {
	Tag__ tag__ = TypeChecker__tag__(s__, (name__)->value__);
	if (Tag__isValid__(tag__)) {
		Map__add__Node__Tag____((s__)->typeMap__, node__, tag__);
	} else {
		StringBuilder__ local0;
		memset(&local0, 0, sizeof(local0));
		string__ local1 = { (pointer__)"Undefined type: ", 16 };
		StringBuilder__write__(&local0, local1);
		StringBuilder__write__(&local0, (name__)->value__);
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (name__)->span__, StringBuilder__compactToString__(&local0)));
	}
	return tag__;
}
bool__ TypeChecker__canAssign__(TypeCheckerState__* s__, Tag__ from__, Value__ fromValue__, Tag__ to__) {
	if (((to__).kind__) != (TagKind__unknown__)) {
		if (((from__).kind__) == (TagKind__number__)) {
			bool__ local0 = ((to__).kind__) == (TagKind__number__);
			if (local0) {
				bool__ local1 = (((to__).q__)) == (((from__).q__));
				if (!local1) {
					bool__ local2 = (((from__).q__)) == ((0));
					if (local2) {
						local2 = TypeChecker__canConvertFreeConst__(s__, fromValue__, (to__).q__);
					}
					local1 = local2;
				}
				local0 = local1;
			}
			return local0;
		} else {
			bool__ local3 = ((from__).kind__) == (TagKind__moduleOut__);
			if (!local3) {
				local3 = ((from__).kind__) == (TagKind__struct___);
			}
			if (local3) {
				bool__ local4 = ((to__).kind__) == ((from__).kind__);
				if (local4) {
					local4 = (((to__).q__)) == (((from__).q__));
				}
				return local4;
			}
		}
	}
	return true__;
}
TypeCheckResult__ TypeChecker__fixedNumberArg__(TypeCheckerState__* s__, CallExpression__* e__, int__ index__) {
	if (((index__)) >= ((((e__)->args__)->count__))) {
		TypeCheckResult__ local0;
		memset(&local0, 0, sizeof(TypeCheckResult__));
		return local0;
	}
	List__Ptr__CallArg______* local1 = (e__)->args__;
	uint__ local2 = (uint__)(index__);
	mu_____boundscheck(local2 < (uint__)local1->count__);
	CallArg__* arg__ = ((CallArg__**)local1->dataPtr__)[local2];
	if ((((arg__)->expr__).dataPtr__) == ((pointer__)(null__))) {
		TypeCheckResult__ local3;
		memset(&local3, 0, sizeof(TypeCheckResult__));
		return local3;
	}
	TypeCheckResult__ tr__ = TypeChecker__expression__(s__, (arg__)->expr__);
	if (Tag__isValid__((tr__).tag__)) {
		bool__ local4 = (((tr__).tag__).kind__) == (TagKind__number__);
		if (local4) {
			local4 = ((((tr__).tag__).q__)) > ((0));
		}
		if (local4) {
		} else {
			TypeChecker__expectedFixedNumberExpression__(s__, (arg__)->expr__);
			TypeCheckResult__ local5;
			memset(&local5, 0, sizeof(TypeCheckResult__));
			return local5;
		}
	}
	return tr__;
}
TypeCheckResult__ TypeChecker__slice__(TypeCheckerState__* s__, CallExpression__* e__) {
	if (((s__)->module__) == (null__)) {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->target__), mu_____string174));
	}
	if ((s__)->isStaticExpr__) {
	} else {
		if ((((((s__)->comp__)->flags__)) & ((CompilationFlags__simulate__))) == (0)) {
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->target__), mu_____string140));
		}
	}
	TypeChecker__builtinArgs__(s__, e__, 3);
	TypeChecker__fixedNumberArg__(s__, e__, 0);
	TypeChecker__numberArg__(s__, e__, 1);
	TypeCheckResult__ widthArg__ = TypeChecker__constantArg__(s__, e__, 2);
	TypeCheckResult__ local0;
	memset(&local0, 0, sizeof(TypeCheckResult__));
	TypeCheckResult__ result__ = local0;
	if (Tag__isValid__((widthArg__).tag__)) {
		Maybe__int____ width__ = TypeChecker__tryUnpackInt__((widthArg__).value__);
		if ((s__)->isStaticExpr__) {
			bool__ local1 = (width__).hasValue__;
			if (local1) {
				local1 = ((0)) < (((width__).value__));
			}
			if (local1) {
				Tag__ local2;
				memset(&local2, 0, sizeof(Tag__));
				local2.kind__ = TagKind__number__;
				local2.q__ = (width__).value__;
				(result__).tag__ = local2;
			} else {
				List__Ptr__CallArg______* local3 = (e__)->args__;
				uint__ local4 = (uint__)(2);
				mu_____boundscheck(local4 < (uint__)local3->count__);
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((((CallArg__**)local3->dataPtr__)[local4])->expr__), mu_____string173));
			}
		} else {
			bool__ local6 = (width__).hasValue__;
			if (local6) {
				local6 = ((1)) <= (((width__).value__));
			}
			bool__ local5 = local6;
			if (local5) {
				local5 = (((width__).value__)) <= ((64));
			}
			if (local5) {
				Tag__ local7;
				memset(&local7, 0, sizeof(Tag__));
				local7.kind__ = TagKind__number__;
				local7.q__ = (width__).value__;
				(result__).tag__ = local7;
			} else {
				List__Ptr__CallArg______* local8 = (e__)->args__;
				uint__ local9 = (uint__)(2);
				mu_____boundscheck(local9 < (uint__)local8->count__);
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((((CallArg__**)local8->dataPtr__)[local9])->expr__), mu_____string145));
			}
		}
	}
	return result__;
}
void__ TypeChecker__unsupportedRegUpdate__(TypeCheckerState__* s__, Node__ e__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), mu_____string139));
}
void__ TypeChecker__const__(TypeCheckerState__* s__, ConstDef__* def__) {
	if (((((def__)->flags__)) & ((ConstFlags__typeCheckDone__))) != (0)) {
		return;
	}
	if (!(TypeChecker__isValidEntityName__(((def__)->name__)->value__))) {
		Node__ local0;
		local0.dataPtr__ = (pointer__)((def__)->name__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		TypeChecker__invalidNamePrefix__(s__, local0);
	}
	(def__)->flags__ = (((def__)->flags__)) | ((ConstFlags__typeCheckStarted__));
	Tag__ local1;
	memset(&local1, 0, sizeof(Tag__));
	Tag__ dt__ = local1;
	if (((def__)->type__) != (null__)) {
		Node__ local2;
		local2.dataPtr__ = (pointer__)(def__);
		local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__ConstDef____ : 0;
		dt__ = TypeChecker__typename__(s__, local2, (def__)->type__);
	}
	if ((((def__)->expr__).dataPtr__) != ((pointer__)(null__))) {
		(s__)->isStaticExpr__ = true__;
		TypeCheckResult__ etr__ = TypeChecker__expressionWithGap__(s__, (def__)->expr__, ((def__)->type__) != (null__), dt__);
		(s__)->isStaticExpr__ = false__;
		if ((((etr__).tag__).kind__) != (TagKind__unknown__)) {
			if (((def__)->type__) != (null__)) {
				if (TypeChecker__canAssign__(s__, (etr__).tag__, (etr__).value__, dt__)) {
					if ((((etr__).value__).kind__) != (ValueKind__none__)) {
					} else {
						TypeChecker__expectedConstant__(s__, (def__)->expr__);
					}
				} else {
					TypeChecker__badAssign__(s__, (def__)->assign__, (etr__).tag__, dt__);
				}
			} else {
				Node__ local3;
				local3.dataPtr__ = (pointer__)(def__);
				local3.id__ = local3.dataPtr__ != null__ ? Node_____Ptr__ConstDef____ : 0;
				Map__add__Node__Tag____((s__)->typeMap__, local3, (etr__).tag__);
				if ((((etr__).value__).kind__) != (ValueKind__none__)) {
				} else {
					TypeChecker__expectedConstant__(s__, (def__)->expr__);
				}
			}
		}
	}
	(def__)->flags__ = (((def__)->flags__)) | ((ConstFlags__typeCheckDone__));
}
TypeCheckResult__ TypeChecker__expressionInner__(TypeCheckerState__* s__, Node__ e__) {
	switch ((e__).id__) {
		case Node_____Ptr__Token____: {
			Token__* local0 = (Token__*)(e__.dataPtr__);
			return TypeChecker__token__(s__, local0);
		}
		case Node_____Ptr__NumberExpression____: {
			NumberExpression__* local1 = (NumberExpression__*)(e__.dataPtr__);
			return TypeChecker__number__(s__, local1);
		}
		case Node_____Ptr__UnaryOperatorExpression____: {
			UnaryOperatorExpression__* local2 = (UnaryOperatorExpression__*)(e__.dataPtr__);
			return TypeChecker__unaryOperator__(s__, local2);
		}
		case Node_____Ptr__BinaryOperatorExpression____: {
			BinaryOperatorExpression__* local3 = (BinaryOperatorExpression__*)(e__.dataPtr__);
			return TypeChecker__binaryOperator__(s__, local3);
		}
		case Node_____Ptr__DotExpression____: {
			DotExpression__* local4 = (DotExpression__*)(e__.dataPtr__);
			return TypeChecker__dot__(s__, local4);
		}
		case Node_____Ptr__TernaryOperatorExpression____: {
			TernaryOperatorExpression__* local5 = (TernaryOperatorExpression__*)(e__.dataPtr__);
			return TypeChecker__ternaryOperator__(s__, local5);
		}
		case Node_____Ptr__MatchExpression____: {
			MatchExpression__* local6 = (MatchExpression__*)(e__.dataPtr__);
			return TypeChecker__match___(s__, local6);
		}
		case Node_____Ptr__ParenExpression____: {
			ParenExpression__* local7 = (ParenExpression__*)(e__.dataPtr__);
			return TypeChecker__paren__(s__, local7);
		}
		case Node_____Ptr__IndexExpression____: {
			IndexExpression__* local8 = (IndexExpression__*)(e__.dataPtr__);
			return TypeChecker__index__(s__, local8);
		}
		case Node_____Ptr__BraceExpression____: {
			BraceExpression__* local9 = (BraceExpression__*)(e__.dataPtr__);
			return TypeChecker__brace__(s__, local9);
		}
		case Node_____Ptr__CallExpression____: {
			CallExpression__* local10 = (CallExpression__*)(e__.dataPtr__);
			return TypeChecker__call__(s__, local10);
		}
		case Node_____Ptr__StructInitializerExpression____: {
			StructInitializerExpression__* local11 = (StructInitializerExpression__*)(e__.dataPtr__);
			return TypeChecker__structInit__(s__, local11);
		}
		case Node_____Ptr__ArrayExpression____: {
			ArrayExpression__* local12 = (ArrayExpression__*)(e__.dataPtr__);
			return TypeChecker__array__(s__, local12);
		}
		case 0:
		default: {
			mu_____nomatch();
			TypeCheckResult__ local13;
			memset(&local13, 0, sizeof(TypeCheckResult__));
			return local13;
		}
	}
}
string__ TypeChecker__tagString__(Compilation__* comp__, Tag__ tag__) {
	if (((tag__).kind__) == (TagKind__number__)) {
		if ((((tag__).q__)) != ((0))) {
			StringBuilder__ local0;
			memset(&local0, 0, sizeof(local0));
			string__ local1 = { (pointer__)"$", 1 };
			StringBuilder__write__(&local0, local1);
			int__writeTo__((tag__).q__, &local0);
			return StringBuilder__compactToString__(&local0);
		} else {
			StringBuilder__ local2;
			memset(&local2, 0, sizeof(local2));
			string__ local3 = { (pointer__)"$*", 2 };
			StringBuilder__write__(&local2, local3);
			return StringBuilder__compactToString__(&local2);
		}
	} else {
		if (((tag__).kind__) == (TagKind__moduleOut__)) {
			StringBuilder__ local4;
			memset(&local4, 0, sizeof(local4));
			string__ local5 = { (pointer__)"[", 1 };
			StringBuilder__write__(&local4, local5);
			List__Node____* local7 = (comp__)->entities__;
			uint__ local8 = (uint__)((tag__).q__);
			mu_____boundscheck(local8 < (uint__)local7->count__);
			Node__ local6 = ((Node__*)local7->dataPtr__)[local8];
			mu_____checkedcast(local6.id__ == Node_____Ptr__ModuleDef____);
			StringBuilder__write__(&local4, (((ModuleDef__*)(local6.dataPtr__))->name__)->value__);
			string__ local9 = { (pointer__)"]", 1 };
			StringBuilder__write__(&local4, local9);
			return StringBuilder__compactToString__(&local4);
		} else {
			if (((tag__).kind__) == (TagKind__struct___)) {
				StringBuilder__ local10;
				memset(&local10, 0, sizeof(local10));
				string__ local11 = { (pointer__)"[", 1 };
				StringBuilder__write__(&local10, local11);
				List__Node____* local13 = (comp__)->entities__;
				uint__ local14 = (uint__)((tag__).q__);
				mu_____boundscheck(local14 < (uint__)local13->count__);
				Node__ local12 = ((Node__*)local13->dataPtr__)[local14];
				mu_____checkedcast(local12.id__ == Node_____Ptr__StructDef____);
				StringBuilder__write__(&local10, (((StructDef__*)(local12.dataPtr__))->name__)->value__);
				string__ local15 = { (pointer__)"]", 1 };
				StringBuilder__write__(&local10, local15);
				return StringBuilder__compactToString__(&local10);
			}
		}
	}
	return mu_____string118;
}
void__ TypeChecker__badBinaryOperandConversion__(TypeCheckerState__* s__, IntRange__ span__, Tag__ tag__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Cannot convert operand to type ", 31 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, tag__));
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, span__, StringBuilder__compactToString__(&local0)));
}
TypeCheckResult__ TypeChecker__assignSlice__(TypeCheckerState__* s__, AssignStatement__* st__, CallExpression__* e__) {
	if ((((((s__)->comp__)->flags__)) & ((CompilationFlags__simulate__))) == (0)) {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->target__), mu_____string140));
	}
	TypeChecker__builtinArgs__(s__, e__, 3);
	if (((((e__)->args__)->count__)) >= ((1))) {
		List__Ptr__CallArg______* local0 = (e__)->args__;
		uint__ local1 = (uint__)(0);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		Node__ regArg__ = (((CallArg__**)local0->dataPtr__)[local1])->expr__;
		if ((regArg__).id__ == Node_____Ptr__Token____) {
			Node__ local2 = regArg__;
			mu_____checkedcast(local2.id__ == Node_____Ptr__Token____);
			Token__* nameToken__ = (Token__*)(local2.dataPtr__);
			string__ name__ = (nameToken__)->value__;
			Node__ sym__ = Map__getOrDefault__string__Node____(((s__)->module__)->symbols__, (nameToken__)->value__);
			if (((sym__).dataPtr__) != ((pointer__)(null__))) {
				bool__ local3 = (sym__).id__ == Node_____Ptr__AssignStatement____;
				if (local3) {
					Node__ local4 = sym__;
					mu_____checkedcast(local4.id__ == Node_____Ptr__AssignStatement____);
					local3 = (((((AssignStatement__*)(local4.dataPtr__))->flags__)) & ((AssignFlags__reg__))) != (0);
				}
				if (local3) {
					Node__ local5 = sym__;
					mu_____checkedcast(local5.id__ == Node_____Ptr__AssignStatement____);
					AssignStatement__* reg__ = (AssignStatement__*)(local5.dataPtr__);
					(st__)->localId__ = (reg__)->localId__;
					Node__ local6;
					local6.dataPtr__ = (pointer__)(nameToken__);
					local6.id__ = local6.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
					TypeChecker__ensureAssignDone__(s__, reg__, local6);
					Node__ local7;
					local7.dataPtr__ = (pointer__)(reg__);
					local7.id__ = local7.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
					Tag__ regTag__ = Map__getOrDefault__Node__Tag____((s__)->typeMap__, local7);
					bool__ local8 = ((regTag__).kind__) == (TagKind__number__);
					if (local8) {
						local8 = (((regTag__).q__)) > ((0));
					}
					if (local8) {
					} else {
						TypeChecker__expectedFixedNumberExpression__(s__, regArg__);
					}
				} else {
					List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (nameToken__)->span__, mu_____string130));
				}
			} else {
				TypeChecker__badSymbol__(s__, nameToken__);
			}
		} else {
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(regArg__), mu_____string130));
		}
	}
	TypeChecker__numberArg__(s__, e__, 1);
	TypeCheckResult__ widthArg__ = TypeChecker__constantArg__(s__, e__, 2);
	Tag__ local9;
	memset(&local9, 0, sizeof(Tag__));
	Tag__ tag__ = local9;
	if (Tag__isValid__((widthArg__).tag__)) {
		Maybe__int____ width__ = TypeChecker__tryUnpackInt__((widthArg__).value__);
		bool__ local11 = (width__).hasValue__;
		if (local11) {
			local11 = ((1)) <= (((width__).value__));
		}
		bool__ local10 = local11;
		if (local10) {
			local10 = (((width__).value__)) <= ((64));
		}
		if (local10) {
			Tag__ local12;
			memset(&local12, 0, sizeof(Tag__));
			local12.kind__ = TagKind__number__;
			local12.q__ = (width__).value__;
			tag__ = local12;
		} else {
			List__Ptr__CallArg______* local13 = (e__)->args__;
			uint__ local14 = (uint__)(2);
			mu_____boundscheck(local14 < (uint__)local13->count__);
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((((CallArg__**)local13->dataPtr__)[local14])->expr__), mu_____string145));
			TypeCheckResult__ local15;
			memset(&local15, 0, sizeof(TypeCheckResult__));
			return local15;
		}
	}
	if ((((st__)->expr__).dataPtr__) != ((pointer__)(null__))) {
		TypeCheckResult__ rhs__ = TypeChecker__expressionWithGap__(s__, (st__)->expr__, true__, tag__);
		if (TypeChecker__canAssign__(s__, (rhs__).tag__, (rhs__).value__, tag__)) {
		} else {
			TypeChecker__badAssign__(s__, (st__)->op__, (rhs__).tag__, tag__);
		}
	}
}
void__ TypeChecker__unsupportedBinaryOp__(TypeCheckerState__* s__, Token__* op__, Tag__ lhs__, Tag__ rhs__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Unsupported expression: cannot apply operator ", 46 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, (op__)->value__);
	string__ local2 = { (pointer__)" to arguments of type ", 22 };
	StringBuilder__write__(&local0, local2);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, lhs__));
	string__ local3 = { (pointer__)" and ", 5 };
	StringBuilder__write__(&local0, local3);
	StringBuilder__write__(&local0, TypeChecker__tagString__((s__)->comp__, rhs__));
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (op__)->span__, StringBuilder__compactToString__(&local0)));
}
TypeCheckResult__ TypeChecker__paren__(TypeCheckerState__* s__, ParenExpression__* e__) {
	TypeCheckResult__ local0;
	if ((((e__)->expr__).dataPtr__) != ((pointer__)(null__))) {
		local0 = TypeChecker__expression__(s__, (e__)->expr__);
	} else {
		TypeCheckResult__ local1;
		memset(&local1, 0, sizeof(TypeCheckResult__));
		local0 = local1;
	}
	return local0;
}
void__ TypeChecker__expectedStaticConstant__(TypeCheckerState__* s__, Node__ e__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), mu_____string107));
}
void__ TypeChecker__clock__(TypeCheckerState__* s__, ClockStatement__* st__) {
	if ((((s__)->module__)->blackboxKeyword__) != (null__)) {
		Node__ local0;
		local0.dataPtr__ = (pointer__)((st__)->keyword__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		TypeChecker__statementNotAllowedInsideBlackbox__(s__, local0);
	}
	if (((st__)->name__) != (null__)) {
		string__ name__ = ((st__)->name__)->value__;
		if (!(Map__containsKey__string__Node____(((s__)->module__)->symbols__, name__))) {
			TypeChecker__badSymbol__(s__, (st__)->name__);
		}
	}
	if ((s__)->inClock__) {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((st__)->keyword__)->span__, mu_____string135));
	}
	(s__)->inClock__ = true__;
	TypeChecker__block__(s__, (st__)->body__);
	(s__)->inClock__ = false__;
}
TypeCheckResult__ TypeChecker__numberArg__(TypeCheckerState__* s__, CallExpression__* e__, int__ index__) {
	if (((index__)) >= ((((e__)->args__)->count__))) {
		TypeCheckResult__ local0;
		memset(&local0, 0, sizeof(TypeCheckResult__));
		return local0;
	}
	List__Ptr__CallArg______* local1 = (e__)->args__;
	uint__ local2 = (uint__)(index__);
	mu_____boundscheck(local2 < (uint__)local1->count__);
	CallArg__* arg__ = ((CallArg__**)local1->dataPtr__)[local2];
	if ((((arg__)->expr__).dataPtr__) == ((pointer__)(null__))) {
		TypeCheckResult__ local3;
		memset(&local3, 0, sizeof(TypeCheckResult__));
		return local3;
	}
	TypeCheckResult__ tr__ = TypeChecker__expression__(s__, (arg__)->expr__);
	if (Tag__isValid__((tr__).tag__)) {
		if ((((tr__).tag__).kind__) == (TagKind__number__)) {
		} else {
			TypeChecker__expectedNumberExpression__(s__, (arg__)->expr__);
			TypeCheckResult__ local4;
			memset(&local4, 0, sizeof(TypeCheckResult__));
			return local4;
		}
	}
	return tr__;
}
bool__ TypeChecker__isValidEntityName_nonStatic__(string__ s__) {
	string__* local1 = &(s__);
	uint__ local2 = (uint__)(0);
	mu_____boundscheck(local2 < (uint__)local1->length__);
	bool__ local0 = (((char__*)local1->dataPtr__)[local2]) != ('$');
	if (local0) {
		string__* local3 = &(s__);
		uint__ local4 = (uint__)(0);
		mu_____boundscheck(local4 < (uint__)local3->length__);
		local0 = (((char__*)local3->dataPtr__)[local4]) != ('#');
	}
	return local0;
}
TypeCheckResult__ TypeChecker__rep__(TypeCheckerState__* s__, CallExpression__* e__) {
	TypeChecker__builtinArgs__(s__, e__, 2);
	TypeCheckResult__ target__ = TypeChecker__fixedNumberArg__(s__, e__, 0);
	TypeCheckResult__ nArg__ = TypeChecker__constantArg__(s__, e__, 1);
	TypeCheckResult__ local0;
	memset(&local0, 0, sizeof(TypeCheckResult__));
	TypeCheckResult__ result__ = local0;
	if (Tag__isValid__((nArg__).tag__)) {
		Maybe__int____ n__ = TypeChecker__tryUnpackInt__((nArg__).value__);
		bool__ local1 = (n__).hasValue__;
		if (local1) {
			local1 = ((0)) < (((n__).value__));
		}
		if (local1) {
			if (Tag__isValid__((target__).tag__)) {
				int__ w__ = ((((target__).tag__).q__)) * (((n__).value__));
				if (((w__)) <= ((64))) {
					Tag__ local2;
					memset(&local2, 0, sizeof(Tag__));
					local2.kind__ = TagKind__number__;
					local2.q__ = w__;
					(result__).tag__ = local2;
					if ((((target__).value__).kind__) == (ValueKind__ulong___)) {
						Value__ local3;
						memset(&local3, 0, sizeof(Value__));
						local3.kind__ = ValueKind__ulong___;
						local3.z__ = (ulong__)(0);
						(result__).value__ = local3;
						{
							int__ i__ = 0;
							while (((i__)) < (((n__).value__))) {
								((result__).value__).z__ = ((ulong__)((result__).value__).z__) << (((target__).tag__).q__);
								((result__).value__).z__ = ((((result__).value__).z__)) | ((((target__).value__).z__));
								i__ += 1;
							}
						}
					}
				} else {
					Node__ local4;
					local4.dataPtr__ = (pointer__)(e__);
					local4.id__ = local4.dataPtr__ != null__ ? Node_____Ptr__CallExpression____ : 0;
					List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(local4), mu_____string172));
				}
			}
		} else {
			List__Ptr__CallArg______* local5 = (e__)->args__;
			uint__ local6 = (uint__)(1);
			mu_____boundscheck(local6 < (uint__)local5->count__);
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((((CallArg__**)local5->dataPtr__)[local6])->expr__), mu_____string173));
		}
	}
	return result__;
}
TypeCheckResult__ TypeChecker__swizzle__(TypeCheckerState__* s__, CallExpression__* e__) {
	if (((s__)->module__) == (null__)) {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->target__), mu_____string179));
	}
	if (!((s__)->isStaticExpr__)) {
		List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->target__), mu_____string180));
	}
	TypeChecker__builtinArgs__(s__, e__, 4);
	TypeCheckResult__ arrayArg__ = TypeChecker__fixedNumberArg__(s__, e__, 0);
	TypeCheckResult__ seqSizeArg__ = TypeChecker__constantArg__(s__, e__, 1);
	TypeCheckResult__ stepArg__ = TypeChecker__constantArg__(s__, e__, 2);
	TypeCheckResult__ blockSizeArg__ = TypeChecker__constantArg__(s__, e__, 3);
	bool__ local2 = Tag__isValid__((arrayArg__).tag__);
	if (local2) {
		local2 = Tag__isValid__((seqSizeArg__).tag__);
	}
	bool__ local1 = local2;
	if (local1) {
		local1 = Tag__isValid__((stepArg__).tag__);
	}
	bool__ local0 = local1;
	if (local0) {
		local0 = Tag__isValid__((blockSizeArg__).tag__);
	}
	if (local0) {
		int__ numBits__ = TypeChecker__unpackWidth__((arrayArg__).tag__);
		Maybe__int____ seqSize__ = TypeChecker__tryUnpackInt__((seqSizeArg__).value__);
		Maybe__int____ step__ = TypeChecker__tryUnpackInt__((stepArg__).value__);
		Maybe__int____ blockSize__ = TypeChecker__tryUnpackInt__((blockSizeArg__).value__);
		if (((((numBits__)) % ((8)))) == ((0))) {
			bool__ local4 = (blockSize__).hasValue__;
			if (local4) {
				local4 = (((blockSize__).value__)) > ((0));
			}
			bool__ local3 = local4;
			if (local3) {
				local3 = ((((numBits__)) % (((blockSize__).value__)))) == ((0));
			}
			if (local3) {
				bool__ local6 = (step__).hasValue__;
				if (local6) {
					local6 = (((step__).value__)) > ((0));
				}
				bool__ local5 = local6;
				if (local5) {
					local5 = (((((blockSize__).value__)) % (((step__).value__)))) == ((0));
				}
				if (local5) {
					bool__ local8 = (seqSize__).hasValue__;
					if (local8) {
						local8 = (((seqSize__).value__)) > ((0));
					}
					bool__ local7 = local8;
					if (local7) {
						local7 = (((((step__).value__)) % (((seqSize__).value__)))) == ((0));
					}
					if (local7) {
						TypeCheckResult__ local9;
						memset(&local9, 0, sizeof(TypeCheckResult__));
						local9.tag__ = (arrayArg__).tag__;
						return local9;
					} else {
						List__Ptr__CallArg______* local10 = (e__)->args__;
						uint__ local11 = (uint__)(1);
						mu_____boundscheck(local11 < (uint__)local10->count__);
						List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((((CallArg__**)local10->dataPtr__)[local11])->expr__), mu_____string181));
					}
				} else {
					List__Ptr__CallArg______* local12 = (e__)->args__;
					uint__ local13 = (uint__)(2);
					mu_____boundscheck(local13 < (uint__)local12->count__);
					List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((((CallArg__**)local12->dataPtr__)[local13])->expr__), mu_____string182));
				}
			} else {
				List__Ptr__CallArg______* local14 = (e__)->args__;
				uint__ local15 = (uint__)(3);
				mu_____boundscheck(local15 < (uint__)local14->count__);
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((((CallArg__**)local14->dataPtr__)[local15])->expr__), mu_____string183));
			}
		} else {
			List__Ptr__CallArg______* local16 = (e__)->args__;
			uint__ local17 = (uint__)(0);
			mu_____boundscheck(local17 < (uint__)local16->count__);
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((((CallArg__**)local16->dataPtr__)[local17])->expr__), mu_____string184));
		}
	}
	TypeCheckResult__ local18;
	memset(&local18, 0, sizeof(TypeCheckResult__));
	return local18;
}
void__ TypeChecker__block__(TypeCheckerState__* s__, Block__* st__) {
	{
		List__Node____* local0 = (st__)->contents__;
		int__ local1 = 0;
		while (local1 < local0->count__) {
			Node__ n__ = ((Node__*)(local0->dataPtr__))[local1];
			switch ((n__).id__) {
				case Node_____Ptr__FieldDef____: {
					FieldDef__* local2 = (FieldDef__*)(n__.dataPtr__);
					TypeChecker__fieldDef__(s__, local2);
					break;
				}
				case Node_____Ptr__ClockStatement____: {
					ClockStatement__* local3 = (ClockStatement__*)(n__.dataPtr__);
					TypeChecker__clock__(s__, local3);
					break;
				}
				case Node_____Ptr__IfStatement____: {
					IfStatement__* local4 = (IfStatement__*)(n__.dataPtr__);
					TypeChecker__if___(s__, local4);
					break;
				}
				case Node_____Ptr__AssignStatement____: {
					AssignStatement__* local5 = (AssignStatement__*)(n__.dataPtr__);
					TypeChecker__assign__(s__, local5);
					break;
				}
				default: {
					{
					}
					break;
				}
				case 0: {
					mu_____nomatch();
				}
			}
			local1 += 1;
		}
	}
}
int__ TypeChecker__numSlots__(Compilation__* comp__, Tag__ tag__) {
	if (((tag__).kind__) == (TagKind__number__)) {
		return 1;
	} else {
		if (((tag__).kind__) == (TagKind__struct___)) {
			List__Node____* local1 = (comp__)->entities__;
			uint__ local2 = (uint__)((tag__).q__);
			mu_____boundscheck(local2 < (uint__)local1->count__);
			Node__ local0 = ((Node__*)local1->dataPtr__)[local2];
			mu_____checkedcast(local0.id__ == Node_____Ptr__StructDef____);
			return (((StructDef__*)(local0.dataPtr__))->fields__)->count__;
		}
	}
	mu_____abandon(-1);
	return 0;
}
TypeCheckResult__ TypeChecker__constantArg__(TypeCheckerState__* s__, CallExpression__* e__, int__ index__) {
	if (((index__)) >= ((((e__)->args__)->count__))) {
		TypeCheckResult__ local0;
		memset(&local0, 0, sizeof(TypeCheckResult__));
		return local0;
	}
	List__Ptr__CallArg______* local1 = (e__)->args__;
	uint__ local2 = (uint__)(index__);
	mu_____boundscheck(local2 < (uint__)local1->count__);
	CallArg__* arg__ = ((CallArg__**)local1->dataPtr__)[local2];
	if ((((arg__)->expr__).dataPtr__) == ((pointer__)(null__))) {
		TypeCheckResult__ local3;
		memset(&local3, 0, sizeof(TypeCheckResult__));
		return local3;
	}
	TypeCheckResult__ tr__ = TypeChecker__expression__(s__, (arg__)->expr__);
	if (Tag__isValid__((tr__).tag__)) {
		bool__ local4 = (((tr__).tag__).kind__) == (TagKind__number__);
		if (local4) {
			local4 = (((tr__).value__).kind__) == (ValueKind__ulong___);
		}
		if (local4) {
		} else {
			TypeChecker__expectedConstant__(s__, (arg__)->expr__);
			TypeCheckResult__ local5;
			memset(&local5, 0, sizeof(TypeCheckResult__));
			return local5;
		}
	}
	return tr__;
}
Maybe__int____ TypeChecker__tryUnpackInt__(Value__ value__) {
	mu_____assert(((value__).kind__) == (ValueKind__ulong___));
	if ((((value__).z__)) <= (((ulong__)(int__maxValue__)))) {
		return Maybe__from__int____((int__)((value__).z__));
	}
	Maybe__int____ local0;
	memset(&local0, 0, sizeof(Maybe__int____));
	return local0;
}
void__ TypeChecker__comp__(Compilation__* comp__) {
	Map__Node__Tag____* local0 = (Map__Node__Tag____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Map__Node__Tag____));
	*local0 = Map__create__Node__Tag____();
	(comp__)->typeMap__ = local0;
	Map__Node__Value____* local1 = (Map__Node__Value____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Map__Node__Value____));
	*local1 = Map__create__Node__Value____();
	(comp__)->constMap__ = local1;
	TypeCheckerState__* local2 = (TypeCheckerState__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(TypeCheckerState__));
	TypeCheckerState__ local3;
	memset(&local3, 0, sizeof(TypeCheckerState__));
	local3.comp__ = comp__;
	local3.errors__ = (comp__)->errors__;
	local3.symbols__ = (comp__)->symbols__;
	local3.typeMap__ = (comp__)->typeMap__;
	local3.constMap__ = (comp__)->constMap__;
	List__QueuedCallArgs____* local4 = (List__QueuedCallArgs____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__QueuedCallArgs____));
	List__QueuedCallArgs____ local5;
	memset(&local5, 0, sizeof(List__QueuedCallArgs____));
	*local4 = local5;
	local3.queue__ = local4;
	*local2 = local3;
	TypeCheckerState__* s__ = local2;
	{
		List__Ptr__CodeUnit______* local6 = (comp__)->units__;
		int__ local7 = 0;
		while (local7 < local6->count__) {
			CodeUnit__* u__ = ((CodeUnit__**)(local6->dataPtr__))[local7];
			TypeChecker__unit__(s__, u__);
			local7 += 1;
		}
	}
	int__ index__ = 0;
	while (true__) {
		if (!(((index__)) < ((((s__)->queue__)->count__)))) { break; }
		List__QueuedCallArgs____* local8 = (s__)->queue__;
		uint__ local9 = (uint__)(index__);
		mu_____boundscheck(local9 < (uint__)local8->count__);
		QueuedCallArgs__ item__ = ((QueuedCallArgs__*)local8->dataPtr__)[local9];
		(s__)->unit__ = ((item__).context__)->unit__;
		(s__)->module__ = (item__).context__;
		TypeChecker__callArgs__(s__, (item__).e__, (item__).def__);
		index__ = ((index__)) + ((1));
	}
}
void__ TypeChecker__ensureConstDone__(TypeCheckerState__* s__, ConstDef__* def__, Node__ reference__) {
	if (((((def__)->flags__)) & ((ConstFlags__typeCheckDone__))) != (0)) {
	} else {
		if (((((def__)->flags__)) & ((ConstFlags__typeCheckStarted__))) == (0)) {
			TypeCheckerContext__ prev__ = TypeChecker__pushContext__(s__, (def__)->unit__, null__);
			TypeChecker__const__(s__, def__);
			TypeChecker__restoreContext__(s__, prev__);
		} else {
			StringBuilder__ local0;
			memset(&local0, 0, sizeof(local0));
			string__ local1 = { (pointer__)"Recursive reference to const: ", 30 };
			StringBuilder__write__(&local0, local1);
			StringBuilder__write__(&local0, ((def__)->name__)->value__);
			List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(reference__), StringBuilder__compactToString__(&local0)));
		}
	}
}
TypeCheckResult__ TypeChecker__expression__(TypeCheckerState__* s__, Node__ e__) {
	bool__ prevGap__ = (s__)->gap__;
	(s__)->gap__ = false__;
	TypeCheckResult__ tr__ = TypeChecker__expressionContinueGap__(s__, e__);
	(s__)->gap__ = prevGap__;
	return tr__;
}
void__ TypeChecker__struct___(TypeCheckerState__* s__, StructDef__* def__) {
	if (((((def__)->flags__)) & ((StructFlags__typeCheckDone__))) != (0)) {
		return;
	}
	if (!(TypeChecker__isValidEntityName_nonStatic__(((def__)->name__)->value__))) {
		Node__ local0;
		local0.dataPtr__ = (pointer__)((def__)->name__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		TypeChecker__invalidNamePrefix_nonStatic__(s__, local0);
	}
	if (((((def__)->fields__)->count__)) == ((0))) {
		int__ local1;
		if ((((def__)->body__)->openBrace__) != (null__)) {
			local1 = ((((def__)->body__)->openBrace__)->span__).to__;
		} else {
			local1 = (((def__)->name__)->span__).to__;
		}
		List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, local1, mu_____string132));
	}
	Map__string__Ptr__FieldDef______* local2 = (Map__string__Ptr__FieldDef______*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Map__string__Ptr__FieldDef______));
	*local2 = Map__create__string__Ptr__FieldDef______();
	(def__)->symbols__ = local2;
	(s__)->struct___ = def__;
	TypeChecker__block__(s__, (def__)->body__);
	(s__)->struct___ = null__;
	(def__)->flags__ = (((def__)->flags__)) | ((StructFlags__typeCheckDone__));
}
TypeCheckResult__ TypeChecker__match___(TypeCheckerState__* s__, MatchExpression__* e__) {
	TypeCheckResult__ local0;
	memset(&local0, 0, sizeof(TypeCheckResult__));
	TypeCheckResult__ target__ = local0;
	bool__ condValid__ = false__;
	if ((((e__)->target__).dataPtr__) != ((pointer__)(null__))) {
		target__ = TypeChecker__expression__(s__, (e__)->target__);
		if (Tag__isValid__((target__).tag__)) {
			bool__ local1 = (((target__).tag__).kind__) == (TagKind__number__);
			if (local1) {
				local1 = ((((target__).tag__).q__)) > ((0));
			}
			if (local1) {
				condValid__ = true__;
			} else {
				List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((e__)->target__), mu_____string142));
			}
		}
	}
	TypeCheckResult__ local2;
	memset(&local2, 0, sizeof(TypeCheckResult__));
	TypeCheckResult__ result__ = local2;
	{
		List__Ptr__MatchExpressionCase______* local3 = (e__)->cases__;
		int__ local4 = 0;
		while (local4 < local3->count__) {
			MatchExpressionCase__* c__ = ((MatchExpressionCase__**)(local3->dataPtr__))[local4];
			TypeCheckResult__ vex__ = TypeChecker__expression__(s__, (c__)->valueExpr__);
			if (Tag__isValid__((vex__).tag__)) {
				bool__ local5 = (((vex__).tag__).kind__) == (TagKind__number__);
				if (local5) {
					local5 = (((vex__).value__).kind__) == (ValueKind__ulong___);
				}
				if (local5) {
					if (condValid__) {
						if (TypeChecker__canAssign__(s__, (vex__).tag__, (vex__).value__, (target__).tag__)) {
						} else {
							TypeChecker__badConstConversion__(s__, (c__)->valueExpr__, (vex__).tag__, (target__).tag__);
						}
					}
				} else {
					List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((c__)->valueExpr__), mu_____string166));
				}
			}
			if ((((c__)->resultExpr__).dataPtr__) != ((pointer__)(null__))) {
				TypeCheckResult__ rex__ = TypeChecker__expressionContinueGap__(s__, (c__)->resultExpr__);
				if (Tag__isValid__((rex__).tag__)) {
					if (Tag__isValid__((result__).tag__)) {
						bool__ local6 = (((rex__).tag__).kind__) == (TagKind__number__);
						if (local6) {
							local6 = ((((rex__).tag__).q__)) == ((((result__).tag__).q__));
						}
						if (local6) {
						} else {
							List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((c__)->resultExpr__), mu_____string167));
						}
					} else {
						bool__ local7 = (((rex__).tag__).kind__) == (TagKind__number__);
						if (local7) {
							local7 = ((((rex__).tag__).q__)) > ((0));
						}
						if (local7) {
							(result__).tag__ = (rex__).tag__;
						} else {
							List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__((c__)->resultExpr__), mu_____string142));
						}
					}
				}
			}
			local4 += 1;
		}
	}
	return result__;
}
bool__ TypeChecker__isFixedNumberOrStruct__(Tag__ tag__) {
	bool__ local1 = ((tag__).kind__) == (TagKind__number__);
	if (local1) {
		local1 = (((tag__).q__)) > ((0));
	}
	bool__ local0 = local1;
	if (!local0) {
		local0 = ((tag__).kind__) == (TagKind__struct___);
	}
	return local0;
}
void__ TypeChecker__duplicateSymbol__(TypeCheckerState__* s__, Token__* token__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, (token__)->span__, mu_____string104));
}
void__ TypeChecker__expectedFixedNumberOrStructExpression__(TypeCheckerState__* s__, Node__ e__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), mu_____string120));
}
TypeCheckResult__ TypeChecker__expressionWithGap__(TypeCheckerState__* s__, Node__ e__, bool__ gap__, Tag__ gapTag__) {
	(s__)->gap__ = gap__;
	(s__)->gapTag__ = gapTag__;
	TypeCheckResult__ tr__ = TypeChecker__expressionContinueGap__(s__, e__);
	(s__)->gap__ = false__;
	return tr__;
}
void__ TypeChecker__expectedNumberExpression__(TypeCheckerState__* s__, Node__ e__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, RangeFinder__find__(e__), mu_____string143));
}
void__ TypeChecker__callArgs__(TypeCheckerState__* s__, CallExpression__* e__, ModuleDef__* def__) {
	if ((def__) != (null__)) {
		Array__int____* local0 = (Array__int____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__int____));
		*local0 = Array__cons__int____(((((def__)->inputs__)->count__)) + ((1)));
		(e__)->calleeLocalIdToArgIndex__ = local0;
		{
			int__ i__ = 0;
			while (((i__)) < ((((e__)->calleeLocalIdToArgIndex__)->count__))) {
				Array__int____* local1 = (e__)->calleeLocalIdToArgIndex__;
				uint__ local2 = (uint__)(i__);
				mu_____boundscheck(local2 < (uint__)local1->count__);
				((int__*)local1->dataPtr__)[local2] = -1;
				i__ += 1;
			}
		}
		{
			List__Ptr__CallArg______* local3 = (e__)->args__;
			int__ i__ = 0;
			while (i__ < local3->count__) {
				CallArg__* arg__ = ((CallArg__**)(local3->dataPtr__))[i__];
				Tag__ local4;
				memset(&local4, 0, sizeof(Tag__));
				Tag__ tag__ = local4;
				bool__ isStatic__ = false__;
				if (((arg__)->name__) != (null__)) {
					Node__ sym__ = Map__getOrDefault__string__Node____((def__)->symbols__, ((arg__)->name__)->value__);
					bool__ local5 = ((sym__).dataPtr__) != ((pointer__)(null__));
					if (local5) {
						local5 = (sym__).id__ == Node_____Ptr__ModuleInputDef____;
					}
					if (local5) {
						Node__ local6 = sym__;
						mu_____checkedcast(local6.id__ == Node_____Ptr__ModuleInputDef____);
						ModuleInputDef__* input__ = (ModuleInputDef__*)(local6.dataPtr__);
						isStatic__ = ((((input__)->flags__)) & ((ModuleInputFlags__static__))) != (0);
						Array__int____* local7 = (e__)->calleeLocalIdToArgIndex__;
						uint__ local8 = (uint__)((input__)->localId__);
						mu_____boundscheck(local8 < (uint__)local7->count__);
						if (((((int__*)local7->dataPtr__)[local8])) == ((-1))) {
							Array__int____* local9 = (e__)->calleeLocalIdToArgIndex__;
							uint__ local10 = (uint__)((input__)->localId__);
							mu_____boundscheck(local10 < (uint__)local9->count__);
							((int__*)local9->dataPtr__)[local10] = i__;
						} else {
							List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((arg__)->name__)->span__, mu_____string194));
						}
						Node__ local11;
						local11.dataPtr__ = (pointer__)(input__);
						local11.id__ = local11.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
						tag__ = Map__getOrDefault__Node__Tag____((s__)->typeMap__, local11);
					} else {
						StringBuilder__ local12;
						memset(&local12, 0, sizeof(local12));
						string__ local13 = { (pointer__)"Undefined input: ", 17 };
						StringBuilder__write__(&local12, local13);
						StringBuilder__write__(&local12, ((def__)->name__)->value__);
						string__ local14 = { (pointer__)".", 1 };
						StringBuilder__write__(&local12, local14);
						StringBuilder__write__(&local12, ((arg__)->name__)->value__);
						List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((arg__)->name__)->span__, StringBuilder__compactToString__(&local12)));
					}
				}
				if ((((arg__)->expr__).dataPtr__) != ((pointer__)(null__))) {
					bool__ local16 = ((arg__)->expr__).id__ == Node_____Ptr__NumberExpression____;
					if (!local16) {
						local16 = ((arg__)->expr__).id__ == Node_____Ptr__BraceExpression____;
					}
					bool__ local15 = local16;
					if (!local15) {
						bool__ local17 = ((arg__)->expr__).id__ == Node_____Ptr__CallExpression____;
						if (local17) {
							Node__ local18 = (arg__)->expr__;
							mu_____checkedcast(local18.id__ == Node_____Ptr__CallExpression____);
							local17 = (((CallExpression__*)(local18.dataPtr__))->builtin__) == (BuiltinCall__rep__);
						}
						local15 = local17;
					}
					(s__)->allowDontCare__ = local15;
					(s__)->isStaticExpr__ = isStatic__;
					TypeCheckResult__ rhs__ = TypeChecker__expressionWithGap__(s__, (arg__)->expr__, true__, tag__);
					(s__)->allowDontCare__ = false__;
					(s__)->isStaticExpr__ = false__;
					if (!(TypeChecker__canAssign__(s__, (rhs__).tag__, (rhs__).value__, tag__))) {
						TypeChecker__badAssign__(s__, (arg__)->colon__, (rhs__).tag__, tag__);
					}
					if (((arg__)->name__) == (null__)) {
						List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, (RangeFinder__find__((arg__)->expr__)).from__, mu_____string196));
					}
				}
				i__ += 1;
			}
		}
		List__string____ local19;
		memset(&local19, 0, sizeof(List__string____));
		List__string____ missing__ = local19;
		{
			int__ i__ = 0;
			while (((i__)) < ((((def__)->inputs__)->count__))) {
				Array__int____* local20 = (e__)->calleeLocalIdToArgIndex__;
				uint__ local21 = (uint__)(((i__)) + ((1)));
				mu_____boundscheck(local21 < (uint__)local20->count__);
				if (((((int__*)local20->dataPtr__)[local21])) == ((-1))) {
					List__Ptr__ModuleInputDef______* local22 = (def__)->inputs__;
					uint__ local23 = (uint__)(i__);
					mu_____boundscheck(local23 < (uint__)local22->count__);
					List__add__string____(&(missing__), ((((ModuleInputDef__**)local22->dataPtr__)[local23])->name__)->value__);
				}
				i__ += 1;
			}
		}
		if ((((missing__).count__)) > ((0))) {
			Array__string____ local24 = List__slice__string____(&(missing__), 0, (missing__).count__);
			string__ names__ = string__join__(mu_____string197, &local24);
			StringBuilder__ local25;
			memset(&local25, 0, sizeof(local25));
			string__ local26 = { (pointer__)"Missing required parameters: ", 29 };
			StringBuilder__write__(&local25, local26);
			StringBuilder__write__(&local25, names__);
			List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, (((e__)->openParen__)->span__).from__, StringBuilder__compactToString__(&local25)));
		}
	} else {
		{
			List__Ptr__CallArg______* local27 = (e__)->args__;
			int__ local28 = 0;
			while (local28 < local27->count__) {
				CallArg__* arg__ = ((CallArg__**)(local27->dataPtr__))[local28];
				if ((((arg__)->expr__).dataPtr__) != ((pointer__)(null__))) {
					TypeChecker__expression__(s__, (arg__)->expr__);
				}
				local28 += 1;
			}
		}
	}
}
void__ TypeChecker__restoreContext__(TypeCheckerState__* s__, TypeCheckerContext__ ctx__) {
	(s__)->unit__ = (ctx__).unit__;
	(s__)->module__ = (ctx__).module__;
	(s__)->inClock__ = (ctx__).inClock__;
	(s__)->isStaticExpr__ = (ctx__).isStaticExpr__;
	(s__)->allowDontCare__ = (ctx__).allowDontCare__;
}
void__ StringBuilder__reverseSlice__(StringBuilder__* sb__, int__ from__, int__ to__) {
	bool__ local1 = ((0)) <= ((from__));
	if (local1) {
		local1 = ((from__)) <= ((to__));
	}
	bool__ local0 = local1;
	if (local0) {
		local0 = ((to__)) <= (((sb__)->count__));
	}
	mu_____assert(local0);
	pointer__ lp__ = ((sb__)->dataPtr__) + (from__);
	pointer__ rp__ = (((sb__)->dataPtr__) + (to__)) - (1);
	while (true__) {
		if (!((lp__) < (rp__))) { break; }
		char__* lc__ = (char__*)(lp__);
		char__* rc__ = (char__*)(rp__);
		char__ temp__ = *(lc__);
		*(lc__) = *(rc__);
		*(rc__) = temp__;
		lp__ = (lp__) + (1);
		rp__ = (rp__) - (1);
	}
}
void__ StringBuilder__clear__(StringBuilder__* sb__) {
	(sb__)->count__ = 0;
}
string__ StringBuilder__toString__(StringBuilder__* this__) {
	return string__alloc__((this__)->dataPtr__, (this__)->count__);
}
void__ StringBuilder__writeChar__(StringBuilder__* sb__, char__ ch__) {
	if ((((sb__)->count__)) == (((sb__)->capacity__))) {
		StringBuilder__reserveForWrite__(sb__, 1);
	}
	*((char__*)(((sb__)->dataPtr__) + ((sb__)->count__))) = ch__;
	(sb__)->count__ = (((sb__)->count__)) + ((1));
}
void__ StringBuilder__reserve__(StringBuilder__* sb__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) < (((sb__)->capacity__))) {
		return;
	}
	(sb__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (sb__)->dataPtr__, (ssize__)(capacity__), (ssize__)((sb__)->capacity__), (ssize__)((sb__)->count__));
	(sb__)->capacity__ = capacity__;
}
void__ StringBuilder__write__(StringBuilder__* sb__, string__ s__) {
	int__ runway__ = (((sb__)->capacity__)) - (((sb__)->count__));
	if (((runway__)) < (((s__).length__))) {
		StringBuilder__reserveForWrite__(sb__, (s__).length__);
	}
	memcpy(((sb__)->dataPtr__) + ((sb__)->count__), (s__).dataPtr__, (usize__)((s__).length__));
	(sb__)->count__ = (((sb__)->count__)) + (((s__).length__));
}
void__ StringBuilder__reserveForWrite__(StringBuilder__* sb__, int__ numBytesToWrite__) {
	int__ target__ = CheckedMath__addPositiveInt__((sb__)->count__, numBytesToWrite__);
	if ((((sb__)->capacity__)) >= ((target__))) {
		return;
	}
	int__ cap__ = (sb__)->capacity__;
	if (((cap__)) == ((0))) {
		cap__ = 16;
	}
	while (true__) {
		if (!(((cap__)) < ((target__)))) { break; }
		cap__ = CheckedMath__mulPositiveInt__(cap__, 2);
	}
	StringBuilder__reserve__(sb__, cap__);
}
string__ StringBuilder__compactToString__(StringBuilder__* sb__) {
	pointer__ dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (sb__)->dataPtr__, (ssize__)((sb__)->count__), (ssize__)((sb__)->capacity__), (ssize__)((sb__)->count__));
	int__ count__ = (sb__)->count__;
	(sb__)->dataPtr__ = null__;
	(sb__)->count__ = 0;
	(sb__)->capacity__ = 0;
	return string__from__(dataPtr__, count__);
}
uint__ Random__xorshift32__(uint__* state__) {
	uint__ x__ = *(state__);
	x__ = ((x__)) ^ ((((uint__)x__) << (13)));
	x__ = ((x__)) ^ ((((uint__)x__) >> (17)));
	x__ = ((x__)) ^ ((((uint__)x__) << (5)));
	*(state__) = x__;
	return x__;
}
uint__ float__hash__(float__ val__) {
	union { float__ from; uint__ to; } local0;
	memset(&local0, 0, sizeof(local0));
	local0.from = val__;
	return local0.to;
}
int__ float__compare__(float__ a__, float__ b__) {
	if (((a__)) < ((b__))) {
		return -1;
	} else {
		if (((a__)) > ((b__))) {
			return 1;
		}
	}
	return 0;
}
void__ float__writeTo__(float__ val__, StringBuilder__* sb__) {
	double__writeTo__((double__)(val__), sb__);
}
uint__ sbyte__hash__(sbyte__ val__) {
	return (uint__)(val__);
}
void__ sbyte__writeTo__(sbyte__ val__, StringBuilder__* sb__) {
	long__writeTo__((long__)(val__), sb__);
}
Array__string____* Environment__getCommandLineArgs__() {
	int__ argc__ = 0;
	pointer__ argv__ = (pointer__)(null__);
	*(&(argc__)) = mu_____argc;
	*(&(argv__)) = mu_____argv;
	;
	Array__cstring____ local0;
	memset(&local0, 0, sizeof(Array__cstring____));
	local0.dataPtr__ = argv__;
	local0.count__ = argc__;
	Array__cstring____ cstrArray__ = local0;
	Array__string____* local1 = (Array__string____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__string____));
	*local1 = Array__cons__string____(argc__);
	Array__string____* result__ = local1;
	{
		Array__cstring____* local2 = &(cstrArray__);
		int__ i__ = 0;
		while (i__ < local2->count__) {
			cstring__ it__ = ((cstring__*)(local2->dataPtr__))[i__];
			Array__string____* local3 = result__;
			uint__ local4 = (uint__)(i__);
			mu_____boundscheck(local4 < (uint__)local3->count__);
			((string__*)local3->dataPtr__)[local4] = string__from_cstring__(it__);
			i__ += 1;
		}
	}
	return result__;
}
uint__ uint__hash__(uint__ val__) {
	return val__;
}
Maybe__uint____ uint__tryParse__(string__ s__) {
	Maybe__ulong____ pr__ = ulong__tryParse__(s__);
	bool__ local0 = (pr__).hasValue__;
	if (local0) {
		local0 = (((pr__).value__)) <= ((ulong__)(uint__maxValue__));
	}
	if (local0) {
		return Maybe__from__uint____((uint__)((pr__).value__));
	}
	Maybe__uint____ local1;
	memset(&local1, 0, sizeof(Maybe__uint____));
	return local1;
}
int__ uint__compare__(uint__ a__, uint__ b__) {
	if (((a__)) < ((b__))) {
		return -1;
	} else {
		if (((a__)) > ((b__))) {
			return 1;
		}
	}
	return 0;
}
void__ uint__writeTo__(uint__ val__, StringBuilder__* sb__) {
	ulong__writeTo__((ulong__)(val__), sb__);
}
uint__ ushort__hash__(ushort__ val__) {
	return (uint__)(val__);
}
void__ ushort__writeTo__(ushort__ val__, StringBuilder__* sb__) {
	ulong__writeTo__((ulong__)(val__), sb__);
}
void__ List__reserve__Ptr__SourceFile______(List__Ptr__SourceFile______* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(SourceFile__*))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(SourceFile__*))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(SourceFile__*))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__Error____(List__Error____* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(Error__))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(Error__))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(Error__))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__SlotInfo____(List__SlotInfo____* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(SlotInfo__))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(SlotInfo__))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(SlotInfo__))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__Ptr__AssignStatement______(List__Ptr__AssignStatement______* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(AssignStatement__*))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(AssignStatement__*))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(AssignStatement__*))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__QueuedCallArgs____(List__QueuedCallArgs____* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(QueuedCallArgs__))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(QueuedCallArgs__))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(QueuedCallArgs__))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__byte____(List__byte____* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(byte__))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(byte__))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(byte__))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__int____(List__int____* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(int__))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(int__))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(int__))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__Node____(List__Node____* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(Node__))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(Node__))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(Node__))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__Instruction____(List__Instruction____* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(Instruction__))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(Instruction__))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(Instruction__))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__Ptr__CallArg______(List__Ptr__CallArg______* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(CallArg__*))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(CallArg__*))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(CallArg__*))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__Ptr__MatchExpressionCase______(List__Ptr__MatchExpressionCase______* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(MatchExpressionCase__*))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(MatchExpressionCase__*))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(MatchExpressionCase__*))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__Value____(List__Value____* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(Value__))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(Value__))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(Value__))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__string____(List__string____* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(string__))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(string__))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(string__))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__Ptr__FieldDef______(List__Ptr__FieldDef______* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(FieldDef__*))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(FieldDef__*))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(FieldDef__*))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__Ptr__ModuleInputDef______(List__Ptr__ModuleInputDef______* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(ModuleInputDef__*))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(ModuleInputDef__*))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(ModuleInputDef__*))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__CommandLineArgsParserError____(List__CommandLineArgsParserError____* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(CommandLineArgsParserError__))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(CommandLineArgsParserError__))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(CommandLineArgsParserError__))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__Ptr__ModuleInstance______(List__Ptr__ModuleInstance______* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(ModuleInstance__*))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(ModuleInstance__*))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(ModuleInstance__*))));
	(this__)->capacity__ = capacity__;
}
void__ List__reserve__Ptr__CodeUnit______(List__Ptr__CodeUnit______* this__, int__ capacity__) {
	mu_____assert(((capacity__)) >= ((0)));
	if (((capacity__)) <= (((this__)->capacity__))) {
		return;
	}
	(this__)->dataPtr__ = IAllocator__realloc__(top_____currentAllocator__, (this__)->dataPtr__, CheckedMath__mulPositiveSsize__((ssize__)(capacity__), (ssize__)(sizeof(CodeUnit__*))), (((ssize__)((this__)->capacity__))) * ((ssize__)(sizeof(CodeUnit__*))), (((ssize__)((this__)->count__))) * ((ssize__)(sizeof(CodeUnit__*))));
	(this__)->capacity__ = capacity__;
}
Array__Error____ List__slice__Error____(List__Error____* this__, int__ from__, int__ to__) {
	bool__ local1 = ((0)) <= ((from__));
	if (local1) {
		local1 = ((from__)) <= ((to__));
	}
	bool__ local0 = local1;
	if (local0) {
		local0 = ((to__)) <= (((this__)->count__));
	}
	mu_____assert(local0);
	Array__Error____ local2;
	memset(&local2, 0, sizeof(Array__Error____));
	local2.dataPtr__ = ((this__)->dataPtr__) + ((((ssize__)(from__))) * ((ssize__)(sizeof(Error__))));
	local2.count__ = ((to__)) - ((from__));
	return local2;
}
Array__byte____ List__slice__byte____(List__byte____* this__, int__ from__, int__ to__) {
	bool__ local1 = ((0)) <= ((from__));
	if (local1) {
		local1 = ((from__)) <= ((to__));
	}
	bool__ local0 = local1;
	if (local0) {
		local0 = ((to__)) <= (((this__)->count__));
	}
	mu_____assert(local0);
	Array__byte____ local2;
	memset(&local2, 0, sizeof(Array__byte____));
	local2.dataPtr__ = ((this__)->dataPtr__) + ((((ssize__)(from__))) * ((ssize__)(sizeof(byte__))));
	local2.count__ = ((to__)) - ((from__));
	return local2;
}
Array__string____ List__slice__string____(List__string____* this__, int__ from__, int__ to__) {
	bool__ local1 = ((0)) <= ((from__));
	if (local1) {
		local1 = ((from__)) <= ((to__));
	}
	bool__ local0 = local1;
	if (local0) {
		local0 = ((to__)) <= (((this__)->count__));
	}
	mu_____assert(local0);
	Array__string____ local2;
	memset(&local2, 0, sizeof(Array__string____));
	local2.dataPtr__ = ((this__)->dataPtr__) + ((((ssize__)(from__))) * ((ssize__)(sizeof(string__))));
	local2.count__ = ((to__)) - ((from__));
	return local2;
}
void__ List__setCountChecked__Value____(List__Value____* this__, int__ count__) {
	bool__ local0 = ((0)) <= ((count__));
	if (local0) {
		local0 = ((count__)) <= (((this__)->count__));
	}
	mu_____assert(local0);
	(this__)->count__ = count__;
}
void__ List__add__Ptr__FieldDef______(List__Ptr__FieldDef______* this__, FieldDef__* item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__Ptr__FieldDef______(this__);
	}
	List__Ptr__FieldDef______* local0 = this__;
	((FieldDef__**)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__Error____(List__Error____* this__, Error__ item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__Error____(this__);
	}
	List__Error____* local0 = this__;
	((Error__*)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__Ptr__ModuleInputDef______(List__Ptr__ModuleInputDef______* this__, ModuleInputDef__* item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__Ptr__ModuleInputDef______(this__);
	}
	List__Ptr__ModuleInputDef______* local0 = this__;
	((ModuleInputDef__**)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__CommandLineArgsParserError____(List__CommandLineArgsParserError____* this__, CommandLineArgsParserError__ item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__CommandLineArgsParserError____(this__);
	}
	List__CommandLineArgsParserError____* local0 = this__;
	((CommandLineArgsParserError__*)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__SlotInfo____(List__SlotInfo____* this__, SlotInfo__ item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__SlotInfo____(this__);
	}
	List__SlotInfo____* local0 = this__;
	((SlotInfo__*)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__byte____(List__byte____* this__, byte__ item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__byte____(this__);
	}
	List__byte____* local0 = this__;
	((byte__*)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__Ptr__ModuleInstance______(List__Ptr__ModuleInstance______* this__, ModuleInstance__* item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__Ptr__ModuleInstance______(this__);
	}
	List__Ptr__ModuleInstance______* local0 = this__;
	((ModuleInstance__**)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__Node____(List__Node____* this__, Node__ item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__Node____(this__);
	}
	List__Node____* local0 = this__;
	((Node__*)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__int____(List__int____* this__, int__ item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__int____(this__);
	}
	List__int____* local0 = this__;
	((int__*)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__Instruction____(List__Instruction____* this__, Instruction__ item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__Instruction____(this__);
	}
	List__Instruction____* local0 = this__;
	((Instruction__*)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__Ptr__CodeUnit______(List__Ptr__CodeUnit______* this__, CodeUnit__* item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__Ptr__CodeUnit______(this__);
	}
	List__Ptr__CodeUnit______* local0 = this__;
	((CodeUnit__**)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__Value____(List__Value____* this__, Value__ item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__Value____(this__);
	}
	List__Value____* local0 = this__;
	((Value__*)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__string____(List__string____* this__, string__ item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__string____(this__);
	}
	List__string____* local0 = this__;
	((string__*)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__Ptr__SourceFile______(List__Ptr__SourceFile______* this__, SourceFile__* item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__Ptr__SourceFile______(this__);
	}
	List__Ptr__SourceFile______* local0 = this__;
	((SourceFile__**)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__Ptr__AssignStatement______(List__Ptr__AssignStatement______* this__, AssignStatement__* item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__Ptr__AssignStatement______(this__);
	}
	List__Ptr__AssignStatement______* local0 = this__;
	((AssignStatement__**)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__QueuedCallArgs____(List__QueuedCallArgs____* this__, QueuedCallArgs__ item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__QueuedCallArgs____(this__);
	}
	List__QueuedCallArgs____* local0 = this__;
	((QueuedCallArgs__*)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__Ptr__CallArg______(List__Ptr__CallArg______* this__, CallArg__* item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__Ptr__CallArg______(this__);
	}
	List__Ptr__CallArg______* local0 = this__;
	((CallArg__**)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__add__Ptr__MatchExpressionCase______(List__Ptr__MatchExpressionCase______* this__, MatchExpressionCase__* item__) {
	if ((((this__)->count__)) == (((this__)->capacity__))) {
		List__grow__Ptr__MatchExpressionCase______(this__);
	}
	List__Ptr__MatchExpressionCase______* local0 = this__;
	((MatchExpressionCase__**)local0->dataPtr__)[(this__)->count__] = item__;
	(this__)->count__ = (((this__)->count__)) + ((1));
}
void__ List__grow__Ptr__SourceFile______(List__Ptr__SourceFile______* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__Ptr__SourceFile______(this__, local0);
}
void__ List__grow__Error____(List__Error____* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__Error____(this__, local0);
}
void__ List__grow__SlotInfo____(List__SlotInfo____* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__SlotInfo____(this__, local0);
}
void__ List__grow__Ptr__AssignStatement______(List__Ptr__AssignStatement______* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__Ptr__AssignStatement______(this__, local0);
}
void__ List__grow__QueuedCallArgs____(List__QueuedCallArgs____* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__QueuedCallArgs____(this__, local0);
}
void__ List__grow__byte____(List__byte____* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__byte____(this__, local0);
}
void__ List__grow__int____(List__int____* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__int____(this__, local0);
}
void__ List__grow__Node____(List__Node____* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__Node____(this__, local0);
}
void__ List__grow__Instruction____(List__Instruction____* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__Instruction____(this__, local0);
}
void__ List__grow__Ptr__CallArg______(List__Ptr__CallArg______* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__Ptr__CallArg______(this__, local0);
}
void__ List__grow__Ptr__MatchExpressionCase______(List__Ptr__MatchExpressionCase______* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__Ptr__MatchExpressionCase______(this__, local0);
}
void__ List__grow__Value____(List__Value____* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__Value____(this__, local0);
}
void__ List__grow__string____(List__string____* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__string____(this__, local0);
}
void__ List__grow__Ptr__FieldDef______(List__Ptr__FieldDef______* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__Ptr__FieldDef______(this__, local0);
}
void__ List__grow__Ptr__ModuleInputDef______(List__Ptr__ModuleInputDef______* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__Ptr__ModuleInputDef______(this__, local0);
}
void__ List__grow__CommandLineArgsParserError____(List__CommandLineArgsParserError____* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__CommandLineArgsParserError____(this__, local0);
}
void__ List__grow__Ptr__ModuleInstance______(List__Ptr__ModuleInstance______* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__Ptr__ModuleInstance______(this__, local0);
}
void__ List__grow__Ptr__CodeUnit______(List__Ptr__CodeUnit______* this__) {
	int__ local0;
	if ((((this__)->capacity__)) != ((0))) {
		local0 = CheckedMath__mulPositiveInt__((this__)->capacity__, 2);
	} else {
		local0 = 4;
	}
	List__reserve__Ptr__CodeUnit______(this__, local0);
}
bool__ Set__tryRemove__string____(Set__string____* this__, string__ value__) {
	uint__ h__ = string__hash__(value__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__SetEntry__string______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		SetEntry__string____* e__ = &(((SetEntry__string____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			return false__;
		}
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = string__equals__((e__)->value__, value__);
		}
		if (local2) {
			goto label0;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
label0:
	{}
	uint__ z__ = b__;
	b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__SetEntry__string______* local3 = &((this__)->entries__);
		uint__ local4 = (uint__)(b__);
		mu_____boundscheck(local4 < (uint__)local3->count__);
		SetEntry__string____* e__ = &(((SetEntry__string____*)local3->dataPtr__)[local4]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			goto label2;
		}
		uint__ ib__ = (((e__)->hash__)) & (((this__)->capacityMask__));
		if (((((((ib__)) - ((((z__)) + ((uint__)(1)))))) & (((this__)->capacityMask__)))) >= ((((((b__)) - ((z__)))) & (((this__)->capacityMask__))))) {
			Array__SetEntry__string______* local5 = &((this__)->entries__);
			uint__ local6 = (uint__)(z__);
			mu_____boundscheck(local6 < (uint__)local5->count__);
			((SetEntry__string____*)local5->dataPtr__)[local6] = *(e__);
			z__ = b__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
label2:
	{}
	Array__SetEntry__string______* local7 = &((this__)->entries__);
	uint__ local8 = (uint__)(z__);
	mu_____boundscheck(local8 < (uint__)local7->count__);
	(((SetEntry__string____*)local7->dataPtr__)[local8]).hash__ = (uint__)(0);
	(this__)->count__ = (((this__)->count__)) - ((1));
	return true__;
}
bool__ Set__tryAdd__string____(Set__string____* this__, string__ value__) {
	if ((((this__)->count__)) > (((this__)->growThreshold__))) {
		Set__grow__string____(this__);
	}
	uint__ h__ = string__hash__(value__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__SetEntry__string______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		SetEntry__string____* e__ = &(((SetEntry__string____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			goto label0;
		}
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = string__equals__((e__)->value__, value__);
		}
		if (local2) {
			return false__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
label0:
	{}
	Array__SetEntry__string______* local3 = &((this__)->entries__);
	uint__ local4 = (uint__)(b__);
	mu_____boundscheck(local4 < (uint__)local3->count__);
	SetEntry__string____ local5;
	memset(&local5, 0, sizeof(SetEntry__string____));
	local5.hash__ = h__;
	local5.value__ = value__;
	((SetEntry__string____*)local3->dataPtr__)[local4] = local5;
	(this__)->count__ = (((this__)->count__)) + ((1));
	return true__;
}
void__ Set__add__string____(Set__string____* this__, string__ value__) {
	mu_____assert(Set__tryAdd__string____(this__, value__));
}
SetEntry__string____* Set__getEmptyEntry___string____(Set__string____* this__, uint__ h__) {
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__SetEntry__string______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		SetEntry__string____* e__ = &(((SetEntry__string____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			return e__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
bool__ Set__contains__string____(Set__string____* this__, string__ value__) {
	uint__ h__ = string__hash__(value__);
	if (((h__)) == ((uint__)(0))) {
		h__ = (uint__)(1);
	}
	uint__ b__ = ((h__)) & (((this__)->capacityMask__));
	while (true__) {
		if (!(true__)) { break; }
		Array__SetEntry__string______* local0 = &((this__)->entries__);
		uint__ local1 = (uint__)(b__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		SetEntry__string____* e__ = &(((SetEntry__string____*)local0->dataPtr__)[local1]);
		if ((((e__)->hash__)) == ((uint__)(0))) {
			return false__;
		}
		bool__ local2 = (((e__)->hash__)) == ((h__));
		if (local2) {
			local2 = string__equals__((e__)->value__, value__);
		}
		if (local2) {
			return true__;
		}
		b__ = ((((b__)) + ((uint__)(1)))) & (((this__)->capacityMask__));
	}
}
void__ Set__grow__string____(Set__string____* this__) {
	int__ newCap__ = CheckedMath__mulPositiveInt__(((this__)->entries__).count__, 2);
	Array__SetEntry__string______ prev__ = (this__)->entries__;
	(this__)->entries__ = Array__cons__SetEntry__string______(newCap__);
	(this__)->capacityMask__ = (uint__)(((newCap__)) - ((1)));
	(this__)->growThreshold__ = ((((newCap__)) / ((3)))) * ((2));
	{
		int__ i__ = 0;
		while (((i__)) < (((prev__).count__))) {
			Array__SetEntry__string______* local0 = &(prev__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->count__);
			SetEntry__string____* e__ = &(((SetEntry__string____*)local0->dataPtr__)[local1]);
			if ((((e__)->hash__)) != ((uint__)(0))) {
				*(Set__getEmptyEntry___string____(this__, (e__)->hash__)) = *(e__);
			}
			i__ += 1;
		}
	}
}
Set__string____ Set__create__string____() {
	int__ cap__ = 8;
	Set__string____ local0;
	memset(&local0, 0, sizeof(Set__string____));
	local0.entries__ = Array__cons__SetEntry__string______(cap__);
	local0.count__ = 0;
	local0.capacityMask__ = (uint__)(((cap__)) - ((1)));
	local0.growThreshold__ = ((((cap__)) / ((3)))) * ((2));
	return local0;
}
string__ ErrorHelper__getErrorDesc__(string__ path__, string__ source__, IntRange__ span__, string__ text__) {
	LocationInfo__ li__ = ErrorHelper__spanToLocationInfo__(source__, span__);
	int__ indent__ = ErrorHelper__getNumColumns__(string__slice__((li__).lineText__, 0, ((li__).columnSpan__).from__), 4);
	int__ width__ = ErrorHelper__getNumColumns__(string__slice__((li__).lineText__, ((li__).columnSpan__).from__, ((li__).columnSpan__).to__), 4);
	string__ local0;
	if (!string__equals__(path__, mu_____string0)) {
		StringBuilder__ local1;
		memset(&local1, 0, sizeof(local1));
		string__ local2 = { (pointer__)"\x0a""-> ", 4 };
		StringBuilder__write__(&local1, local2);
		StringBuilder__write__(&local1, path__);
		string__ local3 = { (pointer__)":", 1 };
		StringBuilder__write__(&local1, local3);
		int__writeTo__((li__).line__, &local1);
		local0 = StringBuilder__compactToString__(&local1);
	} else {
		local0 = mu_____string0;
	}
	string__ pathInfo__ = local0;
	StringBuilder__ local4;
	memset(&local4, 0, sizeof(local4));
	StringBuilder__write__(&local4, text__);
	StringBuilder__write__(&local4, pathInfo__);
	string__ local5 = { (pointer__)"\x0a""", 1 };
	StringBuilder__write__(&local4, local5);
	StringBuilder__write__(&local4, string__replace__((li__).lineText__, mu_____string81, mu_____string82));
	string__ local6 = { (pointer__)"\x0a""", 1 };
	StringBuilder__write__(&local4, local6);
	StringBuilder__write__(&local4, string__repeatChar__(' ', indent__));
	int__ local7 = 1;
	int__ local8 = width__;
	StringBuilder__write__(&local4, string__repeatChar__('~', (local7 > local8) ? local7 : local8));
	return StringBuilder__compactToString__(&local4);
}
LocationInfo__ ErrorHelper__spanToLocationInfo__(string__ source__, IntRange__ span__) {
	mu_____assert((((span__).from__)) <= (((span__).to__)));
	int__ from__ = (span__).from__;
	int__ lines__ = 0;
	int__ lineStart__ = 0;
	int__ i__ = 0;
	while (true__) {
		if (!(((i__)) < ((from__)))) { break; }
		string__* local0 = &(source__);
		uint__ local1 = (uint__)(i__);
		mu_____boundscheck(local1 < (uint__)local0->length__);
		char__ ch__ = ((char__*)local0->dataPtr__)[local1];
		if ((ch__) == ('\n')) {
			lines__ = ((lines__)) + ((1));
			lineStart__ = ((i__)) + ((1));
		}
		i__ = ((i__)) + ((1));
	}
	i__ = from__;
	int__ lineEnd__ = 0;
	while (true__) {
		if (!(true__)) { break; }
		string__* local2 = &(source__);
		uint__ local3 = (uint__)(i__);
		mu_____boundscheck(local3 < (uint__)local2->length__);
		char__ ch__ = ((char__*)local2->dataPtr__)[local3];
		bool__ local5 = (ch__) == ('\n');
		if (!local5) {
			local5 = (ch__) == ('\r');
		}
		bool__ local4 = local5;
		if (!local4) {
			local4 = (ch__) == ('\0');
		}
		if (local4) {
			lineEnd__ = i__;
			goto label2;
		}
		i__ = ((i__)) + ((1));
	}
label2:
	{}
	int__ local6 = (span__).to__;
	int__ local7 = lineEnd__;
	int__ to__ = (local6 < local7) ? local6 : local7;
	LocationInfo__ local8;
	memset(&local8, 0, sizeof(LocationInfo__));
	local8.line__ = ((lines__)) + ((1));
	local8.span__ = IntRange__cons__(from__, to__);
	local8.columnSpan__ = IntRange__cons__(((from__)) - ((lineStart__)), ((to__)) - ((lineStart__)));
	local8.lineText__ = string__slice__(source__, lineStart__, lineEnd__);
	return local8;
}
int__ ErrorHelper__getNumColumns__(string__ s__, int__ tabSize__) {
	int__ cols__ = 0;
	{
		int__ i__ = 0;
		while (((i__)) < (((s__).length__))) {
			string__* local0 = &(s__);
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->length__);
			if ((((char__*)local0->dataPtr__)[local1]) == ('\t')) {
				cols__ = ((cols__)) + ((tabSize__));
			} else {
				cols__ = ((cols__)) + ((1));
			}
			i__ += 1;
		}
	}
	return cols__;
}
int__ ErrorHelper__compareErrors__(Error__ a__, Error__ b__) {
	if (((a__).unit__) == (null__)) {
		return -1;
	}
	if (((b__).unit__) == (null__)) {
		return 1;
	}
	if (((((a__).unit__)->id__)) != ((((b__).unit__)->id__))) {
		return int__compare__(((a__).unit__)->id__, ((b__).unit__)->id__);
	}
	return int__compare__(((a__).span__).from__, ((b__).span__).from__);
}
void__ EmulatorOrderCalculator__dot__(EmulatorState__* s__, DotExpression__* e__) {
	Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, (e__)->lhs__);
	if (((tag__).kind__) == (TagKind__struct___)) {
		mu_____assert((((s__)->evalCtxField__)) == ((-1)));
		List__Node____* local1 = (s__)->entities__;
		uint__ local2 = (uint__)((tag__).q__);
		mu_____boundscheck(local2 < (uint__)local1->count__);
		Node__ local0 = ((Node__*)local1->dataPtr__)[local2];
		mu_____checkedcast(local0.id__ == Node_____Ptr__StructDef____);
		StructDef__* def__ = (StructDef__*)(local0.dataPtr__);
		(s__)->evalCtxField__ = (Map__get__string__Ptr__FieldDef______((def__)->symbols__, ((e__)->rhs__)->value__))->fieldIndex__;
		EmulatorOrderCalculator__expression__(s__, (e__)->lhs__);
		(s__)->evalCtxField__ = -1;
	} else {
		if (((tag__).kind__) == (TagKind__moduleOut__)) {
			mu_____assert((((s__)->evalCtxOutput__)) == ((-1)));
			List__Node____* local4 = (s__)->entities__;
			uint__ local5 = (uint__)((tag__).q__);
			mu_____boundscheck(local5 < (uint__)local4->count__);
			Node__ local3 = ((Node__*)local4->dataPtr__)[local5];
			mu_____checkedcast(local3.id__ == Node_____Ptr__ModuleDef____);
			ModuleDef__* def__ = (ModuleDef__*)(local3.dataPtr__);
			Node__ local6 = Map__get__string__Node____((def__)->symbols__, ((e__)->rhs__)->value__);
			mu_____checkedcast(local6.id__ == Node_____Ptr__AssignStatement____);
			(s__)->evalCtxOutput__ = ((AssignStatement__*)(local6.dataPtr__))->outputIndex__;
			EmulatorOrderCalculator__expression__(s__, (e__)->lhs__);
			(s__)->evalCtxOutput__ = -1;
		} else {
			mu_____abandon(-1);
		}
	}
}
void__ EmulatorOrderCalculator__block__(EmulatorState__* s__, Block__* st__) {
	{
		List__Node____* local0 = (st__)->contents__;
		int__ local1 = 0;
		while (local1 < local0->count__) {
			Node__ n__ = ((Node__*)(local0->dataPtr__))[local1];
			switch ((n__).id__) {
				case Node_____Ptr__ClockStatement____: {
					ClockStatement__* local2 = (ClockStatement__*)(n__.dataPtr__);
					EmulatorOrderCalculator__block__(s__, (local2)->body__);
					break;
				}
				case Node_____Ptr__IfStatement____: {
					IfStatement__* local3 = (IfStatement__*)(n__.dataPtr__);
					EmulatorOrderCalculator__if___(s__, local3);
					break;
				}
				case Node_____Ptr__AssignStatement____: {
					AssignStatement__* local4 = (AssignStatement__*)(n__.dataPtr__);
					EmulatorOrderCalculator__assign__(s__, local4);
					break;
				}
				case 0:
				default: {
					mu_____nomatch();
				}
			}
			local1 += 1;
		}
	}
}
void__ EmulatorOrderCalculator__structInit__(EmulatorState__* s__, StructInitializerExpression__* e__) {
	mu_____assert((((s__)->evalCtxField__)) >= ((0)));
	Node__ local0;
	local0.dataPtr__ = (pointer__)(e__);
	local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__StructInitializerExpression____ : 0;
	Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local0);
	mu_____assert(((tag__).kind__) == (TagKind__struct___));
	List__Node____* local2 = (s__)->entities__;
	uint__ local3 = (uint__)((tag__).q__);
	mu_____boundscheck(local3 < (uint__)local2->count__);
	Node__ local1 = ((Node__*)local2->dataPtr__)[local3];
	mu_____checkedcast(local1.id__ == Node_____Ptr__StructDef____);
	StructDef__* def__ = (StructDef__*)(local1.dataPtr__);
	Array__int____* local4 = (e__)->fieldIndexToArgIndex__;
	uint__ local5 = (uint__)((s__)->evalCtxField__);
	mu_____boundscheck(local5 < (uint__)local4->count__);
	int__ argIndex__ = ((int__*)local4->dataPtr__)[local5];
	if (((argIndex__)) >= ((0))) {
		List__Ptr__CallArg______* local6 = (e__)->args__;
		uint__ local7 = (uint__)(argIndex__);
		mu_____boundscheck(local7 < (uint__)local6->count__);
		Node__ arg__ = (((CallArg__**)local6->dataPtr__)[local7])->expr__;
		int__ prevCtxField__ = (s__)->evalCtxField__;
		(s__)->evalCtxField__ = -1;
		EmulatorOrderCalculator__expression__(s__, arg__);
		(s__)->evalCtxField__ = prevCtxField__;
	}
}
void__ EmulatorOrderCalculator__call__(EmulatorState__* s__, CallExpression__* e__) {
	if (((e__)->builtin__) != (BuiltinCall__none__)) {
		mu_____assert((((s__)->evalCtxOutput__)) == ((-1)));
		{
			List__Ptr__CallArg______* local0 = (e__)->args__;
			int__ local1 = 0;
			while (local1 < local0->count__) {
				CallArg__* arg__ = ((CallArg__**)(local0->dataPtr__))[local1];
				EmulatorOrderCalculator__expression__(s__, (arg__)->expr__);
				local1 += 1;
			}
		}
		return;
	}
	mu_____assert((((s__)->evalCtxOutput__)) >= ((0)));
	List__Ptr__ModuleInstance______* local2 = (s__)->moduleInstances__;
	Array__int____* local4 = ((s__)->inst__)->calls__;
	uint__ local5 = (uint__)((e__)->callId__);
	mu_____boundscheck(local5 < (uint__)local4->count__);
	uint__ local3 = (uint__)(((int__*)local4->dataPtr__)[local5]);
	mu_____boundscheck(local3 < (uint__)local2->count__);
	ModuleInstance__* target__ = ((ModuleInstance__**)local2->dataPtr__)[local3];
	if ((((target__)->def__)->blackboxKeyword__) != (null__)) {
		return;
	}
	List__Ptr__AssignStatement______* local6 = ((target__)->def__)->outputs__;
	uint__ local7 = (uint__)((s__)->evalCtxOutput__);
	mu_____boundscheck(local7 < (uint__)local6->count__);
	AssignStatement__* output__ = ((AssignStatement__**)local6->dataPtr__)[local7];
	ModuleInstance__* prevInst__ = (s__)->inst__;
	int__ prevCtxOutput__ = (s__)->evalCtxOutput__;
	(s__)->inst__ = target__;
	(s__)->evalCtxOutput__ = -1;
	EmulatorOrderCalculator__assignRef__(s__, output__);
	(s__)->inst__ = prevInst__;
	(s__)->evalCtxOutput__ = prevCtxOutput__;
}
void__ EmulatorOrderCalculator__comp__(EmulatorState__* s__) {
	Array__bool____* local0 = (Array__bool____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__bool____));
	*local0 = Array__cons__bool____(((s__)->rs__)->count__);
	(s__)->started__ = local0;
	Array__bool____* local1 = (Array__bool____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__bool____));
	*local1 = Array__cons__bool____(((s__)->rs__)->count__);
	(s__)->done__ = local1;
	List__Ptr__ModuleInstance______* local2 = (s__)->moduleInstances__;
	uint__ local3 = (uint__)(0);
	mu_____boundscheck(local3 < (uint__)local2->count__);
	ModuleInstance__* top__ = ((ModuleInstance__**)local2->dataPtr__)[local3];
	{
		List__Ptr__ModuleInputDef______* local4 = ((top__)->def__)->inputs__;
		int__ local5 = 0;
		while (local5 < local4->count__) {
			ModuleInputDef__* inp__ = ((ModuleInputDef__**)(local4->dataPtr__))[local5];
			Array__int____* local6 = (top__)->localState__;
			uint__ local7 = (uint__)((inp__)->localId__);
			mu_____boundscheck(local7 < (uint__)local6->count__);
			int__ si__ = ((int__*)local6->dataPtr__)[local7];
			List__SlotInfo____* local8 = (s__)->infos__;
			uint__ local9 = (uint__)(si__);
			mu_____boundscheck(local9 < (uint__)local8->count__);
			Tag__ tag__ = (((SlotInfo__*)local8->dataPtr__)[local9]).tag__;
			if (((tag__).kind__) == (TagKind__number__)) {
				Array__bool____* local10 = (s__)->started__;
				uint__ local11 = (uint__)(si__);
				mu_____boundscheck(local11 < (uint__)local10->count__);
				((bool__*)local10->dataPtr__)[local11] = true__;
				Array__bool____* local12 = (s__)->done__;
				uint__ local13 = (uint__)(si__);
				mu_____boundscheck(local13 < (uint__)local12->count__);
				((bool__*)local12->dataPtr__)[local13] = true__;
			} else {
				if (((tag__).kind__) == (TagKind__struct___)) {
					List__Node____* local15 = (s__)->entities__;
					uint__ local16 = (uint__)((tag__).q__);
					mu_____boundscheck(local16 < (uint__)local15->count__);
					Node__ local14 = ((Node__*)local15->dataPtr__)[local16];
					mu_____checkedcast(local14.id__ == Node_____Ptr__StructDef____);
					StructDef__* struct___ = (StructDef__*)(local14.dataPtr__);
					{
						List__Ptr__FieldDef______* local17 = (struct___)->fields__;
						int__ fi__ = 0;
						while (fi__ < local17->count__) {
							FieldDef__* f__ = ((FieldDef__**)(local17->dataPtr__))[fi__];
							Array__bool____* local18 = (s__)->started__;
							uint__ local19 = (uint__)(((si__)) + ((fi__)));
							mu_____boundscheck(local19 < (uint__)local18->count__);
							((bool__*)local18->dataPtr__)[local19] = true__;
							Array__bool____* local20 = (s__)->done__;
							uint__ local21 = (uint__)(((si__)) + ((fi__)));
							mu_____boundscheck(local21 < (uint__)local20->count__);
							((bool__*)local20->dataPtr__)[local21] = true__;
							fi__ += 1;
						}
					}
				}
			}
			local5 += 1;
		}
	}
	{
		List__Ptr__ModuleInstance______* local22 = (s__)->moduleInstances__;
		int__ local23 = 0;
		while (local23 < local22->count__) {
			ModuleInstance__* mi__ = ((ModuleInstance__**)(local22->dataPtr__))[local23];
			EmulatorOrderCalculator__module__(s__, mi__);
			local23 += 1;
		}
	}
}
void__ EmulatorOrderCalculator__expression__(EmulatorState__* s__, Node__ e__) {
	switch ((e__).id__) {
		case Node_____Ptr__Token____: {
			Token__* local0 = (Token__*)(e__.dataPtr__);
			EmulatorOrderCalculator__token__(s__, local0);
			break;
		}
		case Node_____Ptr__NumberExpression____: {
			NumberExpression__* local1 = (NumberExpression__*)(e__.dataPtr__);
			{
			}
			break;
		}
		case Node_____Ptr__UnaryOperatorExpression____: {
			UnaryOperatorExpression__* local2 = (UnaryOperatorExpression__*)(e__.dataPtr__);
			{
				EmulatorOrderCalculator__expression__(s__, (local2)->expr__);
			}
			break;
		}
		case Node_____Ptr__BinaryOperatorExpression____: {
			BinaryOperatorExpression__* local3 = (BinaryOperatorExpression__*)(e__.dataPtr__);
			{
				EmulatorOrderCalculator__expression__(s__, (local3)->lhs__);
				EmulatorOrderCalculator__expression__(s__, (local3)->rhs__);
			}
			break;
		}
		case Node_____Ptr__DotExpression____: {
			DotExpression__* local4 = (DotExpression__*)(e__.dataPtr__);
			EmulatorOrderCalculator__dot__(s__, local4);
			break;
		}
		case Node_____Ptr__TernaryOperatorExpression____: {
			TernaryOperatorExpression__* local5 = (TernaryOperatorExpression__*)(e__.dataPtr__);
			{
				EmulatorOrderCalculator__expression__(s__, (local5)->conditionExpr__);
				EmulatorOrderCalculator__expression__(s__, (local5)->trueExpr__);
				EmulatorOrderCalculator__expression__(s__, (local5)->falseExpr__);
			}
			break;
		}
		case Node_____Ptr__MatchExpression____: {
			MatchExpression__* local6 = (MatchExpression__*)(e__.dataPtr__);
			{
				EmulatorOrderCalculator__expression__(s__, (local6)->target__);
				{
					List__Ptr__MatchExpressionCase______* local7 = (local6)->cases__;
					int__ local8 = 0;
					while (local8 < local7->count__) {
						MatchExpressionCase__* c__ = ((MatchExpressionCase__**)(local7->dataPtr__))[local8];
						EmulatorOrderCalculator__expression__(s__, (c__)->valueExpr__);
						EmulatorOrderCalculator__expression__(s__, (c__)->resultExpr__);
						local8 += 1;
					}
				}
			}
			break;
		}
		case Node_____Ptr__ParenExpression____: {
			ParenExpression__* local9 = (ParenExpression__*)(e__.dataPtr__);
			{
				EmulatorOrderCalculator__expression__(s__, (local9)->expr__);
			}
			break;
		}
		case Node_____Ptr__IndexExpression____: {
			IndexExpression__* local10 = (IndexExpression__*)(e__.dataPtr__);
			{
				EmulatorOrderCalculator__expression__(s__, (local10)->target__);
				EmulatorOrderCalculator__expression__(s__, (local10)->upperExpr__);
				EmulatorOrderCalculator__expression__(s__, (local10)->lowerExpr__);
			}
			break;
		}
		case Node_____Ptr__BraceExpression____: {
			BraceExpression__* local11 = (BraceExpression__*)(e__.dataPtr__);
			{
				{
					List__Node____* local12 = (local11)->args__;
					int__ local13 = 0;
					while (local13 < local12->count__) {
						Node__ arg__ = ((Node__*)(local12->dataPtr__))[local13];
						EmulatorOrderCalculator__expression__(s__, arg__);
						local13 += 1;
					}
				}
			}
			break;
		}
		case Node_____Ptr__CallExpression____: {
			CallExpression__* local14 = (CallExpression__*)(e__.dataPtr__);
			EmulatorOrderCalculator__call__(s__, local14);
			break;
		}
		case Node_____Ptr__StructInitializerExpression____: {
			StructInitializerExpression__* local15 = (StructInitializerExpression__*)(e__.dataPtr__);
			EmulatorOrderCalculator__structInit__(s__, local15);
			break;
		}
		case Node_____Ptr__ArrayExpression____: {
			ArrayExpression__* local16 = (ArrayExpression__*)(e__.dataPtr__);
			{
			}
			break;
		}
		case 0: {
			{
			}
			break;
		}
		default: {
			mu_____nomatch();
		}
	}
}
void__ EmulatorOrderCalculator__assign__(EmulatorState__* s__, AssignStatement__* st__) {
	bool__ local1 = ((((st__)->flags__)) & ((AssignFlags__reg__))) != (0);
	if (local1) {
		local1 = ((((st__)->flags__)) & ((AssignFlags__regUpdate__))) == (0);
	}
	bool__ local0 = local1;
	if (local0) {
		local0 = (((st__)->expr__).dataPtr__) != ((pointer__)(null__));
	}
	if (local0) {
		Node__ local2;
		local2.dataPtr__ = (pointer__)(st__);
		local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
		Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local2);
		if (((tag__).kind__) == (TagKind__number__)) {
			EmulatorOrderCalculator__expression__(s__, (st__)->expr__);
			Array__int____* local3 = ((s__)->inst__)->localState__;
			uint__ local4 = (uint__)((st__)->localId__);
			mu_____boundscheck(local4 < (uint__)local3->count__);
			List__add__int____((s__)->evalOrder__, ((int__*)local3->dataPtr__)[local4]);
		} else {
			if (((tag__).kind__) == (TagKind__struct___)) {
				List__Node____* local6 = (s__)->entities__;
				uint__ local7 = (uint__)((tag__).q__);
				mu_____boundscheck(local7 < (uint__)local6->count__);
				Node__ local5 = ((Node__*)local6->dataPtr__)[local7];
				mu_____checkedcast(local5.id__ == Node_____Ptr__StructDef____);
				StructDef__* def__ = (StructDef__*)(local5.dataPtr__);
				{
					List__Ptr__FieldDef______* local8 = (def__)->fields__;
					int__ fi__ = 0;
					while (fi__ < local8->count__) {
						FieldDef__* f__ = ((FieldDef__**)(local8->dataPtr__))[fi__];
						(s__)->evalCtxField__ = fi__;
						EmulatorOrderCalculator__expression__(s__, (st__)->expr__);
						Array__int____* local9 = ((s__)->inst__)->localState__;
						uint__ local10 = (uint__)((st__)->localId__);
						mu_____boundscheck(local10 < (uint__)local9->count__);
						List__add__int____((s__)->evalOrder__, ((((int__*)local9->dataPtr__)[local10])) + ((fi__)));
						fi__ += 1;
					}
				}
				(s__)->evalCtxField__ = -1;
			} else {
				mu_____abandon(-1);
			}
		}
	}
	bool__ local12 = ((((st__)->flags__)) & ((AssignFlags__wire__))) != (0);
	if (local12) {
		local12 = ((st__)->outKeyword__) != (null__);
	}
	bool__ local11 = local12;
	if (local11) {
		List__Ptr__ModuleInstance______* local13 = (s__)->moduleInstances__;
		uint__ local14 = (uint__)(0);
		mu_____boundscheck(local14 < (uint__)local13->count__);
		local11 = ((s__)->inst__) == (((ModuleInstance__**)local13->dataPtr__)[local14]);
	}
	if (local11) {
		Node__ local15;
		local15.dataPtr__ = (pointer__)(st__);
		local15.id__ = local15.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
		Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local15);
		if (((tag__).kind__) == (TagKind__number__)) {
			EmulatorOrderCalculator__wire__(s__, st__);
		} else {
			if (((tag__).kind__) == (TagKind__struct___)) {
				List__Node____* local17 = (s__)->entities__;
				uint__ local18 = (uint__)((tag__).q__);
				mu_____boundscheck(local18 < (uint__)local17->count__);
				Node__ local16 = ((Node__*)local17->dataPtr__)[local18];
				mu_____checkedcast(local16.id__ == Node_____Ptr__StructDef____);
				StructDef__* def__ = (StructDef__*)(local16.dataPtr__);
				{
					List__Ptr__FieldDef______* local19 = (def__)->fields__;
					int__ i__ = 0;
					while (i__ < local19->count__) {
						FieldDef__* f__ = ((FieldDef__**)(local19->dataPtr__))[i__];
						(s__)->evalCtxField__ = i__;
						EmulatorOrderCalculator__wire__(s__, st__);
						i__ += 1;
					}
				}
				(s__)->evalCtxField__ = -1;
			} else {
				if (((tag__).kind__) == (TagKind__moduleOut__)) {
				} else {
					mu_____abandon(-1);
				}
			}
		}
	}
	if (((((st__)->flags__)) & ((AssignFlags__regUpdate__))) != (0)) {
		Array__int____* local20 = ((s__)->inst__)->localState__;
		uint__ local21 = (uint__)((st__)->localId__);
		mu_____boundscheck(local21 < (uint__)local20->count__);
		int__ si__ = ((int__*)local20->dataPtr__)[local21];
		if (((st__)->nameExpr__).id__ == Node_____Ptr__Token____) {
			Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, (st__)->expr__);
			if (((tag__).kind__) == (TagKind__number__)) {
				EmulatorOrderCalculator__expression__(s__, (st__)->expr__);
			} else {
				if (((tag__).kind__) == (TagKind__struct___)) {
					List__Node____* local23 = (s__)->entities__;
					uint__ local24 = (uint__)((tag__).q__);
					mu_____boundscheck(local24 < (uint__)local23->count__);
					Node__ local22 = ((Node__*)local23->dataPtr__)[local24];
					mu_____checkedcast(local22.id__ == Node_____Ptr__StructDef____);
					StructDef__* def__ = (StructDef__*)(local22.dataPtr__);
					{
						List__Ptr__FieldDef______* local25 = (def__)->fields__;
						int__ i__ = 0;
						while (i__ < local25->count__) {
							FieldDef__* f__ = ((FieldDef__**)(local25->dataPtr__))[i__];
							(s__)->evalCtxField__ = i__;
							EmulatorOrderCalculator__expression__(s__, (st__)->expr__);
							i__ += 1;
						}
					}
					(s__)->evalCtxField__ = -1;
				} else {
					mu_____abandon(-1);
				}
			}
		} else {
			if (((st__)->nameExpr__).id__ == Node_____Ptr__DotExpression____) {
				Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, (st__)->expr__);
				if (((tag__).kind__) == (TagKind__number__)) {
					EmulatorOrderCalculator__expression__(s__, (st__)->expr__);
				} else {
					mu_____abandon(-1);
				}
			} else {
				if (((st__)->nameExpr__).id__ == Node_____Ptr__CallExpression____) {
					Node__ local26 = (st__)->nameExpr__;
					mu_____checkedcast(local26.id__ == Node_____Ptr__CallExpression____);
					CallExpression__* call__ = (CallExpression__*)(local26.dataPtr__);
					if (((call__)->builtin__) == (BuiltinCall__slice__)) {
						EmulatorOrderCalculator__expression__(s__, (st__)->expr__);
					} else {
						mu_____abandon(-1);
					}
				} else {
					mu_____abandon(-1);
				}
			}
		}
	}
}
void__ EmulatorOrderCalculator__assignRef__(EmulatorState__* s__, AssignStatement__* st__) {
	Array__int____* local0 = ((s__)->inst__)->localState__;
	uint__ local1 = (uint__)((st__)->localId__);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	int__ si__ = ((int__*)local0->dataPtr__)[local1];
	if (((((st__)->flags__)) & ((AssignFlags__reg__))) != (0)) {
		mu_____assert((((s__)->evalCtxOutput__)) == ((-1)));
	} else {
		if (((((st__)->flags__)) & ((AssignFlags__wire__))) != (0)) {
			EmulatorOrderCalculator__wire__(s__, st__);
		} else {
			mu_____abandon(-1);
		}
	}
}
void__ EmulatorOrderCalculator__token__(EmulatorState__* s__, Token__* e__) {
	string__ name__ = (e__)->value__;
	Node__ local0;
	if (((s__)->inst__) != (null__)) {
		local0 = Map__getOrDefault__string__Node____((((s__)->inst__)->def__)->symbols__, name__);
	} else {
		Node__ local1;
		local1.dataPtr__ = null__;
		local1.id__ = 0;
		local0 = local1;
	}
	Node__ node__ = local0;
	switch ((node__).id__) {
		case Node_____Ptr__ModuleInputDef____: {
			ModuleInputDef__* local2 = (ModuleInputDef__*)(node__.dataPtr__);
			{
				EmulatorOrderCalculator__input__(s__, local2);
			}
			break;
		}
		case Node_____Ptr__AssignStatement____: {
			AssignStatement__* local3 = (AssignStatement__*)(node__.dataPtr__);
			{
				EmulatorOrderCalculator__assignRef__(s__, local3);
			}
			break;
		}
		case 0: {
			{
			}
			break;
		}
		default: {
			mu_____nomatch();
		}
	}
}
void__ EmulatorOrderCalculator__wire__(EmulatorState__* s__, AssignStatement__* st__) {
	Array__int____* local0 = ((s__)->inst__)->localState__;
	uint__ local1 = (uint__)((st__)->localId__);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	int__ si__ = ((int__*)local0->dataPtr__)[local1];
	if (((si__)) == ((-1))) {
		EmulatorOrderCalculator__expression__(s__, (st__)->expr__);
		return;
	}
	int__ local2 = (s__)->evalCtxField__;
	int__ local3 = 0;
	si__ = ((si__)) + (((local2 > local3) ? local2 : local3));
	Array__bool____* local4 = (s__)->done__;
	uint__ local5 = (uint__)(si__);
	mu_____boundscheck(local5 < (uint__)local4->count__);
	if (((bool__*)local4->dataPtr__)[local5]) {
		return;
	} else {
		Array__bool____* local6 = (s__)->started__;
		uint__ local7 = (uint__)(si__);
		mu_____boundscheck(local7 < (uint__)local6->count__);
		if (!(((bool__*)local6->dataPtr__)[local7])) {
			Array__bool____* local8 = (s__)->started__;
			uint__ local9 = (uint__)(si__);
			mu_____boundscheck(local9 < (uint__)local8->count__);
			((bool__*)local8->dataPtr__)[local9] = true__;
			EmulatorOrderCalculator__expression__(s__, (st__)->expr__);
			List__add__int____((s__)->evalOrder__, si__);
			Array__bool____* local10 = (s__)->done__;
			uint__ local11 = (uint__)(si__);
			mu_____boundscheck(local11 < (uint__)local10->count__);
			((bool__*)local10->dataPtr__)[local11] = true__;
		} else {
			EmulatorOrderCalculator__logicLoop__(s__, (st__)->nameExpr__);
		}
	}
}
void__ EmulatorOrderCalculator__if___(EmulatorState__* s__, IfStatement__* st__) {
	EmulatorOrderCalculator__expression__(s__, (st__)->expr__);
	EmulatorOrderCalculator__block__(s__, (st__)->ifBody__);
	if (((st__)->elseBranch__).id__ == Node_____Ptr__IfStatement____) {
		Node__ local0 = (st__)->elseBranch__;
		mu_____checkedcast(local0.id__ == Node_____Ptr__IfStatement____);
		EmulatorOrderCalculator__if___(s__, (IfStatement__*)(local0.dataPtr__));
	} else {
		if (((st__)->elseBranch__).id__ == Node_____Ptr__Block____) {
			Node__ local1 = (st__)->elseBranch__;
			mu_____checkedcast(local1.id__ == Node_____Ptr__Block____);
			EmulatorOrderCalculator__block__(s__, (Block__*)(local1.dataPtr__));
		}
	}
}
void__ EmulatorOrderCalculator__input__(EmulatorState__* s__, ModuleInputDef__* inp__) {
	Array__int____* local0 = ((s__)->inst__)->localState__;
	uint__ local1 = (uint__)((inp__)->localId__);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	int__ local2 = (s__)->evalCtxField__;
	int__ local3 = 0;
	int__ si__ = ((((int__*)local0->dataPtr__)[local1])) + (((local2 > local3) ? local2 : local3));
	Array__bool____* local4 = (s__)->done__;
	uint__ local5 = (uint__)(si__);
	mu_____boundscheck(local5 < (uint__)local4->count__);
	if (((bool__*)local4->dataPtr__)[local5]) {
		return;
	}
	Array__bool____* local6 = (s__)->started__;
	uint__ local7 = (uint__)(si__);
	mu_____boundscheck(local7 < (uint__)local6->count__);
	if (!(((bool__*)local6->dataPtr__)[local7])) {
		ModuleInstance__* caller__ = ((s__)->inst__)->caller__;
		CallExpression__* callExpr__ = ((s__)->inst__)->callExpr__;
		Array__bool____* local8 = (s__)->started__;
		uint__ local9 = (uint__)(si__);
		mu_____boundscheck(local9 < (uint__)local8->count__);
		((bool__*)local8->dataPtr__)[local9] = true__;
		ModuleInstance__* prevInst__ = (s__)->inst__;
		(s__)->inst__ = caller__;
		List__Ptr__CallArg______* local10 = (callExpr__)->args__;
		Array__int____* local12 = (callExpr__)->calleeLocalIdToArgIndex__;
		uint__ local13 = (uint__)((inp__)->localId__);
		mu_____boundscheck(local13 < (uint__)local12->count__);
		uint__ local11 = (uint__)(((int__*)local12->dataPtr__)[local13]);
		mu_____boundscheck(local11 < (uint__)local10->count__);
		EmulatorOrderCalculator__expression__(s__, (((CallArg__**)local10->dataPtr__)[local11])->expr__);
		List__add__int____((s__)->evalOrder__, si__);
		(s__)->inst__ = prevInst__;
		Array__bool____* local14 = (s__)->done__;
		uint__ local15 = (uint__)(si__);
		mu_____boundscheck(local15 < (uint__)local14->count__);
		((bool__*)local14->dataPtr__)[local15] = true__;
	} else {
		Node__ local16;
		local16.dataPtr__ = (pointer__)((inp__)->name__);
		local16.id__ = local16.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		EmulatorOrderCalculator__logicLoop__(s__, local16);
	}
}
void__ EmulatorOrderCalculator__module__(EmulatorState__* s__, ModuleInstance__* inst__) {
	(s__)->inst__ = inst__;
	if ((((inst__)->def__)->blackboxKeyword__) == (null__)) {
		EmulatorOrderCalculator__block__(s__, ((inst__)->def__)->body__);
	} else {
		{
			List__Ptr__ModuleInputDef______* local0 = ((inst__)->def__)->inputs__;
			int__ local1 = 0;
			while (local1 < local0->count__) {
				ModuleInputDef__* inp__ = ((ModuleInputDef__**)(local0->dataPtr__))[local1];
				EmulatorOrderCalculator__input__(s__, inp__);
				local1 += 1;
			}
		}
	}
}
void__ EmulatorOrderCalculator__logicLoop__(EmulatorState__* s__, Node__ e__) {
	List__add__Error____((s__)->errors__, Error__at__((((s__)->inst__)->def__)->unit__, RangeFinder__find__(e__), mu_____string201));
}
int__ CheckedMath__addPositiveInt__(int__ x__, int__ y__) {
	if (((((int__maxValue__)) - ((x__)))) >= ((y__))) {
		return ((x__)) + ((y__));
	}
	mu_____abandon(-1);
	return 0;
}
ssize__ CheckedMath__mulPositiveSsize__(ssize__ x__, ssize__ y__) {
	if (!(top______32bit__)) {
		bool__ local0 = ((x__)) <= ((ssize__)(int__maxValue__));
		if (local0) {
			local0 = ((y__)) <= ((ssize__)(int__maxValue__));
		}
		if (local0) {
			return ((x__)) * ((y__));
		}
		if (((long__)(x__)) <= ((((long__maxValue__)) / ((long__)(y__))))) {
			return ((x__)) * ((y__));
		}
	} else {
		bool__ local1 = ((x__)) <= ((ssize__)(short__maxValue__));
		if (local1) {
			local1 = ((y__)) <= ((ssize__)(short__maxValue__));
		}
		if (local1) {
			return ((x__)) * ((y__));
		}
		if ((((int__)(x__))) <= ((((int__maxValue__)) / (((int__)(y__)))))) {
			return ((x__)) * ((y__));
		}
	}
	mu_____abandon(-1);
	return 0;
}
int__ CheckedMath__mulPositiveInt__(int__ x__, int__ y__) {
	bool__ local0 = ((x__)) <= ((int__)(short__maxValue__));
	if (local0) {
		local0 = ((y__)) <= ((int__)(short__maxValue__));
	}
	if (local0) {
		return ((x__)) * ((y__));
	}
	if (((x__)) <= ((((int__maxValue__)) / ((y__))))) {
		return ((x__)) * ((y__));
	}
	mu_____abandon(-1);
	return 0;
}
void__ EmulatorRunner__setInput__(EmulatorState__* s__, ModuleInstance__* inst__, string__ input__, ulong__ val__) {
	Array__int____* local0 = (inst__)->localState__;
	Node__ local2 = Map__get__string__Node____(((inst__)->def__)->symbols__, input__);
	mu_____checkedcast(local2.id__ == Node_____Ptr__ModuleInputDef____);
	uint__ local1 = (uint__)(((ModuleInputDef__*)(local2.dataPtr__))->localId__);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	int__ si__ = ((int__*)local0->dataPtr__)[local1];
	Value__ local3;
	memset(&local3, 0, sizeof(Value__));
	local3.kind__ = ValueKind__ulong___;
	local3.z__ = val__;
	EmulatorRunner__setSlot__(s__, si__, local3);
	Array__bool____* local4 = (s__)->started__;
	uint__ local5 = (uint__)(si__);
	mu_____boundscheck(local5 < (uint__)local4->count__);
	((bool__*)local4->dataPtr__)[local5] = true__;
	Array__bool____* local6 = (s__)->done__;
	uint__ local7 = (uint__)(si__);
	mu_____boundscheck(local7 < (uint__)local6->count__);
	((bool__*)local6->dataPtr__)[local7] = true__;
}
Value__ EmulatorRunner__swizzle__(EmulatorState__* s__, Value__ target__, int__ targetWidth__, int__ seqSize__, int__ readStep__, int__ blockSize__) {
	Array__byte____ data__ = EmulatorRunner__unpackAsArray__(&(target__));
	Array__byte____* local0 = (Array__byte____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__byte____));
	*local0 = Array__cons__byte____(((targetWidth__)) / ((8)));
	Array__byte____* result__ = local0;
	int__ blocks__ = ((targetWidth__)) / ((blockSize__));
	int__ cycles__ = ((readStep__)) / ((seqSize__));
	int__ stepsPerCycle__ = ((blockSize__)) / ((readStep__));
	int__ w__ = 0;
	{
		int__ b__ = 0;
		while (((b__)) < ((blocks__))) {
			{
				int__ i__ = 0;
				while (((i__)) < ((cycles__))) {
					{
						int__ j__ = 0;
						while (((j__)) < ((stepsPerCycle__))) {
							int__ r__ = ((((((b__)) * ((blockSize__)))) + ((((i__)) * ((seqSize__)))))) + ((((j__)) * ((readStep__))));
							{
								int__ k__ = 0;
								while (((k__)) < ((seqSize__))) {
									int__ readIndex__ = ((int__)r__) >> (3);
									int__ local1;
									if (((readIndex__)) < (((data__).count__))) {
										Array__byte____* local2 = &(data__);
										uint__ local3 = (uint__)(readIndex__);
										mu_____boundscheck(local3 < (uint__)local2->count__);
										local1 = (int__)(((byte__*)local2->dataPtr__)[local3]);
									} else {
										local1 = 0;
									}
									int__ readByte__ = local1;
									int__ readMask__ = ((int__)1) << (((r__)) & ((7)));
									if (((((readByte__)) & ((readMask__)))) != ((0))) {
										int__ writeMask__ = ((int__)1) << (((w__)) & ((7)));
										Array__byte____* local4 = result__;
										uint__ local5 = (uint__)(((int__)w__) >> (3));
										mu_____boundscheck(local5 < (uint__)local4->count__);
										Array__byte____* local6 = result__;
										uint__ local7 = (uint__)(((int__)w__) >> (3));
										mu_____boundscheck(local7 < (uint__)local6->count__);
										((byte__*)local4->dataPtr__)[local5] = (byte__)(((int__)(((byte__*)local6->dataPtr__)[local7])) | ((writeMask__)));
									}
									r__ = ((r__)) + ((1));
									w__ = ((w__)) + ((1));
									k__ += 1;
								}
							}
							j__ += 1;
						}
					}
					i__ += 1;
				}
			}
			b__ += 1;
		}
	}
	mu_____assert(((w__)) == ((targetWidth__)));
	Value__ local8;
	if (((targetWidth__)) > ((64))) {
		local8 = EmulatorRunner__packArray__(result__);
	} else {
		local8 = EmulatorRunner__packULong__(result__);
	}
	return local8;
}
Array__byte____* EmulatorRunner__unpackArray__(Value__ v__) {
	mu_____assert(((v__).kind__) == (ValueKind__byteArray__));
	return (Array__byte____*)((v__).z__);
}
void__ EmulatorRunner__run__(EmulatorState__* s__, List__Instruction____* program__) {
	List__Value____* stack__ = (s__)->stack__;
	mu_____assert((((stack__)->count__)) == ((0)));
	int__ pc__ = 0;
	while (true__) {
		if (!(((pc__)) < (((program__)->count__)))) { break; }
		List__Instruction____* local0 = program__;
		uint__ local1 = (uint__)(pc__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		Instruction__ ins__ = ((Instruction__*)local0->dataPtr__)[local1];
		int__ top__ = (((stack__)->count__)) - ((1));
		int__ lhs__ = (((stack__)->count__)) - ((2));
		if (((ins__).op__) == (Opcode__dup__)) {
			List__Value____* local2 = stack__;
			uint__ local3 = (uint__)(top__);
			mu_____boundscheck(local3 < (uint__)local2->count__);
			List__add__Value____(stack__, ((Value__*)local2->dataPtr__)[local3]);
		} else {
			if (((ins__).op__) == (Opcode__discard__)) {
				List__setCountChecked__Value____(stack__, top__);
			} else {
				if (((ins__).op__) == (Opcode__push__)) {
					Value__ local4;
					memset(&local4, 0, sizeof(Value__));
					local4.kind__ = ValueKind__ulong___;
					local4.z__ = (ins__).z__;
					List__add__Value____(stack__, local4);
				} else {
					if (((ins__).op__) == (Opcode__pushArray__)) {
						Value__ local5;
						memset(&local5, 0, sizeof(Value__));
						local5.kind__ = ValueKind__byteArray__;
						local5.z__ = (ins__).z__;
						List__add__Value____(stack__, local5);
					} else {
						if (((ins__).op__) == (Opcode__load__)) {
							List__Value____* local6 = (s__)->rs__;
							uint__ local7 = (uint__)((uint__)((ins__).z__));
							mu_____boundscheck(local7 < (uint__)local6->count__);
							List__add__Value____(stack__, ((Value__*)local6->dataPtr__)[local7]);
						} else {
							if (((ins__).op__) == (Opcode__store__)) {
								List__Value____* local8 = stack__;
								uint__ local9 = (uint__)(top__);
								mu_____boundscheck(local9 < (uint__)local8->count__);
								EmulatorRunner__setSlot__(s__, (int__)((ins__).z__), ((Value__*)local8->dataPtr__)[local9]);
								List__setCountChecked__Value____(stack__, top__);
							} else {
								if (((ins__).op__) == (Opcode__mask__)) {
									List__Value____* local10 = stack__;
									uint__ local11 = (uint__)(top__);
									mu_____boundscheck(local11 < (uint__)local10->count__);
									mu_____assert(((((Value__*)local10->dataPtr__)[local11]).kind__) == (ValueKind__ulong___));
									List__Value____* local12 = stack__;
									uint__ local13 = (uint__)(top__);
									mu_____boundscheck(local13 < (uint__)local12->count__);
									List__Value____* local14 = stack__;
									uint__ local15 = (uint__)(top__);
									mu_____boundscheck(local15 < (uint__)local14->count__);
									(((Value__*)local12->dataPtr__)[local13]).z__ = (((((Value__*)local14->dataPtr__)[local15]).z__)) & (((ins__).z__));
								} else {
									if (((ins__).op__) == (Opcode__index__)) {
										ulong__ shr__ = ((ulong__)(ins__).z__) >> (32);
										ulong__ mask__ = ((((ulong__)1uLL) << ((((ins__).z__)) & ((4294967295uLL))))) - ((ulong__)(1));
										List__Value____* local16 = stack__;
										uint__ local17 = (uint__)(top__);
										mu_____boundscheck(local17 < (uint__)local16->count__);
										List__Value____* local18 = stack__;
										uint__ local19 = (uint__)(top__);
										mu_____boundscheck(local19 < (uint__)local18->count__);
										(((Value__*)local16->dataPtr__)[local17]).z__ = ((((ulong__)EmulatorRunner__unpack__(((Value__*)local18->dataPtr__)[local19])) >> (shr__))) & ((mask__));
									} else {
										if (((ins__).op__) == (Opcode__shlOr__)) {
											List__Value____* local20 = stack__;
											uint__ local21 = (uint__)(lhs__);
											mu_____boundscheck(local21 < (uint__)local20->count__);
											List__Value____* local22 = stack__;
											uint__ local23 = (uint__)(top__);
											mu_____boundscheck(local23 < (uint__)local22->count__);
											EmulatorRunner__binaryOperator__(s__, stack__, ((((ulong__)EmulatorRunner__unpack__(((Value__*)local20->dataPtr__)[local21])) << ((ins__).z__))) | ((EmulatorRunner__unpack__(((Value__*)local22->dataPtr__)[local23]))));
										} else {
											if (((ins__).op__) == (Opcode__jumpIfZero__)) {
												List__Value____* local24 = stack__;
												uint__ local25 = (uint__)(top__);
												mu_____boundscheck(local25 < (uint__)local24->count__);
												if ((((((Value__*)local24->dataPtr__)[local25]).z__)) == ((ulong__)(0))) {
													pc__ = ((pc__)) + (((int__)((ins__).z__)));
												}
												List__setCountChecked__Value____(stack__, top__);
											} else {
												if (((ins__).op__) == (Opcode__jump__)) {
													pc__ = ((pc__)) + (((int__)((ins__).z__)));
												} else {
													if (((ins__).op__) == (Opcode__neg__)) {
														List__Value____* local26 = stack__;
														uint__ local27 = (uint__)(top__);
														mu_____boundscheck(local27 < (uint__)local26->count__);
														List__Value____* local28 = stack__;
														uint__ local29 = (uint__)(top__);
														mu_____boundscheck(local29 < (uint__)local28->count__);
														(((Value__*)local26->dataPtr__)[local27]).z__ = -(EmulatorRunner__unpack__(((Value__*)local28->dataPtr__)[local29]));
													} else {
														if (((ins__).op__) == (Opcode__invert__)) {
															List__Value____* local30 = stack__;
															uint__ local31 = (uint__)(top__);
															mu_____boundscheck(local31 < (uint__)local30->count__);
															List__Value____* local32 = stack__;
															uint__ local33 = (uint__)(top__);
															mu_____boundscheck(local33 < (uint__)local32->count__);
															(((Value__*)local30->dataPtr__)[local31]).z__ = ~(EmulatorRunner__unpack__(((Value__*)local32->dataPtr__)[local33]));
														} else {
															if (((ins__).op__) == (Opcode__add__)) {
																List__Value____* local34 = stack__;
																uint__ local35 = (uint__)(lhs__);
																mu_____boundscheck(local35 < (uint__)local34->count__);
																List__Value____* local36 = stack__;
																uint__ local37 = (uint__)(top__);
																mu_____boundscheck(local37 < (uint__)local36->count__);
																EmulatorRunner__binaryOperator__(s__, stack__, ((EmulatorRunner__unpack__(((Value__*)local34->dataPtr__)[local35]))) + ((EmulatorRunner__unpack__(((Value__*)local36->dataPtr__)[local37]))));
															} else {
																if (((ins__).op__) == (Opcode__sub__)) {
																	List__Value____* local38 = stack__;
																	uint__ local39 = (uint__)(lhs__);
																	mu_____boundscheck(local39 < (uint__)local38->count__);
																	List__Value____* local40 = stack__;
																	uint__ local41 = (uint__)(top__);
																	mu_____boundscheck(local41 < (uint__)local40->count__);
																	EmulatorRunner__binaryOperator__(s__, stack__, ((EmulatorRunner__unpack__(((Value__*)local38->dataPtr__)[local39]))) - ((EmulatorRunner__unpack__(((Value__*)local40->dataPtr__)[local41]))));
																} else {
																	if (((ins__).op__) == (Opcode__and__)) {
																		List__Value____* local42 = stack__;
																		uint__ local43 = (uint__)(lhs__);
																		mu_____boundscheck(local43 < (uint__)local42->count__);
																		List__Value____* local44 = stack__;
																		uint__ local45 = (uint__)(top__);
																		mu_____boundscheck(local45 < (uint__)local44->count__);
																		EmulatorRunner__binaryOperator__(s__, stack__, ((EmulatorRunner__unpack__(((Value__*)local42->dataPtr__)[local43]))) & ((EmulatorRunner__unpack__(((Value__*)local44->dataPtr__)[local45]))));
																	} else {
																		if (((ins__).op__) == (Opcode__or__)) {
																			List__Value____* local46 = stack__;
																			uint__ local47 = (uint__)(lhs__);
																			mu_____boundscheck(local47 < (uint__)local46->count__);
																			List__Value____* local48 = stack__;
																			uint__ local49 = (uint__)(top__);
																			mu_____boundscheck(local49 < (uint__)local48->count__);
																			EmulatorRunner__binaryOperator__(s__, stack__, ((EmulatorRunner__unpack__(((Value__*)local46->dataPtr__)[local47]))) | ((EmulatorRunner__unpack__(((Value__*)local48->dataPtr__)[local49]))));
																		} else {
																			if (((ins__).op__) == (Opcode__xor__)) {
																				List__Value____* local50 = stack__;
																				uint__ local51 = (uint__)(lhs__);
																				mu_____boundscheck(local51 < (uint__)local50->count__);
																				List__Value____* local52 = stack__;
																				uint__ local53 = (uint__)(top__);
																				mu_____boundscheck(local53 < (uint__)local52->count__);
																				EmulatorRunner__binaryOperator__(s__, stack__, ((EmulatorRunner__unpack__(((Value__*)local50->dataPtr__)[local51]))) ^ ((EmulatorRunner__unpack__(((Value__*)local52->dataPtr__)[local53]))));
																			} else {
																				if (((ins__).op__) == (Opcode__mul__)) {
																					List__Value____* local54 = stack__;
																					uint__ local55 = (uint__)(lhs__);
																					mu_____boundscheck(local55 < (uint__)local54->count__);
																					List__Value____* local56 = stack__;
																					uint__ local57 = (uint__)(top__);
																					mu_____boundscheck(local57 < (uint__)local56->count__);
																					EmulatorRunner__binaryOperator__(s__, stack__, ((EmulatorRunner__unpack__(((Value__*)local54->dataPtr__)[local55]))) * ((EmulatorRunner__unpack__(((Value__*)local56->dataPtr__)[local57]))));
																				} else {
																					if (((ins__).op__) == (Opcode__eq__)) {
																						ulong__ local58;
																						List__Value____* local59 = stack__;
																						uint__ local60 = (uint__)(lhs__);
																						mu_____boundscheck(local60 < (uint__)local59->count__);
																						List__Value____* local61 = stack__;
																						uint__ local62 = (uint__)(top__);
																						mu_____boundscheck(local62 < (uint__)local61->count__);
																						if (((EmulatorRunner__unpack__(((Value__*)local59->dataPtr__)[local60]))) == ((EmulatorRunner__unpack__(((Value__*)local61->dataPtr__)[local62])))) {
																							local58 = 1uLL;
																						} else {
																							local58 = (ulong__)(0);
																						}
																						EmulatorRunner__binaryOperator__(s__, stack__, local58);
																					} else {
																						if (((ins__).op__) == (Opcode__neq__)) {
																							ulong__ local63;
																							List__Value____* local64 = stack__;
																							uint__ local65 = (uint__)(lhs__);
																							mu_____boundscheck(local65 < (uint__)local64->count__);
																							List__Value____* local66 = stack__;
																							uint__ local67 = (uint__)(top__);
																							mu_____boundscheck(local67 < (uint__)local66->count__);
																							if (((EmulatorRunner__unpack__(((Value__*)local64->dataPtr__)[local65]))) != ((EmulatorRunner__unpack__(((Value__*)local66->dataPtr__)[local67])))) {
																								local63 = 1uLL;
																							} else {
																								local63 = (ulong__)(0);
																							}
																							EmulatorRunner__binaryOperator__(s__, stack__, local63);
																						} else {
																							if (((ins__).op__) == (Opcode__lte__)) {
																								ulong__ local68;
																								List__Value____* local69 = stack__;
																								uint__ local70 = (uint__)(lhs__);
																								mu_____boundscheck(local70 < (uint__)local69->count__);
																								List__Value____* local71 = stack__;
																								uint__ local72 = (uint__)(top__);
																								mu_____boundscheck(local72 < (uint__)local71->count__);
																								if (((EmulatorRunner__unpack__(((Value__*)local69->dataPtr__)[local70]))) <= ((EmulatorRunner__unpack__(((Value__*)local71->dataPtr__)[local72])))) {
																									local68 = 1uLL;
																								} else {
																									local68 = (ulong__)(0);
																								}
																								EmulatorRunner__binaryOperator__(s__, stack__, local68);
																							} else {
																								if (((ins__).op__) == (Opcode__lt__)) {
																									ulong__ local73;
																									List__Value____* local74 = stack__;
																									uint__ local75 = (uint__)(lhs__);
																									mu_____boundscheck(local75 < (uint__)local74->count__);
																									List__Value____* local76 = stack__;
																									uint__ local77 = (uint__)(top__);
																									mu_____boundscheck(local77 < (uint__)local76->count__);
																									if (((EmulatorRunner__unpack__(((Value__*)local74->dataPtr__)[local75]))) < ((EmulatorRunner__unpack__(((Value__*)local76->dataPtr__)[local77])))) {
																										local73 = 1uLL;
																									} else {
																										local73 = (ulong__)(0);
																									}
																									EmulatorRunner__binaryOperator__(s__, stack__, local73);
																								} else {
																									if (((ins__).op__) == (Opcode__gte__)) {
																										ulong__ local78;
																										List__Value____* local79 = stack__;
																										uint__ local80 = (uint__)(lhs__);
																										mu_____boundscheck(local80 < (uint__)local79->count__);
																										List__Value____* local81 = stack__;
																										uint__ local82 = (uint__)(top__);
																										mu_____boundscheck(local82 < (uint__)local81->count__);
																										if (((EmulatorRunner__unpack__(((Value__*)local79->dataPtr__)[local80]))) >= ((EmulatorRunner__unpack__(((Value__*)local81->dataPtr__)[local82])))) {
																											local78 = 1uLL;
																										} else {
																											local78 = (ulong__)(0);
																										}
																										EmulatorRunner__binaryOperator__(s__, stack__, local78);
																									} else {
																										if (((ins__).op__) == (Opcode__gt__)) {
																											ulong__ local83;
																											List__Value____* local84 = stack__;
																											uint__ local85 = (uint__)(lhs__);
																											mu_____boundscheck(local85 < (uint__)local84->count__);
																											List__Value____* local86 = stack__;
																											uint__ local87 = (uint__)(top__);
																											mu_____boundscheck(local87 < (uint__)local86->count__);
																											if (((EmulatorRunner__unpack__(((Value__*)local84->dataPtr__)[local85]))) > ((EmulatorRunner__unpack__(((Value__*)local86->dataPtr__)[local87])))) {
																												local83 = 1uLL;
																											} else {
																												local83 = (ulong__)(0);
																											}
																											EmulatorRunner__binaryOperator__(s__, stack__, local83);
																										} else {
																											if (((ins__).op__) == (Opcode__shl__)) {
																												List__Value____* local88 = stack__;
																												uint__ local89 = (uint__)(lhs__);
																												mu_____boundscheck(local89 < (uint__)local88->count__);
																												List__Value____* local90 = stack__;
																												uint__ local91 = (uint__)(top__);
																												mu_____boundscheck(local91 < (uint__)local90->count__);
																												EmulatorRunner__binaryOperator__(s__, stack__, ((ulong__)EmulatorRunner__unpack__(((Value__*)local88->dataPtr__)[local89])) << (EmulatorRunner__unpack__(((Value__*)local90->dataPtr__)[local91])));
																											} else {
																												if (((ins__).op__) == (Opcode__shr__)) {
																													List__Value____* local92 = stack__;
																													uint__ local93 = (uint__)(lhs__);
																													mu_____boundscheck(local93 < (uint__)local92->count__);
																													List__Value____* local94 = stack__;
																													uint__ local95 = (uint__)(top__);
																													mu_____boundscheck(local95 < (uint__)local94->count__);
																													EmulatorRunner__binaryOperator__(s__, stack__, ((ulong__)EmulatorRunner__unpack__(((Value__*)local92->dataPtr__)[local93])) >> (EmulatorRunner__unpack__(((Value__*)local94->dataPtr__)[local95])));
																												} else {
																													if (((ins__).op__) == (Opcode__slice__)) {
																														List__Value____* local96 = stack__;
																														uint__ local97 = (uint__)((((stack__)->count__)) - ((3)));
																														mu_____boundscheck(local97 < (uint__)local96->count__);
																														List__Value____* local98 = stack__;
																														uint__ local99 = (uint__)(lhs__);
																														mu_____boundscheck(local99 < (uint__)local98->count__);
																														List__Value____* local100 = stack__;
																														uint__ local101 = (uint__)(top__);
																														mu_____boundscheck(local101 < (uint__)local100->count__);
																														Value__ value__ = EmulatorRunner__slice__(s__, ((Value__*)local96->dataPtr__)[local97], (ins__).z__, EmulatorRunner__unpack__(((Value__*)local98->dataPtr__)[local99]), EmulatorRunner__unpack__(((Value__*)local100->dataPtr__)[local101]));
																														List__setCountChecked__Value____(stack__, (((stack__)->count__)) - ((3)));
																														List__add__Value____(stack__, value__);
																													} else {
																														if (((ins__).op__) == (Opcode__storeSlice__)) {
																															List__Value____* local102 = stack__;
																															uint__ local103 = (uint__)((((stack__)->count__)) - ((3)));
																															mu_____boundscheck(local103 < (uint__)local102->count__);
																															List__Value____* local104 = stack__;
																															uint__ local105 = (uint__)(lhs__);
																															mu_____boundscheck(local105 < (uint__)local104->count__);
																															List__Value____* local106 = stack__;
																															uint__ local107 = (uint__)(top__);
																															mu_____boundscheck(local107 < (uint__)local106->count__);
																															EmulatorRunner__storeSlice__(s__, (int__)((ins__).z__), EmulatorRunner__unpack__(((Value__*)local102->dataPtr__)[local103]), EmulatorRunner__unpack__(((Value__*)local104->dataPtr__)[local105]), ((Value__*)local106->dataPtr__)[local107]);
																															List__setCountChecked__Value____(stack__, (((stack__)->count__)) - ((3)));
																														} else {
																															if (((ins__).op__) == (Opcode__swizzle__)) {
																																List__Value____* local108 = stack__;
																																uint__ local109 = (uint__)((((stack__)->count__)) - ((5)));
																																mu_____boundscheck(local109 < (uint__)local108->count__);
																																List__Value____* local110 = stack__;
																																uint__ local111 = (uint__)((((stack__)->count__)) - ((4)));
																																mu_____boundscheck(local111 < (uint__)local110->count__);
																																List__Value____* local112 = stack__;
																																uint__ local113 = (uint__)((((stack__)->count__)) - ((3)));
																																mu_____boundscheck(local113 < (uint__)local112->count__);
																																List__Value____* local114 = stack__;
																																uint__ local115 = (uint__)(lhs__);
																																mu_____boundscheck(local115 < (uint__)local114->count__);
																																List__Value____* local116 = stack__;
																																uint__ local117 = (uint__)(top__);
																																mu_____boundscheck(local117 < (uint__)local116->count__);
																																Value__ value__ = EmulatorRunner__swizzle__(s__, ((Value__*)local108->dataPtr__)[local109], (int__)(EmulatorRunner__unpack__(((Value__*)local110->dataPtr__)[local111])), (int__)(EmulatorRunner__unpack__(((Value__*)local112->dataPtr__)[local113])), (int__)(EmulatorRunner__unpack__(((Value__*)local114->dataPtr__)[local115])), (int__)(EmulatorRunner__unpack__(((Value__*)local116->dataPtr__)[local117])));
																																List__setCountChecked__Value____(stack__, (((stack__)->count__)) - ((5)));
																																List__add__Value____(stack__, value__);
																															} else {
																																mu_____abandon(-1);
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		pc__ = ((pc__)) + ((1));
	}
	mu_____assert((((stack__)->count__)) == ((0)));
}
void__ EmulatorRunner__binaryOperator__(EmulatorState__* s__, List__Value____* stack__, ulong__ result__) {
	List__Value____* local0 = stack__;
	uint__ local1 = (uint__)((((stack__)->count__)) - ((2)));
	mu_____boundscheck(local1 < (uint__)local0->count__);
	(((Value__*)local0->dataPtr__)[local1]).z__ = result__;
	List__setCountChecked__Value____(stack__, (((stack__)->count__)) - ((1)));
}
void__ EmulatorRunner__copyToArray__(Value__ v__, Value__* dest__) {
	mu_____assert(((dest__)->kind__) == (ValueKind__byteArray__));
	Array__byte____* to__ = (Array__byte____*)((dest__)->z__);
	if (((v__).kind__) == (ValueKind__ulong___)) {
		Array__clearValues__byte____(to__);
		int__ local0 = (to__)->count__;
		int__ local1 = sizeof(ulong__);
		memcpy((to__)->dataPtr__, (pointer__)(&((v__).z__)), (usize__)((uint__)((local0 < local1) ? local0 : local1)));
	} else {
		if (((v__).kind__) == (ValueKind__byteArray__)) {
			Array__byte____* from__ = (Array__byte____*)((v__).z__);
			if ((from__) != (to__)) {
				Array__copySlice__byte____(from__, 0, (from__)->count__, to__, 0);
				Array__byte____ local2 = Array__slice__byte____(to__, (from__)->count__, (to__)->count__);
				Array__clearValues__byte____(&local2);
			}
		} else {
			mu_____abandon(-1);
		}
	}
}
void__ EmulatorRunner__setSlot__(EmulatorState__* s__, int__ si__, Value__ val__) {
	if (((si__)) < ((((s__)->ws__)->count__))) {
		List__Value____* local0 = (s__)->ws__;
		uint__ local1 = (uint__)(si__);
		mu_____boundscheck(local1 < (uint__)local0->count__);
		Value__* dest__ = &(((Value__*)local0->dataPtr__)[local1]);
		if (((dest__)->kind__) == (ValueKind__ulong___)) {
			(dest__)->z__ = EmulatorRunner__unpackAsULong__(val__);
		} else {
			if (((dest__)->kind__) == (ValueKind__byteArray__)) {
				EmulatorRunner__copyToArray__(val__, dest__);
			} else {
				mu_____abandon(-1);
			}
		}
	} else {
		bool__ local2 = ((val__).kind__) == (ValueKind__ulong___);
		if (!local2) {
			local2 = ((val__).kind__) == (ValueKind__byteArray__);
		}
		mu_____assert(local2);
		List__Value____* local3 = (s__)->rs__;
		uint__ local4 = (uint__)(si__);
		mu_____boundscheck(local4 < (uint__)local3->count__);
		((Value__*)local3->dataPtr__)[local4] = val__;
	}
}
Value__ EmulatorRunner__slice__(EmulatorState__* s__, Value__ target__, ulong__ targetWidth__, ulong__ offset__, ulong__ width__) {
	if (((width__)) > ((ulong__)(64))) {
		return EmulatorRunner__bigSlice__(s__, target__, targetWidth__, offset__, width__);
	}
	Array__byte____ data__ = EmulatorRunner__unpackAsArray__(&(target__));
	int__ local1 = (data__).count__;
	mu_____checkedcast(0 <= local1);
	ulong__ local0 = (((ulong__)(local1))) * ((ulong__)(8));
	ulong__ local2 = targetWidth__;
	ulong__ dataWidth__ = (local0 < local2) ? local0 : local2;
	Value__ local3;
	memset(&local3, 0, sizeof(Value__));
	local3.kind__ = ValueKind__ulong___;
	Value__ result__ = local3;
	ulong__ to__ = offset__;
	ulong__ local4 = ((offset__)) + ((width__));
	ulong__ local5 = dataWidth__;
	offset__ = (local4 < local5) ? local4 : local5;
	while (true__) {
		if (!(((offset__)) > ((to__)))) { break; }
		offset__ = ((offset__)) - ((ulong__)(1));
		(result__).z__ = ((ulong__)(result__).z__) << (1);
		uint__ index__ = (uint__)(((ulong__)offset__) >> (3));
		int__ mask__ = ((int__)1) << (((offset__)) & ((ulong__)(7)));
		Array__byte____* local6 = &(data__);
		uint__ local7 = (uint__)(index__);
		mu_____boundscheck(local7 < (uint__)local6->count__);
		if (((((int__)(((byte__*)local6->dataPtr__)[local7])) & ((mask__)))) != ((0))) {
			(result__).z__ = (((result__).z__)) | ((ulong__)(1));
		}
	}
	return result__;
}
ulong__ EmulatorRunner__unpack__(Value__ v__) {
	mu_____assert(((v__).kind__) == (ValueKind__ulong___));
	return (v__).z__;
}
ulong__ EmulatorRunner__unpackAsULong__(Value__ v__) {
	if (((v__).kind__) == (ValueKind__ulong___)) {
		return (v__).z__;
	} else {
		if (((v__).kind__) == (ValueKind__byteArray__)) {
			ulong__ z__ = 0uLL;
			Array__byte____* data__ = (Array__byte____*)((v__).z__);
			int__ local0 = (data__)->count__;
			int__ local1 = sizeof(ulong__);
			memcpy((pointer__)(&(z__)), (data__)->dataPtr__, (usize__)((uint__)((local0 < local1) ? local0 : local1)));
			return z__;
		} else {
			mu_____abandon(-1);
			return 0;
		}
	}
}
Value__ EmulatorRunner__packULong__(Array__byte____* data__) {
	ulong__ z__ = 0uLL;
	int__ local0 = (data__)->count__;
	int__ local1 = sizeof(ulong__);
	memcpy((pointer__)(&(z__)), (data__)->dataPtr__, (usize__)((uint__)((local0 < local1) ? local0 : local1)));
	Value__ local2;
	memset(&local2, 0, sizeof(Value__));
	local2.kind__ = ValueKind__ulong___;
	local2.z__ = z__;
	return local2;
}
void__ EmulatorRunner__storeSlice__(EmulatorState__* s__, int__ si__, ulong__ offset__, ulong__ width__, Value__ val__) {
	List__Value____* local0 = (s__)->ws__;
	uint__ local1 = (uint__)(si__);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	Value__* dest__ = &(((Value__*)local0->dataPtr__)[local1]);
	Array__byte____ data__ = EmulatorRunner__unpackAsArray__(dest__);
	ulong__ z__ = EmulatorRunner__unpackAsULong__(val__);
	int__ local3 = (((data__).count__)) * ((8));
	List__SlotInfo____* local5 = (s__)->infos__;
	uint__ local6 = (uint__)(si__);
	mu_____boundscheck(local6 < (uint__)local5->count__);
	int__ local4 = TypeChecker__unpackWidth__((((SlotInfo__*)local5->dataPtr__)[local6]).tag__);
	int__ local2 = (local3 < local4) ? local3 : local4;
	mu_____checkedcast(0 <= local2);
	ulong__ dataWidth__ = (ulong__)(local2);
	ulong__ local7 = ((offset__)) + ((width__));
	ulong__ local8 = dataWidth__;
	ulong__ to__ = (local7 < local8) ? local7 : local8;
	while (true__) {
		if (!(((offset__)) < ((to__)))) { break; }
		uint__ index__ = (uint__)(((ulong__)offset__) >> (3));
		int__ mask__ = ((int__)1) << (((offset__)) & ((ulong__)(7)));
		if (((((z__)) & ((ulong__)(1)))) == ((ulong__)(1))) {
			Array__byte____* local9 = &(data__);
			uint__ local10 = (uint__)(index__);
			mu_____boundscheck(local10 < (uint__)local9->count__);
			Array__byte____* local11 = &(data__);
			uint__ local12 = (uint__)(index__);
			mu_____boundscheck(local12 < (uint__)local11->count__);
			((byte__*)local9->dataPtr__)[local10] = (byte__)(((int__)(((byte__*)local11->dataPtr__)[local12])) | ((mask__)));
		} else {
			Array__byte____* local13 = &(data__);
			uint__ local14 = (uint__)(index__);
			mu_____boundscheck(local14 < (uint__)local13->count__);
			Array__byte____* local15 = &(data__);
			uint__ local16 = (uint__)(index__);
			mu_____boundscheck(local16 < (uint__)local15->count__);
			((byte__*)local13->dataPtr__)[local14] = (byte__)(((int__)(((byte__*)local15->dataPtr__)[local16])) & ((~(mask__))));
		}
		offset__ = ((offset__)) + ((ulong__)(1));
		z__ = ((ulong__)z__) >> (1);
	}
}
Value__ EmulatorRunner__bigSlice__(EmulatorState__* s__, Value__ target__, ulong__ targetWidth__, ulong__ offset__, ulong__ width__) {
	Array__byte____ data__ = EmulatorRunner__unpackAsArray__(&(target__));
	ulong__ size__ = (((ulong__)((data__).count__))) * ((ulong__)(8));
	ulong__ local0 = offset__;
	ulong__ local1 = size__;
	ulong__ from__ = (local0 < local1) ? local0 : local1;
	ulong__ local2 = ((offset__)) + ((width__));
	ulong__ local3 = size__;
	ulong__ to__ = (local2 < local3) ? local2 : local3;
	int__ fromByte__ = (int__)(((from__)) / ((ulong__)(8)));
	int__ toByte__ = (int__)(((((to__)) + ((ulong__)(7)))) / ((ulong__)(8)));
	ulong__ fromBit__ = ((from__)) % ((ulong__)(8));
	ulong__ toBit__ = ((to__)) % ((ulong__)(8));
	bool__ local5 = ((fromBit__)) == ((ulong__)(0));
	if (local5) {
		local5 = ((toBit__)) == ((ulong__)(0));
	}
	bool__ local4 = local5;
	if (local4) {
		local4 = ((target__).kind__) == (ValueKind__byteArray__);
	}
	if (local4) {
		Array__byte____* local6 = (Array__byte____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__byte____));
		*local6 = Array__slice__byte____(EmulatorRunner__unpackArray__(target__), fromByte__, toByte__);
		return EmulatorRunner__packArray__(local6);
	}
	int__ count__ = ((toByte__)) - ((fromByte__));
	Array__byte____* local7 = (Array__byte____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Array__byte____));
	*local7 = Array__cons__byte____(count__);
	Array__byte____* result__ = local7;
	Array__copySlice__byte____(&(data__), 0, count__, result__, 0);
	Util__shlArray__(result__, (int__)(fromBit__));
	return EmulatorRunner__packArray__(result__);
}
Array__byte____ EmulatorRunner__unpackAsArray__(Value__* v__) {
	if (((v__)->kind__) == (ValueKind__ulong___)) {
		Array__byte____ local0;
		memset(&local0, 0, sizeof(Array__byte____));
		local0.dataPtr__ = (pointer__)(&((v__)->z__));
		local0.count__ = 8;
		return local0;
	} else {
		if (((v__)->kind__) == (ValueKind__byteArray__)) {
			return *((Array__byte____*)((v__)->z__));
		} else {
			mu_____abandon(-1);
			Array__byte____ local1;
			memset(&local1, 0, sizeof(Array__byte____));
			return local1;
		}
	}
}
Value__ EmulatorRunner__packArray__(Array__byte____* data__) {
	Value__ local0;
	memset(&local0, 0, sizeof(Value__));
	local0.kind__ = ValueKind__byteArray__;
	local0.z__ = (ulong__)(uintptr_t)((pointer__)(data__));
	return local0;
}
uint__ NodeWithCtx__hash__(NodeWithCtx__ self__) {
	return (((((uint__)(uintptr_t)((pointer__)(((self__).node__).dataPtr__)))) ^ ((((uint__)(uint__)((self__).ctxOutput__)) << (25))))) ^ (((uint__)((self__).ctxField__)));
}
bool__ NodeWithCtx__equals__(NodeWithCtx__ a__, NodeWithCtx__ b__) {
	bool__ local1 = (((a__).node__).dataPtr__) == (((b__).node__).dataPtr__);
	if (local1) {
		local1 = (((a__).ctxOutput__)) == (((b__).ctxOutput__));
	}
	bool__ local0 = local1;
	if (local0) {
		local0 = (((a__).ctxField__)) == (((b__).ctxField__));
	}
	return local0;
}
void__ Stdout__write__(string__ s__) {
	printf((cstring__)((mu_____string6).dataPtr__), (s__).length__, (s__).dataPtr__);
}
void__ Stdout__writeLine__(string__ s__) {
	printf((cstring__)((mu_____string7).dataPtr__), (s__).length__, (s__).dataPtr__);
}
Array__byte____ Array__slice__byte____(Array__byte____* this__, int__ from__, int__ to__) {
	bool__ local1 = ((0)) <= ((from__));
	if (local1) {
		local1 = ((from__)) <= ((to__));
	}
	bool__ local0 = local1;
	if (local0) {
		local0 = ((to__)) <= (((this__)->count__));
	}
	mu_____assert(local0);
	Array__byte____ local2;
	memset(&local2, 0, sizeof(Array__byte____));
	local2.dataPtr__ = ((this__)->dataPtr__) + ((((ssize__)(from__))) * ((ssize__)(sizeof(byte__))));
	local2.count__ = ((to__)) - ((from__));
	return local2;
}
void__ Array__stableSort__Error____(Array__Error____* items__, fun__Error__Error__int____ compareFn__) {
	if ((((items__)->count__)) <= ((1))) {
		return;
	}
	mu_____assert((((items__)->count__)) < ((((int__)1) << (30))));
	int__ count__ = (items__)->count__;
	{
		int__ i__ = 0;
		while (((i__)) < ((((((count__)) / ((2)))) * ((2))))) {
			Array__Error____* local0 = items__;
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->count__);
			Array__Error____* local2 = items__;
			uint__ local3 = (uint__)(((i__)) + ((1)));
			mu_____boundscheck(local3 < (uint__)local2->count__);
			if (((compareFn__(((Error__*)local0->dataPtr__)[local1], ((Error__*)local2->dataPtr__)[local3]))) > ((0))) {
				Array__Error____* local4 = items__;
				uint__ local5 = (uint__)(i__);
				mu_____boundscheck(local5 < (uint__)local4->count__);
				Error__ temp__ = ((Error__*)local4->dataPtr__)[local5];
				Array__Error____* local6 = items__;
				uint__ local7 = (uint__)(i__);
				mu_____boundscheck(local7 < (uint__)local6->count__);
				Array__Error____* local8 = items__;
				uint__ local9 = (uint__)(((i__)) + ((1)));
				mu_____boundscheck(local9 < (uint__)local8->count__);
				((Error__*)local6->dataPtr__)[local7] = ((Error__*)local8->dataPtr__)[local9];
				Array__Error____* local10 = items__;
				uint__ local11 = (uint__)(((i__)) + ((1)));
				mu_____boundscheck(local11 < (uint__)local10->count__);
				((Error__*)local10->dataPtr__)[local11] = temp__;
			}
			i__ = ((i__)) + ((2));
		}
	}
	Array__Error____* src__ = items__;
	Array__Error____ local12 = Array__cons__Error____(count__);
	Array__Error____* dest__ = &local12;
	int__ chunk__ = 2;
	while (true__) {
		if (!(((chunk__)) < ((count__)))) { break; }
		int__ step__ = ((chunk__)) * ((2));
		{
			int__ i__ = 0;
			while (((i__)) < ((count__))) {
				Array__stableSortMerge___Error____(src__, dest__, i__, chunk__, compareFn__);
				i__ = ((i__)) + ((step__));
			}
		}
		chunk__ = ((chunk__)) * ((2));
		Array__Error____* temp__ = src__;
		src__ = dest__;
		dest__ = temp__;
	}
	if ((items__) != (src__)) {
		Array__copySlice__Error____(src__, 0, count__, items__, 0);
	}
}
Array__IntRange____ Array__cons__IntRange____(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(IntRange__)));
	Array__IntRange____ local0;
	memset(&local0, 0, sizeof(Array__IntRange____));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__IntRange____ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
Array__Error____ Array__cons__Error____(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(Error__)));
	Array__Error____ local0;
	memset(&local0, 0, sizeof(Array__Error____));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__Error____ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
Array__int____ Array__cons__int____(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(int__)));
	Array__int____ local0;
	memset(&local0, 0, sizeof(Array__int____));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__int____ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
Array__byte____ Array__cons__byte____(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(byte__)));
	Array__byte____ local0;
	memset(&local0, 0, sizeof(Array__byte____));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__byte____ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
Array__SetEntry__string______ Array__cons__SetEntry__string______(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(SetEntry__string____)));
	Array__SetEntry__string______ local0;
	memset(&local0, 0, sizeof(Array__SetEntry__string______));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__SetEntry__string______ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
Array__MapEntry__NodeWithCtx__string______ Array__cons__MapEntry__NodeWithCtx__string______(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(MapEntry__NodeWithCtx__string____)));
	Array__MapEntry__NodeWithCtx__string______ local0;
	memset(&local0, 0, sizeof(Array__MapEntry__NodeWithCtx__string______));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__MapEntry__NodeWithCtx__string______ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
Array__MapEntry__Node__Value______ Array__cons__MapEntry__Node__Value______(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(MapEntry__Node__Value____)));
	Array__MapEntry__Node__Value______ local0;
	memset(&local0, 0, sizeof(Array__MapEntry__Node__Value______));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__MapEntry__Node__Value______ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
Array__MapEntry__Node__Tag______ Array__cons__MapEntry__Node__Tag______(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(MapEntry__Node__Tag____)));
	Array__MapEntry__Node__Tag______ local0;
	memset(&local0, 0, sizeof(Array__MapEntry__Node__Tag______));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__MapEntry__Node__Tag______ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
Array__MapEntry__Node__int______ Array__cons__MapEntry__Node__int______(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(MapEntry__Node__int____)));
	Array__MapEntry__Node__int______ local0;
	memset(&local0, 0, sizeof(Array__MapEntry__Node__int______));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__MapEntry__Node__int______ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
Array__MapEntry__string__Node______ Array__cons__MapEntry__string__Node______(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(MapEntry__string__Node____)));
	Array__MapEntry__string__Node______ local0;
	memset(&local0, 0, sizeof(Array__MapEntry__string__Node______));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__MapEntry__string__Node______ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
Array__MapEntry__string__Ptr__FieldDef________ Array__cons__MapEntry__string__Ptr__FieldDef________(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(MapEntry__string__Ptr__FieldDef______)));
	Array__MapEntry__string__Ptr__FieldDef________ local0;
	memset(&local0, 0, sizeof(Array__MapEntry__string__Ptr__FieldDef________));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__MapEntry__string__Ptr__FieldDef________ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
Array__bool____ Array__cons__bool____(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(bool__)));
	Array__bool____ local0;
	memset(&local0, 0, sizeof(Array__bool____));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__bool____ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
Array__string____ Array__cons__string____(int__ count__) {
	ssize__ numBytes__ = CheckedMath__mulPositiveSsize__((ssize__)(count__), (ssize__)(sizeof(string__)));
	Array__string____ local0;
	memset(&local0, 0, sizeof(Array__string____));
	local0.dataPtr__ = IAllocator__alloc__(top_____currentAllocator__, numBytes__);
	local0.count__ = count__;
	Array__string____ result__ = local0;
	memset((result__).dataPtr__, 0, (usize__)(numBytes__));
	return result__;
}
void__ Array__clearValues__byte____(Array__byte____* this__) {
	memset((this__)->dataPtr__, 0, (usize__)((((ssize__)((this__)->count__))) * ((ssize__)(sizeof(byte__)))));
}
void__ Array__stableSortMerge___Error____(Array__Error____* src__, Array__Error____* dest__, int__ from__, int__ chunk__, fun__Error__Error__int____ compareFn__) {
	int__ a__ = from__;
	int__ ae__ = ((a__)) + ((chunk__));
	if (((ae__)) >= (((src__)->count__))) {
		Array__copySlice__Error____(src__, from__, (src__)->count__, dest__, from__);
		return;
	}
	int__ b__ = ae__;
	int__ local0 = ((b__)) + ((chunk__));
	int__ local1 = (src__)->count__;
	int__ be__ = (local0 < local1) ? local0 : local1;
	int__ i__ = from__;
	while (true__) {
		bool__ local2 = ((a__)) < ((ae__));
		if (!local2) {
			local2 = ((b__)) < ((be__));
		}
		if (!(local2)) { break; }
		bool__ local3 = ((a__)) < ((ae__));
		if (local3) {
			bool__ local4 = ((b__)) >= ((be__));
			if (!local4) {
				Array__Error____* local5 = src__;
				uint__ local6 = (uint__)(a__);
				mu_____boundscheck(local6 < (uint__)local5->count__);
				Array__Error____* local7 = src__;
				uint__ local8 = (uint__)(b__);
				mu_____boundscheck(local8 < (uint__)local7->count__);
				local4 = ((compareFn__(((Error__*)local5->dataPtr__)[local6], ((Error__*)local7->dataPtr__)[local8]))) <= ((0));
			}
			local3 = local4;
		}
		if (local3) {
			Array__Error____* local9 = dest__;
			uint__ local10 = (uint__)(i__);
			mu_____boundscheck(local10 < (uint__)local9->count__);
			Array__Error____* local11 = src__;
			uint__ local12 = (uint__)(a__);
			mu_____boundscheck(local12 < (uint__)local11->count__);
			((Error__*)local9->dataPtr__)[local10] = ((Error__*)local11->dataPtr__)[local12];
			a__ = ((a__)) + ((1));
			i__ = ((i__)) + ((1));
		} else {
			Array__Error____* local13 = dest__;
			uint__ local14 = (uint__)(i__);
			mu_____boundscheck(local14 < (uint__)local13->count__);
			Array__Error____* local15 = src__;
			uint__ local16 = (uint__)(b__);
			mu_____boundscheck(local16 < (uint__)local15->count__);
			((Error__*)local13->dataPtr__)[local14] = ((Error__*)local15->dataPtr__)[local16];
			b__ = ((b__)) + ((1));
			i__ = ((i__)) + ((1));
		}
	}
}
void__ Array__copySlice__Error____(Array__Error____* src__, int__ from__, int__ to__, Array__Error____* dest__, int__ index__) {
	bool__ local1 = ((0)) <= ((from__));
	if (local1) {
		local1 = ((from__)) <= ((to__));
	}
	bool__ local0 = local1;
	if (local0) {
		local0 = ((to__)) <= (((src__)->count__));
	}
	mu_____assert(local0);
	int__ count__ = ((to__)) - ((from__));
	bool__ local2 = ((0)) <= ((index__));
	if (local2) {
		local2 = ((index__)) <= (((((dest__)->count__)) - ((count__))));
	}
	mu_____assert(local2);
	memcpy(((dest__)->dataPtr__) + ((((ssize__)(index__))) * ((ssize__)(sizeof(Error__)))), ((src__)->dataPtr__) + ((((ssize__)(from__))) * ((ssize__)(sizeof(Error__)))), (usize__)((((ssize__)(count__))) * ((ssize__)(sizeof(Error__)))));
}
void__ Array__copySlice__byte____(Array__byte____* src__, int__ from__, int__ to__, Array__byte____* dest__, int__ index__) {
	bool__ local1 = ((0)) <= ((from__));
	if (local1) {
		local1 = ((from__)) <= ((to__));
	}
	bool__ local0 = local1;
	if (local0) {
		local0 = ((to__)) <= (((src__)->count__));
	}
	mu_____assert(local0);
	int__ count__ = ((to__)) - ((from__));
	bool__ local2 = ((0)) <= ((index__));
	if (local2) {
		local2 = ((index__)) <= (((((dest__)->count__)) - ((count__))));
	}
	mu_____assert(local2);
	memcpy(((dest__)->dataPtr__) + ((((ssize__)(index__))) * ((ssize__)(sizeof(byte__)))), ((src__)->dataPtr__) + ((((ssize__)(from__))) * ((ssize__)(sizeof(byte__)))), (usize__)((((ssize__)(count__))) * ((ssize__)(sizeof(byte__)))));
}
void__ Indexer__block__(IndexerState__* s__, Block__* st__) {
	{
		List__Node____* local0 = (st__)->contents__;
		int__ local1 = 0;
		while (local1 < local0->count__) {
			Node__ n__ = ((Node__*)(local0->dataPtr__))[local1];
			switch ((n__).id__) {
				case Node_____Ptr__ClockStatement____: {
					ClockStatement__* local2 = (ClockStatement__*)(n__.dataPtr__);
					Indexer__block__(s__, (local2)->body__);
					break;
				}
				case Node_____Ptr__IfStatement____: {
					IfStatement__* local3 = (IfStatement__*)(n__.dataPtr__);
					Indexer__if___(s__, local3);
					break;
				}
				case Node_____Ptr__AssignStatement____: {
					AssignStatement__* local4 = (AssignStatement__*)(n__.dataPtr__);
					Indexer__assign__(s__, local4);
					break;
				}
				default: {
					{
					}
					break;
				}
				case 0: {
					mu_____nomatch();
				}
			}
			local1 += 1;
		}
	}
}
void__ Indexer__unit__(IndexerState__* s__, CodeUnit__* unit__) {
	Compilation__* comp__ = (s__)->comp__;
	{
		List__Node____* local0 = (unit__)->contents__;
		int__ local1 = 0;
		while (local1 < local0->count__) {
			Node__ n__ = ((Node__*)(local0->dataPtr__))[local1];
			switch ((n__).id__) {
				case Node_____Ptr__ConstDef____: {
					ConstDef__* local2 = (ConstDef__*)(n__.dataPtr__);
					{
						if (((local2)->name__) != (null__)) {
							string__ name__ = ((local2)->name__)->value__;
							Node__ local3;
							local3.dataPtr__ = (pointer__)(local2);
							local3.id__ = local3.dataPtr__ != null__ ? Node_____Ptr__ConstDef____ : 0;
							if (Map__tryAdd__string__Node____((comp__)->symbols__, name__, local3)) {
								(local2)->id__ = ((comp__)->entities__)->count__;
								Node__ local4;
								local4.dataPtr__ = (pointer__)(local2);
								local4.id__ = local4.dataPtr__ != null__ ? Node_____Ptr__ConstDef____ : 0;
								List__add__Node____((comp__)->entities__, local4);
							} else {
								Indexer__duplicateSymbol__(s__, (local2)->name__);
							}
						}
					}
					break;
				}
				case Node_____Ptr__StructDef____: {
					StructDef__* local5 = (StructDef__*)(n__.dataPtr__);
					{
						string__ name__ = ((local5)->name__)->value__;
						Node__ local6;
						local6.dataPtr__ = (pointer__)(local5);
						local6.id__ = local6.dataPtr__ != null__ ? Node_____Ptr__StructDef____ : 0;
						if (Map__tryAdd__string__Node____((comp__)->symbols__, name__, local6)) {
							(local5)->id__ = ((comp__)->entities__)->count__;
							Node__ local7;
							local7.dataPtr__ = (pointer__)(local5);
							local7.id__ = local7.dataPtr__ != null__ ? Node_____Ptr__StructDef____ : 0;
							List__add__Node____((comp__)->entities__, local7);
						} else {
							Indexer__duplicateSymbol__(s__, (local5)->name__);
						}
					}
					break;
				}
				case Node_____Ptr__ModuleDef____: {
					ModuleDef__* local8 = (ModuleDef__*)(n__.dataPtr__);
					{
						string__ name__ = ((local8)->name__)->value__;
						Node__ local9;
						local9.dataPtr__ = (pointer__)(local8);
						local9.id__ = local9.dataPtr__ != null__ ? Node_____Ptr__ModuleDef____ : 0;
						if (Map__tryAdd__string__Node____((comp__)->symbols__, name__, local9)) {
							(local8)->id__ = ((comp__)->entities__)->count__;
							Node__ local10;
							local10.dataPtr__ = (pointer__)(local8);
							local10.id__ = local10.dataPtr__ != null__ ? Node_____Ptr__ModuleDef____ : 0;
							List__add__Node____((comp__)->entities__, local10);
						} else {
							Indexer__duplicateSymbol__(s__, (local8)->name__);
						}
						(s__)->module__ = local8;
						Map__string__Node____* local11 = (Map__string__Node____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Map__string__Node____));
						*local11 = Map__create__string__Node____();
						(local8)->symbols__ = local11;
						List__Ptr__AssignStatement______* local12 = (List__Ptr__AssignStatement______*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Ptr__AssignStatement______));
						List__Ptr__AssignStatement______ local13;
						memset(&local13, 0, sizeof(List__Ptr__AssignStatement______));
						*local12 = local13;
						(local8)->outputs__ = local12;
						{
							List__Ptr__ModuleInputDef______* local14 = (local8)->inputs__;
							int__ local15 = 0;
							while (local15 < local14->count__) {
								ModuleInputDef__* input__ = ((ModuleInputDef__**)(local14->dataPtr__))[local15];
								Node__ local16;
								local16.dataPtr__ = (pointer__)(input__);
								local16.id__ = local16.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
								if (Map__tryAdd__string__Node____(((s__)->module__)->symbols__, ((input__)->name__)->value__, local16)) {
									(input__)->localId__ = (((s__)->module__)->symbols__)->count__;
								} else {
									Indexer__duplicateSymbol__(s__, (input__)->name__);
								}
								local15 += 1;
							}
						}
						Indexer__block__(s__, (local8)->body__);
					}
					break;
				}
				default: {
					{
					}
					break;
				}
				case 0: {
					mu_____nomatch();
				}
			}
			local1 += 1;
		}
	}
}
void__ Indexer__comp__(Compilation__* comp__) {
	Map__string__Node____* local0 = (Map__string__Node____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Map__string__Node____));
	*local0 = Map__create__string__Node____();
	(comp__)->symbols__ = local0;
	List__Node____* local1 = (List__Node____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Node____));
	List__Node____ local2;
	memset(&local2, 0, sizeof(List__Node____));
	*local1 = local2;
	(comp__)->entities__ = local1;
	(comp__)->nonSyntaxErrorStart__ = ((comp__)->errors__)->count__;
	IndexerState__* local3 = (IndexerState__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(IndexerState__));
	IndexerState__ local4;
	memset(&local4, 0, sizeof(IndexerState__));
	local4.comp__ = comp__;
	*local3 = local4;
	IndexerState__* s__ = local3;
	{
		List__Ptr__CodeUnit______* local5 = (comp__)->units__;
		int__ local6 = 0;
		while (local6 < local5->count__) {
			CodeUnit__* u__ = ((CodeUnit__**)(local5->dataPtr__))[local6];
			(s__)->unit__ = u__;
			Indexer__unit__(s__, u__);
			local6 += 1;
		}
	}
}
void__ Indexer__if___(IndexerState__* s__, IfStatement__* st__) {
	Indexer__block__(s__, (st__)->ifBody__);
	if (((st__)->elseBranch__).id__ == Node_____Ptr__IfStatement____) {
		Node__ local0 = (st__)->elseBranch__;
		mu_____checkedcast(local0.id__ == Node_____Ptr__IfStatement____);
		Indexer__if___(s__, (IfStatement__*)(local0.dataPtr__));
	} else {
		if (((st__)->elseBranch__).id__ == Node_____Ptr__Block____) {
			Node__ local1 = (st__)->elseBranch__;
			mu_____checkedcast(local1.id__ == Node_____Ptr__Block____);
			Indexer__block__(s__, (Block__*)(local1.dataPtr__));
		}
	}
}
void__ Indexer__assign__(IndexerState__* s__, AssignStatement__* st__) {
	ModuleDef__* module__ = (s__)->module__;
	if (((st__)->regKeyword__) != (null__)) {
		(st__)->flags__ = (((st__)->flags__)) | ((AssignFlags__reg__));
		if (((st__)->nameExpr__).id__ == Node_____Ptr__Token____) {
			Node__ local0 = (st__)->nameExpr__;
			mu_____checkedcast(local0.id__ == Node_____Ptr__Token____);
			Token__* nameToken__ = (Token__*)(local0.dataPtr__);
			string__ name__ = (nameToken__)->value__;
			Node__ local1;
			local1.dataPtr__ = (pointer__)(st__);
			local1.id__ = local1.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
			if (Map__tryAdd__string__Node____(((s__)->module__)->symbols__, name__, local1)) {
				(st__)->localId__ = (((s__)->module__)->symbols__)->count__;
			} else {
				Indexer__duplicateSymbol__(s__, nameToken__);
			}
		}
	} else {
		bool__ local2 = ((st__)->op__) != (null__);
		if (local2) {
			local2 = string__equals__(((st__)->op__)->value__, mu_____string44);
		}
		if (local2) {
			(st__)->flags__ = (((st__)->flags__)) | ((AssignFlags__regUpdate__));
		} else {
			(st__)->flags__ = (((st__)->flags__)) | ((AssignFlags__wire__));
			if (((st__)->nameExpr__).id__ == Node_____Ptr__Token____) {
				Node__ local3 = (st__)->nameExpr__;
				mu_____checkedcast(local3.id__ == Node_____Ptr__Token____);
				Token__* nameToken__ = (Token__*)(local3.dataPtr__);
				string__ name__ = (nameToken__)->value__;
				Node__ local4;
				local4.dataPtr__ = (pointer__)(st__);
				local4.id__ = local4.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
				if (Map__tryAdd__string__Node____(((s__)->module__)->symbols__, name__, local4)) {
					(st__)->localId__ = (((s__)->module__)->symbols__)->count__;
				} else {
					Indexer__duplicateSymbol__(s__, nameToken__);
				}
			}
		}
	}
}
void__ Indexer__duplicateSymbol__(IndexerState__* s__, Token__* token__) {
	List__add__Error____(((s__)->comp__)->errors__, Error__at__((s__)->unit__, (token__)->span__, mu_____string104));
}
uint__ ssize__hash__(ssize__ val__) {
	return (uint__)(val__);
}
void__ ssize__writeTo__(ssize__ val__, StringBuilder__* sb__) {
	long__writeTo__((long__)(val__), sb__);
}
IntRange__ RangeFinder__find__(Node__ e__) {
	RangeFinderState__ local0;
	memset(&local0, 0, sizeof(RangeFinderState__));
	IntRange__ local1;
	memset(&local1, 0, sizeof(IntRange__));
	local1.from__ = int__maxValue__;
	local1.to__ = int__minValue__;
	local0.range__ = local1;
	RangeFinderState__ s__ = local0;
	RangeFinder__node__(&(s__), e__);
	return (s__).range__;
}
void__ RangeFinder__token__(RangeFinderState__* s__, Token__* e__) {
	if ((e__) == (null__)) {
		return;
	}
	int__ local0 = ((s__)->range__).from__;
	int__ local1 = ((e__)->span__).from__;
	((s__)->range__).from__ = (local0 < local1) ? local0 : local1;
	int__ local2 = ((s__)->range__).to__;
	int__ local3 = ((e__)->span__).to__;
	((s__)->range__).to__ = (local2 > local3) ? local2 : local3;
}
void__ RangeFinder__node__(RangeFinderState__* s__, Node__ e__) {
	switch ((e__).id__) {
		case Node_____Ptr__Token____: {
			Token__* local0 = (Token__*)(e__.dataPtr__);
			{
				RangeFinder__token__(s__, local0);
			}
			break;
		}
		case Node_____Ptr__NumberExpression____: {
			NumberExpression__* local1 = (NumberExpression__*)(e__.dataPtr__);
			{
				RangeFinder__token__(s__, (local1)->token__);
			}
			break;
		}
		case Node_____Ptr__UnaryOperatorExpression____: {
			UnaryOperatorExpression__* local2 = (UnaryOperatorExpression__*)(e__.dataPtr__);
			{
				RangeFinder__token__(s__, (local2)->op__);
				RangeFinder__node__(s__, (local2)->expr__);
			}
			break;
		}
		case Node_____Ptr__BinaryOperatorExpression____: {
			BinaryOperatorExpression__* local3 = (BinaryOperatorExpression__*)(e__.dataPtr__);
			{
				RangeFinder__node__(s__, (local3)->lhs__);
				RangeFinder__token__(s__, (local3)->op__);
				RangeFinder__node__(s__, (local3)->rhs__);
			}
			break;
		}
		case Node_____Ptr__DotExpression____: {
			DotExpression__* local4 = (DotExpression__*)(e__.dataPtr__);
			{
				RangeFinder__node__(s__, (local4)->lhs__);
				RangeFinder__token__(s__, (local4)->dot__);
				RangeFinder__token__(s__, (local4)->rhs__);
			}
			break;
		}
		case Node_____Ptr__TernaryOperatorExpression____: {
			TernaryOperatorExpression__* local5 = (TernaryOperatorExpression__*)(e__.dataPtr__);
			{
				RangeFinder__node__(s__, (local5)->conditionExpr__);
				RangeFinder__token__(s__, (local5)->question__);
				RangeFinder__node__(s__, (local5)->trueExpr__);
				RangeFinder__token__(s__, (local5)->colon__);
				RangeFinder__node__(s__, (local5)->falseExpr__);
			}
			break;
		}
		case Node_____Ptr__MatchExpression____: {
			MatchExpression__* local6 = (MatchExpression__*)(e__.dataPtr__);
			{
				RangeFinder__token__(s__, (local6)->keyword__);
				RangeFinder__node__(s__, (local6)->target__);
				RangeFinder__token__(s__, (local6)->openBrace__);
				{
					List__Node____* local7 = (local6)->contents__;
					int__ local8 = 0;
					while (local8 < local7->count__) {
						Node__ c__ = ((Node__*)(local7->dataPtr__))[local8];
						RangeFinder__node__(s__, c__);
						local8 += 1;
					}
				}
				RangeFinder__token__(s__, (local6)->closeBrace__);
			}
			break;
		}
		case Node_____Ptr__MatchExpressionCase____: {
			MatchExpressionCase__* local9 = (MatchExpressionCase__*)(e__.dataPtr__);
			{
				RangeFinder__node__(s__, (local9)->valueExpr__);
				RangeFinder__token__(s__, (local9)->colon__);
				RangeFinder__node__(s__, (local9)->resultExpr__);
			}
			break;
		}
		case Node_____Ptr__CallExpression____: {
			CallExpression__* local10 = (CallExpression__*)(e__.dataPtr__);
			{
				RangeFinder__node__(s__, (local10)->target__);
				RangeFinder__token__(s__, (local10)->openParen__);
				{
					List__Node____* local11 = (local10)->contents__;
					int__ local12 = 0;
					while (local12 < local11->count__) {
						Node__ c__ = ((Node__*)(local11->dataPtr__))[local12];
						RangeFinder__node__(s__, c__);
						local12 += 1;
					}
				}
				RangeFinder__token__(s__, (local10)->closeParen__);
			}
			break;
		}
		case Node_____Ptr__StructInitializerExpression____: {
			StructInitializerExpression__* local13 = (StructInitializerExpression__*)(e__.dataPtr__);
			{
				RangeFinder__node__(s__, (local13)->target__);
				RangeFinder__token__(s__, (local13)->openBrace__);
				{
					List__Node____* local14 = (local13)->contents__;
					int__ local15 = 0;
					while (local15 < local14->count__) {
						Node__ c__ = ((Node__*)(local14->dataPtr__))[local15];
						RangeFinder__node__(s__, c__);
						local15 += 1;
					}
				}
				RangeFinder__token__(s__, (local13)->closeBrace__);
			}
			break;
		}
		case Node_____Ptr__ParenExpression____: {
			ParenExpression__* local16 = (ParenExpression__*)(e__.dataPtr__);
			{
				RangeFinder__token__(s__, (local16)->openParen__);
				RangeFinder__node__(s__, (local16)->expr__);
				RangeFinder__token__(s__, (local16)->closeParen__);
			}
			break;
		}
		case Node_____Ptr__BraceExpression____: {
			BraceExpression__* local17 = (BraceExpression__*)(e__.dataPtr__);
			{
				RangeFinder__token__(s__, (local17)->openBrace__);
				{
					List__Node____* local18 = (local17)->contents__;
					int__ local19 = 0;
					while (local19 < local18->count__) {
						Node__ c__ = ((Node__*)(local18->dataPtr__))[local19];
						RangeFinder__node__(s__, c__);
						local19 += 1;
					}
				}
				RangeFinder__token__(s__, (local17)->closeBrace__);
			}
			break;
		}
		case Node_____Ptr__IndexExpression____: {
			IndexExpression__* local20 = (IndexExpression__*)(e__.dataPtr__);
			{
				RangeFinder__node__(s__, (local20)->target__);
				RangeFinder__token__(s__, (local20)->openBracket__);
				RangeFinder__node__(s__, (local20)->upperExpr__);
				RangeFinder__token__(s__, (local20)->colon__);
				RangeFinder__node__(s__, (local20)->lowerExpr__);
				RangeFinder__token__(s__, (local20)->closeBracket__);
			}
			break;
		}
		case Node_____Ptr__ArrayExpression____: {
			ArrayExpression__* local21 = (ArrayExpression__*)(e__.dataPtr__);
			{
				RangeFinder__token__(s__, (local21)->openBracket__);
				{
					List__Node____* local22 = (local21)->contents__;
					int__ local23 = 0;
					while (local23 < local22->count__) {
						Node__ c__ = ((Node__*)(local22->dataPtr__))[local23];
						RangeFinder__node__(s__, c__);
						local23 += 1;
					}
				}
				RangeFinder__token__(s__, (local21)->closeBracket__);
			}
			break;
		}
		case 0: {
			{
			}
			break;
		}
		default: {
			mu_____nomatch();
		}
	}
}
IAllocator__ Memory__newArenaAllocator__(ssize__ capacity__) {
	IAllocator__ prev__ = top_____currentAllocator__;
	top_____currentAllocator__ = Memory__heapAllocator__();
	ArenaAllocator__* local0 = (ArenaAllocator__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(ArenaAllocator__));
	*local0 = ArenaAllocator__cons__(capacity__);
	ArenaAllocator__* a__ = local0;
	top_____currentAllocator__ = prev__;
	return ArenaAllocator__iAllocator_escaping__(a__);
}
IAllocator__ Memory__heapAllocator__() {
	IAllocator__ local0;
	memset(&local0, 0, sizeof(IAllocator__));
	local0.allocFn__ = &Memory__heapAllocFn__;
	local0.reallocFn__ = &Memory__heapReallocFn__;
	local0.freeFn__ = &Memory__heapFreeFn__;
	return local0;
}
pointer__ Memory__heapAllocFn__(pointer__ data__, ssize__ numBytes__) {
	ssize__ local0 = numBytes__;
	mu_____checkedcast(0 <= local0);
	pointer__ result__ = (pointer__)malloc((usize__)(local0));
	mu_____assert((result__) != (null__));
	return result__;
}
pointer__ Memory__heapReallocFn__(pointer__ data__, pointer__ ptr__, ssize__ newSizeInBytes__, ssize__ prevSizeInBytes__, ssize__ copySizeInBytes__) {
	ssize__ local0 = newSizeInBytes__;
	mu_____checkedcast(0 <= local0);
	pointer__ result__ = (pointer__)realloc(ptr__, (usize__)(local0));
	mu_____assert((result__) != (null__));
	return result__;
}
IAllocator__ Memory__pushAllocator__(IAllocator__ allocator__) {
	IAllocator__ prev__ = top_____currentAllocator__;
	top_____currentAllocator__ = allocator__;
	return prev__;
}
void__ Memory__heapFreeFn__(pointer__ data__, pointer__ ptr__) {
	mu_____assert((ptr__) != (null__));
	free(ptr__);
}
void__ Memory__restoreAllocator__(IAllocator__ allocator__) {
	top_____currentAllocator__ = allocator__;
}
uint__ short__hash__(short__ val__) {
	return (uint__)(val__);
}
void__ short__writeTo__(short__ val__, StringBuilder__* sb__) {
	long__writeTo__((long__)(val__), sb__);
}
ModuleInputDef__* Parser__moduleInput__(ParseState__* s__) {
	ModuleInputDef__* local0 = (ModuleInputDef__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(ModuleInputDef__));
	ModuleInputDef__ local1;
	memset(&local1, 0, sizeof(ModuleInputDef__));
	local1.name__ = (s__)->token__;
	*local0 = local1;
	ModuleInputDef__* node__ = local0;
	string__* local2 = &(((s__)->token__)->value__);
	uint__ local3 = (uint__)(0);
	mu_____boundscheck(local3 < (uint__)local2->length__);
	if ((((char__*)local2->dataPtr__)[local3]) == ('#')) {
		(node__)->flags__ = (((node__)->flags__)) | ((ModuleInputFlags__static__));
	}
	Parser__readToken__(s__);
	bool__ local4 = (((s__)->token__)->type__) == (TokenType__identifier__);
	if (local4) {
		local4 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
	}
	if (local4) {
		(node__)->type__ = (s__)->token__;
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string70);
	}
	return node__;
}
CodeUnit__* Parser__unit__(string__ text__, List__Error____* errors__, int__ tabSize__) {
	Parser__maxBase__ = ((int__maxValue__)) - ((1));
	CodeUnit__* local0 = (CodeUnit__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(CodeUnit__));
	CodeUnit__ local1;
	memset(&local1, 0, sizeof(CodeUnit__));
	List__Node____* local2 = (List__Node____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Node____));
	List__Node____ local3;
	memset(&local3, 0, sizeof(List__Node____));
	*local2 = local3;
	local1.contents__ = local2;
	local1.source__ = text__;
	*local0 = local1;
	CodeUnit__* unit__ = local0;
	ParseState__* local4 = (ParseState__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(ParseState__));
	ParseState__ local5;
	memset(&local5, 0, sizeof(ParseState__));
	local5.text__ = text__;
	local5.unit__ = unit__;
	local5.errors__ = errors__;
	Token__* local6 = (Token__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Token__));
	Token__ local7;
	memset(&local7, 0, sizeof(Token__));
	*local6 = local7;
	local5.token__ = local6;
	*local4 = local5;
	ParseState__* s__ = local4;
	if (((tabSize__)) > ((0))) {
		(s__)->tabSize__ = tabSize__;
	} else {
		(s__)->tabSize__ = 1;
		(s__)->ignoreIndent__ = true__;
		(s__)->base__ = -1;
		(s__)->blockBase__ = -1;
	}
	Parser__readToken__(s__);
	while (true__) {
		if (!((((s__)->token__)->type__) != (TokenType__end__))) { break; }
		if (((((s__)->token__)->indent__)) == ((0))) {
			if ((((s__)->token__)->type__) == (TokenType__identifier__)) {
				Token__* name__ = (s__)->token__;
				Parser__readToken__(s__);
				bool__ local9 = (((s__)->token__)->type__) == (TokenType__identifier__);
				if (local9) {
					local9 = string__equals__(((s__)->token__)->value__, mu_____string11);
				}
				bool__ local8 = local9;
				if (local8) {
					local8 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
				}
				if (local8) {
					Parser__struct___(s__, name__, (unit__)->contents__);
				} else {
					bool__ local11 = (((s__)->token__)->type__) == (TokenType__openParen__);
					if (!local11) {
						bool__ local12 = (((s__)->token__)->type__) == (TokenType__identifier__);
						if (local12) {
							local12 = string__equals__(((s__)->token__)->value__, mu_____string69);
						}
						local11 = local12;
					}
					bool__ local10 = local11;
					if (local10) {
						local10 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
					}
					if (local10) {
						Parser__module__(s__, name__, (unit__)->contents__);
					} else {
						Parser__const__(s__, name__, (unit__)->contents__);
					}
				}
			} else {
				Parser__parseErrorToken__(s__, mu_____string75, (unit__)->contents__);
			}
		} else {
			Parser__parseErrorToken__(s__, mu_____string76, (unit__)->contents__);
		}
		while (true__) {
			if (!(((((s__)->token__)->indent__)) == ((Parser__sameLine__)))) { break; }
			Node__ local13;
			local13.dataPtr__ = (pointer__)((s__)->token__);
			local13.id__ = local13.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
			List__add__Node____((unit__)->contents__, local13);
			Parser__readBadToken_newline__(s__);
		}
	}
	return unit__;
}
void__ Parser__finishToken__(ParseState__* s__, int__ outerFrom__, int__ from__, int__ indent__, TokenType__ type__) {
	int__ to__ = (s__)->index__;
	string__* local0 = &((s__)->text__);
	uint__ local1 = (uint__)((s__)->index__);
	mu_____boundscheck(local1 < (uint__)local0->length__);
	char__ ch__ = ((char__*)local0->dataPtr__)[local1];
	while (true__) {
		bool__ local3 = (ch__) == (' ');
		if (!local3) {
			local3 = (ch__) == ('\t');
		}
		bool__ local2 = local3;
		if (!local2) {
			local2 = (ch__) == ('\r');
		}
		if (!(local2)) { break; }
		(s__)->index__ = (((s__)->index__)) + ((1));
		string__* local4 = &((s__)->text__);
		uint__ local5 = (uint__)((s__)->index__);
		mu_____boundscheck(local5 < (uint__)local4->length__);
		ch__ = ((char__*)local4->dataPtr__)[local5];
	}
	if ((ch__) == ('\n')) {
		(s__)->index__ = (((s__)->index__)) + ((1));
		(s__)->lineStart__ = (s__)->index__;
	}
	(s__)->prevTokenTo__ = (((s__)->token__)->span__).to__;
	Token__* local6 = (Token__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Token__));
	Token__ local7;
	memset(&local7, 0, sizeof(Token__));
	local7.type__ = type__;
	local7.value__ = string__slice__((s__)->text__, from__, to__);
	local7.indent__ = indent__;
	local7.span__ = IntRange__cons__(from__, to__);
	local7.outerSpan__ = IntRange__cons__(outerFrom__, (s__)->index__);
	*local6 = local7;
	(s__)->token__ = local6;
}
void__ Parser__readBadToken_unexpected__(ParseState__* s__) {
	Parser__readBadToken__(s__, mu_____string77);
}
void__ Parser__errorAt__(ParseState__* s__, int__ index__, string__ text__) {
	List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, index__, text__));
}
Node__ Parser__parseExpression_alwaysProgress__(ParseState__* s__, int__ minLevel__, List__Node____* out_all__) {
	Node__ leaf__ = Parser__parseExpressionLeaf__(s__);
	if (((leaf__).dataPtr__) == ((pointer__)(null__))) {
		Node__ local0;
		local0.dataPtr__ = (pointer__)((s__)->token__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		List__add__Node____(out_all__, local0);
		Parser__error__(s__, mu_____string25);
		Parser__readToken__(s__);
		Node__ local1;
		local1.dataPtr__ = null__;
		local1.id__ = 0;
		return local1;
	}
	Node__ expr__ = Parser__parseExpressionTail__(s__, leaf__, minLevel__);
	List__add__Node____(out_all__, expr__);
	return expr__;
}
void__ Parser__parseAssignStatement__(ParseState__* s__, List__Node____* out__) {
	AssignStatement__* local0 = (AssignStatement__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(AssignStatement__));
	AssignStatement__ local1;
	memset(&local1, 0, sizeof(AssignStatement__));
	local1.module__ = (s__)->module__;
	*local0 = local1;
	AssignStatement__* node__ = local0;
	Node__ local2;
	local2.dataPtr__ = (pointer__)(node__);
	local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
	List__add__Node____(out__, local2);
	bool__ local3 = string__equals__(((s__)->token__)->value__, mu_____string60);
	if (local3) {
		local3 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
	}
	if (local3) {
		(node__)->outKeyword__ = (s__)->token__;
		Parser__readToken__(s__);
	}
	bool__ local4 = string__equals__(((s__)->token__)->value__, mu_____string61);
	if (local4) {
		local4 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
	}
	if (local4) {
		(node__)->regKeyword__ = (s__)->token__;
		Parser__readToken__(s__);
	}
	bool__ local5 = (((s__)->token__)->type__) == (TokenType__identifier__);
	if (local5) {
		local5 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
	}
	if (local5) {
		Token__* name__ = (s__)->token__;
		string__* local6 = &(((s__)->token__)->value__);
		uint__ local7 = (uint__)(0);
		mu_____boundscheck(local7 < (uint__)local6->length__);
		if ((((char__*)local6->dataPtr__)[local7]) == ('#')) {
			(node__)->flags__ = (((node__)->flags__)) | ((AssignFlags__static__));
		}
		Parser__readToken__(s__);
		bool__ local9 = (((s__)->token__)->type__) == (TokenType__openParen__);
		if (!local9) {
			bool__ local10 = (((s__)->token__)->type__) == (TokenType__operator__);
			if (local10) {
				local10 = string__equals__(((s__)->token__)->value__, mu_____string35);
			}
			local9 = local10;
		}
		bool__ local8 = local9;
		if (local8) {
			local8 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
		}
		if (local8) {
			Node__ local11;
			local11.dataPtr__ = (pointer__)(name__);
			local11.id__ = local11.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
			(node__)->nameExpr__ = Parser__parseExpressionTail__(s__, local11, 20);
		} else {
			Node__ local12;
			local12.dataPtr__ = (pointer__)(name__);
			local12.id__ = local12.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
			(node__)->nameExpr__ = local12;
			bool__ local13 = (((s__)->token__)->type__) == (TokenType__identifier__);
			if (local13) {
				local13 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
			}
			if (local13) {
				(node__)->type__ = (s__)->token__;
				Parser__readToken__(s__);
			}
		}
	} else {
		Parser__expected__(s__, mu_____string16);
	}
	bool__ local14 = (((s__)->token__)->type__) == (TokenType__operator__);
	if (local14) {
		local14 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
	}
	if (local14) {
		(node__)->op__ = (s__)->token__;
		Parser__readToken__(s__);
	}
	int__ prev__ = (s__)->base__;
	(s__)->base__ = Parser__maxBase__;
	(node__)->expr__ = Parser__parseExpression_orNull__(s__, 0);
	(s__)->base__ = prev__;
}
void__ Parser__readBadToken__(ParseState__* s__, string__ text__) {
	bool__ local0 = ((((s__)->errors__)->count__)) > ((0));
	if (local0) {
		List__Error____* local2 = (s__)->errors__;
		uint__ local3 = (uint__)(((((s__)->errors__)->count__)) - ((1)));
		mu_____boundscheck(local3 < (uint__)local2->count__);
		bool__ local1 = ((((((Error__*)local2->dataPtr__)[local3]).span__).to__)) == (((s__)->prevTokenTo__));
		if (!local1) {
			List__Error____* local4 = (s__)->errors__;
			uint__ local5 = (uint__)(((((s__)->errors__)->count__)) - ((1)));
			mu_____boundscheck(local5 < (uint__)local4->count__);
			local1 = ((((((Error__*)local4->dataPtr__)[local5]).span__).to__)) == (((((s__)->token__)->span__).from__));
		}
		local0 = local1;
	}
	if (local0) {
		List__Error____* local6 = (s__)->errors__;
		uint__ local7 = (uint__)(((((s__)->errors__)->count__)) - ((1)));
		mu_____boundscheck(local7 < (uint__)local6->count__);
		((((Error__*)local6->dataPtr__)[local7]).span__).to__ = (((s__)->token__)->span__).to__;
	} else {
		Parser__error__(s__, text__);
	}
	Parser__readToken__(s__);
}
void__ Parser__readToken__(ParseState__* s__) {
	int__ outerFrom__ = (s__)->index__;
	int__ indent__ = 0;
	while (true__) {
		if (!(true__)) { break; }
		string__* local0 = &((s__)->text__);
		uint__ local1 = (uint__)((s__)->index__);
		mu_____boundscheck(local1 < (uint__)local0->length__);
		char__ ch__ = ((char__*)local0->dataPtr__)[local1];
		if ((ch__) == ('\0')) {
			Parser__finishToken__(s__, outerFrom__, (s__)->index__, int__minValue__, TokenType__end__);
			return;
		}
		if ((ch__) == (' ')) {
			indent__ = ((indent__)) + ((1));
		} else {
			if ((ch__) == ('\t')) {
				indent__ = ((((((indent__)) + (((s__)->tabSize__)))) / (((s__)->tabSize__)))) * (((s__)->tabSize__));
			} else {
				if ((ch__) == ('\r')) {
				} else {
					if ((ch__) == ('\n')) {
						indent__ = 0;
						(s__)->lineStart__ = (((s__)->index__)) + ((1));
					} else {
						bool__ local2 = (ch__) == ('/');
						if (local2) {
							string__* local3 = &((s__)->text__);
							uint__ local4 = (uint__)((((s__)->index__)) + ((1)));
							mu_____boundscheck(local4 < (uint__)local3->length__);
							local2 = (((char__*)local3->dataPtr__)[local4]) == ('/');
						}
						if (local2) {
							(s__)->index__ = (((s__)->index__)) + ((2));
							string__* local5 = &((s__)->text__);
							uint__ local6 = (uint__)((s__)->index__);
							mu_____boundscheck(local6 < (uint__)local5->length__);
							ch__ = ((char__*)local5->dataPtr__)[local6];
							while (true__) {
								bool__ local7 = (ch__) != ('\n');
								if (local7) {
									local7 = (ch__) != ('\0');
								}
								if (!(local7)) { break; }
								(s__)->index__ = (((s__)->index__)) + ((1));
								string__* local8 = &((s__)->text__);
								uint__ local9 = (uint__)((s__)->index__);
								mu_____boundscheck(local9 < (uint__)local8->length__);
								ch__ = ((char__*)local8->dataPtr__)[local9];
							}
							goto label1;
						} else {
							goto label0;
						}
					}
				}
			}
		}
		(s__)->index__ = (((s__)->index__)) + ((1));
	label1:
		{}
	}
label0:
	{}
	if ((((s__)->lineStart__)) < ((outerFrom__))) {
		indent__ = Parser__sameLine__;
	} else {
		if ((s__)->ignoreIndent__) {
			indent__ = 0;
		}
	}
	int__ from__ = (s__)->index__;
	string__* local10 = &((s__)->text__);
	uint__ local11 = (uint__)((s__)->index__);
	mu_____boundscheck(local11 < (uint__)local10->length__);
	char__ ch__ = ((char__*)local10->dataPtr__)[local11];
	bool__ local16 = ((unsigned char)('A')) <= ((unsigned char)(ch__));
	if (local16) {
		local16 = ((unsigned char)(ch__)) <= ((unsigned char)('Z'));
	}
	bool__ local15 = local16;
	if (!local15) {
		bool__ local17 = ((unsigned char)('a')) <= ((unsigned char)(ch__));
		if (local17) {
			local17 = ((unsigned char)(ch__)) <= ((unsigned char)('z'));
		}
		local15 = local17;
	}
	bool__ local14 = local15;
	if (!local14) {
		local14 = (ch__) == ('_');
	}
	bool__ local13 = local14;
	if (!local13) {
		local13 = (ch__) == ('$');
	}
	bool__ local12 = local13;
	if (!local12) {
		local12 = (ch__) == ('#');
	}
	if (local12) {
		(s__)->index__ = (((s__)->index__)) + ((1));
		string__* local18 = &((s__)->text__);
		uint__ local19 = (uint__)((s__)->index__);
		mu_____boundscheck(local19 < (uint__)local18->length__);
		ch__ = ((char__*)local18->dataPtr__)[local19];
		while (true__) {
			bool__ local25 = ((unsigned char)('A')) <= ((unsigned char)(ch__));
			if (local25) {
				local25 = ((unsigned char)(ch__)) <= ((unsigned char)('Z'));
			}
			bool__ local24 = local25;
			if (!local24) {
				bool__ local26 = ((unsigned char)('a')) <= ((unsigned char)(ch__));
				if (local26) {
					local26 = ((unsigned char)(ch__)) <= ((unsigned char)('z'));
				}
				local24 = local26;
			}
			bool__ local23 = local24;
			if (!local23) {
				bool__ local27 = ((unsigned char)('0')) <= ((unsigned char)(ch__));
				if (local27) {
					local27 = ((unsigned char)(ch__)) <= ((unsigned char)('9'));
				}
				local23 = local27;
			}
			bool__ local22 = local23;
			if (!local22) {
				local22 = (ch__) == ('_');
			}
			bool__ local21 = local22;
			if (!local21) {
				local21 = (ch__) == ('$');
			}
			bool__ local20 = local21;
			if (!local20) {
				local20 = (ch__) == ('#');
			}
			if (!(local20)) { break; }
			(s__)->index__ = (((s__)->index__)) + ((1));
			string__* local28 = &((s__)->text__);
			uint__ local29 = (uint__)((s__)->index__);
			mu_____boundscheck(local29 < (uint__)local28->length__);
			ch__ = ((char__*)local28->dataPtr__)[local29];
		}
		Parser__finishToken__(s__, outerFrom__, from__, indent__, TokenType__identifier__);
		return;
	}
	bool__ local31 = ((unsigned char)('0')) <= ((unsigned char)(ch__));
	if (local31) {
		local31 = ((unsigned char)(ch__)) <= ((unsigned char)('9'));
	}
	bool__ local30 = local31;
	if (!local30) {
		local30 = (ch__) == ('\'');
	}
	if (local30) {
		(s__)->index__ = (((s__)->index__)) + ((1));
		string__* local32 = &((s__)->text__);
		uint__ local33 = (uint__)((s__)->index__);
		mu_____boundscheck(local33 < (uint__)local32->length__);
		ch__ = ((char__*)local32->dataPtr__)[local33];
		while (true__) {
			bool__ local38 = ((unsigned char)('A')) <= ((unsigned char)(ch__));
			if (local38) {
				local38 = ((unsigned char)(ch__)) <= ((unsigned char)('Z'));
			}
			bool__ local37 = local38;
			if (!local37) {
				bool__ local39 = ((unsigned char)('a')) <= ((unsigned char)(ch__));
				if (local39) {
					local39 = ((unsigned char)(ch__)) <= ((unsigned char)('z'));
				}
				local37 = local39;
			}
			bool__ local36 = local37;
			if (!local36) {
				bool__ local40 = ((unsigned char)('0')) <= ((unsigned char)(ch__));
				if (local40) {
					local40 = ((unsigned char)(ch__)) <= ((unsigned char)('9'));
				}
				local36 = local40;
			}
			bool__ local35 = local36;
			if (!local35) {
				local35 = (ch__) == ('_');
			}
			bool__ local34 = local35;
			if (!local34) {
				local34 = (ch__) == ('$');
			}
			if (!(local34)) { break; }
			(s__)->index__ = (((s__)->index__)) + ((1));
			string__* local41 = &((s__)->text__);
			uint__ local42 = (uint__)((s__)->index__);
			mu_____boundscheck(local42 < (uint__)local41->length__);
			ch__ = ((char__*)local41->dataPtr__)[local42];
		}
		Parser__finishToken__(s__, outerFrom__, from__, indent__, TokenType__numberLiteral__);
		return;
	}
	if ((ch__) == (',')) {
		(s__)->index__ = (((s__)->index__)) + ((1));
		Parser__finishToken__(s__, outerFrom__, from__, indent__, TokenType__comma__);
		return;
	}
	if ((ch__) == ('(')) {
		(s__)->index__ = (((s__)->index__)) + ((1));
		Parser__finishToken__(s__, outerFrom__, from__, indent__, TokenType__openParen__);
		return;
	}
	if ((ch__) == (')')) {
		(s__)->index__ = (((s__)->index__)) + ((1));
		Parser__finishToken__(s__, outerFrom__, from__, indent__, TokenType__closeParen__);
		return;
	}
	if ((ch__) == ('{')) {
		(s__)->index__ = (((s__)->index__)) + ((1));
		Parser__finishToken__(s__, outerFrom__, from__, indent__, TokenType__openBrace__);
		return;
	}
	if ((ch__) == ('}')) {
		(s__)->index__ = (((s__)->index__)) + ((1));
		Parser__finishToken__(s__, outerFrom__, from__, indent__, TokenType__closeBrace__);
		return;
	}
	if ((ch__) == ('[')) {
		(s__)->index__ = (((s__)->index__)) + ((1));
		Parser__finishToken__(s__, outerFrom__, from__, indent__, TokenType__openBracket__);
		return;
	}
	if ((ch__) == (']')) {
		(s__)->index__ = (((s__)->index__)) + ((1));
		Parser__finishToken__(s__, outerFrom__, from__, indent__, TokenType__closeBracket__);
		return;
	}
	if (Parser__isOperatorChar__(ch__)) {
		(s__)->index__ = (((s__)->index__)) + ((1));
		string__* local43 = &((s__)->text__);
		uint__ local44 = (uint__)((s__)->index__);
		mu_____boundscheck(local44 < (uint__)local43->length__);
		ch__ = ((char__*)local43->dataPtr__)[local44];
		while (true__) {
			if (!(Parser__isOperatorChar__(ch__))) { break; }
			(s__)->index__ = (((s__)->index__)) + ((1));
			string__* local45 = &((s__)->text__);
			uint__ local46 = (uint__)((s__)->index__);
			mu_____boundscheck(local46 < (uint__)local45->length__);
			ch__ = ((char__*)local45->dataPtr__)[local46];
		}
		Parser__finishToken__(s__, outerFrom__, from__, indent__, TokenType__operator__);
		return;
	}
	(s__)->index__ = (((s__)->index__)) + ((1));
	Parser__finishToken__(s__, outerFrom__, from__, indent__, TokenType__invalid__);
}
void__ Parser__error__(ParseState__* s__, string__ text__) {
	List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, ((s__)->token__)->span__, text__));
}
void__ Parser__const__(ParseState__* s__, Token__* name__, List__Node____* out__) {
	ConstDef__* local0 = (ConstDef__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(ConstDef__));
	ConstDef__ local1;
	memset(&local1, 0, sizeof(ConstDef__));
	local1.name__ = name__;
	local1.unit__ = (s__)->unit__;
	*local0 = local1;
	ConstDef__* node__ = local0;
	Node__ local2;
	local2.dataPtr__ = (pointer__)(node__);
	local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__ConstDef____ : 0;
	List__add__Node____(out__, local2);
	bool__ local3 = (((s__)->token__)->type__) == (TokenType__identifier__);
	if (local3) {
		local3 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
	}
	if (local3) {
		(node__)->type__ = (s__)->token__;
		Parser__readToken__(s__);
	}
	bool__ local4 = string__equals__(((s__)->token__)->value__, mu_____string74);
	if (local4) {
		local4 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
	}
	if (local4) {
		(node__)->assign__ = (s__)->token__;
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string74);
	}
	int__ prev__ = (s__)->base__;
	(s__)->base__ = Parser__maxBase__;
	(node__)->expr__ = Parser__parseExpression__(s__, 0);
	(s__)->base__ = prev__;
}
bool__ Parser__isOperatorChar__(char__ ch__) {
	bool__ local12 = (ch__) == ('+');
	if (!local12) {
		local12 = (ch__) == ('-');
	}
	bool__ local11 = local12;
	if (!local11) {
		local11 = (ch__) == ('*');
	}
	bool__ local10 = local11;
	if (!local10) {
		local10 = (ch__) == ('&');
	}
	bool__ local9 = local10;
	if (!local9) {
		local9 = (ch__) == ('|');
	}
	bool__ local8 = local9;
	if (!local8) {
		local8 = (ch__) == ('^');
	}
	bool__ local7 = local8;
	if (!local7) {
		local7 = (ch__) == ('~');
	}
	bool__ local6 = local7;
	if (!local6) {
		local6 = (ch__) == ('.');
	}
	bool__ local5 = local6;
	if (!local5) {
		local5 = (ch__) == ('?');
	}
	bool__ local4 = local5;
	if (!local4) {
		local4 = (ch__) == (':');
	}
	bool__ local3 = local4;
	if (!local3) {
		local3 = (ch__) == ('=');
	}
	bool__ local2 = local3;
	if (!local2) {
		local2 = (ch__) == ('!');
	}
	bool__ local1 = local2;
	if (!local1) {
		local1 = (ch__) == ('<');
	}
	bool__ local0 = local1;
	if (!local0) {
		local0 = (ch__) == ('>');
	}
	return local0;
}
void__ Parser__fieldDef__(ParseState__* s__, List__Node____* out__) {
	if ((((s__)->token__)->type__) != (TokenType__identifier__)) {
		Parser__error__(s__, mu_____string63);
		Node__ local0;
		local0.dataPtr__ = (pointer__)((s__)->token__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		List__add__Node____(out__, local0);
		Parser__readToken__(s__);
		return;
	}
	FieldDef__* local1 = (FieldDef__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(FieldDef__));
	FieldDef__ local2;
	memset(&local2, 0, sizeof(FieldDef__));
	local2.name__ = (s__)->token__;
	*local1 = local2;
	FieldDef__* node__ = local1;
	Node__ local3;
	local3.dataPtr__ = (pointer__)(node__);
	local3.id__ = local3.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
	List__add__Node____(out__, local3);
	List__add__Ptr__FieldDef______(((s__)->struct___)->fields__, node__);
	Parser__readToken__(s__);
	bool__ local4 = (((s__)->token__)->type__) == (TokenType__identifier__);
	if (local4) {
		local4 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
	}
	if (local4) {
		(node__)->type__ = (s__)->token__;
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string64);
	}
}
void__ Parser__expected__(ParseState__* s__, string__ text__) {
	Parser__expectedAt__(s__, (s__)->prevTokenTo__, text__);
}
Node__ Parser__parseExpressionLeaf__(ParseState__* s__) {
	if ((((s__)->token__)->type__) == (TokenType__identifier__)) {
		if (string__equals__(((s__)->token__)->value__, mu_____string20)) {
			UnaryOperatorExpression__* local0 = (UnaryOperatorExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(UnaryOperatorExpression__));
			UnaryOperatorExpression__ local1;
			memset(&local1, 0, sizeof(UnaryOperatorExpression__));
			local1.op__ = (s__)->token__;
			*local0 = local1;
			UnaryOperatorExpression__* result__ = local0;
			Parser__readToken__(s__);
			(result__)->expr__ = Parser__parseExpression__(s__, 20);
			Node__ local2;
			local2.dataPtr__ = (pointer__)(result__);
			local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__UnaryOperatorExpression____ : 0;
			return local2;
		} else {
			if (string__equals__(((s__)->token__)->value__, mu_____string21)) {
				return Parser__parseMatchExpression__(s__);
			} else {
				Token__* result__ = (s__)->token__;
				Parser__readToken__(s__);
				Node__ local3;
				local3.dataPtr__ = (pointer__)(result__);
				local3.id__ = local3.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
				return local3;
			}
		}
	}
	if ((((s__)->token__)->type__) == (TokenType__numberLiteral__)) {
		Node__ local4;
		local4.dataPtr__ = (pointer__)(Parser__parseNumber__(s__));
		local4.id__ = local4.dataPtr__ != null__ ? Node_____Ptr__NumberExpression____ : 0;
		return local4;
	}
	bool__ local5 = (((s__)->token__)->type__) == (TokenType__operator__);
	if (local5) {
		local5 = string__equals__(((s__)->token__)->value__, mu_____string56);
	}
	if (local5) {
		NumberExpression__* local6 = (NumberExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(NumberExpression__));
		NumberExpression__ local7;
		memset(&local7, 0, sizeof(NumberExpression__));
		local7.token__ = (s__)->token__;
		local7.dontCare__ = ulong__maxValue__;
		local7.flags__ = ((NumberFlags__valid__)) | ((NumberFlags__dontCare__));
		*local6 = local7;
		NumberExpression__* result__ = local6;
		Parser__readToken__(s__);
		Node__ local8;
		local8.dataPtr__ = (pointer__)(result__);
		local8.id__ = local8.dataPtr__ != null__ ? Node_____Ptr__NumberExpression____ : 0;
		return local8;
	}
	bool__ local9 = (((s__)->token__)->type__) == (TokenType__operator__);
	if (local9) {
		bool__ local10 = string__equals__(((s__)->token__)->value__, mu_____string57);
		if (!local10) {
			local10 = string__equals__(((s__)->token__)->value__, mu_____string2);
		}
		local9 = local10;
	}
	if (local9) {
		UnaryOperatorExpression__* local11 = (UnaryOperatorExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(UnaryOperatorExpression__));
		UnaryOperatorExpression__ local12;
		memset(&local12, 0, sizeof(UnaryOperatorExpression__));
		local12.op__ = (s__)->token__;
		*local11 = local12;
		UnaryOperatorExpression__* result__ = local11;
		Parser__readToken__(s__);
		(result__)->expr__ = Parser__parseExpression__(s__, 20);
		Node__ local13;
		local13.dataPtr__ = (pointer__)(result__);
		local13.id__ = local13.dataPtr__ != null__ ? Node_____Ptr__UnaryOperatorExpression____ : 0;
		return local13;
	}
	if ((((s__)->token__)->type__) == (TokenType__openParen__)) {
		ParenExpression__* local14 = (ParenExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(ParenExpression__));
		ParenExpression__ local15;
		memset(&local15, 0, sizeof(ParenExpression__));
		local15.openParen__ = (s__)->token__;
		*local14 = local15;
		ParenExpression__* result__ = local14;
		Parser__readToken__(s__);
		int__ prev__ = (s__)->base__;
		bool__ prevNB__ = (s__)->exprNoBrace__;
		(s__)->exprNoBrace__ = false__;
		(s__)->base__ = (s__)->blockBase__;
		(result__)->expr__ = Parser__parseExpression__(s__, 0);
		bool__ local16 = (((s__)->token__)->type__) == (TokenType__closeParen__);
		if (local16) {
			local16 = ((((s__)->token__)->indent__)) >= (((s__)->base__));
		}
		if (local16) {
			(result__)->closeParen__ = (s__)->token__;
			Parser__readToken__(s__);
		} else {
			Parser__expected__(s__, mu_____string32);
		}
		(s__)->base__ = prev__;
		(s__)->exprNoBrace__ = prevNB__;
		Node__ local17;
		local17.dataPtr__ = (pointer__)(result__);
		local17.id__ = local17.dataPtr__ != null__ ? Node_____Ptr__ParenExpression____ : 0;
		return local17;
	}
	bool__ local18 = (((s__)->token__)->type__) == (TokenType__openBrace__);
	if (local18) {
		local18 = !((s__)->exprNoBrace__);
	}
	if (local18) {
		BraceExpression__* local19 = (BraceExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(BraceExpression__));
		BraceExpression__ local20;
		memset(&local20, 0, sizeof(BraceExpression__));
		local20.openBrace__ = (s__)->token__;
		List__Node____* local21 = (List__Node____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Node____));
		List__Node____ local22;
		memset(&local22, 0, sizeof(List__Node____));
		*local21 = local22;
		local20.args__ = local21;
		List__Node____* local23 = (List__Node____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Node____));
		List__Node____ local24;
		memset(&local24, 0, sizeof(List__Node____));
		*local23 = local24;
		local20.contents__ = local23;
		*local19 = local20;
		BraceExpression__* node__ = local19;
		Parser__readToken__(s__);
		int__ prev__ = (s__)->base__;
		(s__)->base__ = (s__)->blockBase__;
		ParseCommaListState__ state__ = ParseCommaListState__start__;
		while (true__) {
			bool__ local25 = ((((s__)->token__)->indent__)) > (((s__)->base__));
			if (local25) {
				local25 = (((s__)->token__)->type__) != (TokenType__closeBrace__);
			}
			if (!(local25)) { break; }
			if ((state__) != (ParseCommaListState__expectComma__)) {
				if ((((s__)->token__)->type__) != (TokenType__comma__)) {
					Node__ expr__ = Parser__parseExpression_alwaysProgress__(s__, 0, (node__)->contents__);
					if (((expr__).dataPtr__) != ((pointer__)(null__))) {
						List__add__Node____((node__)->args__, expr__);
					}
				} else {
					Parser__expected__(s__, mu_____string19);
				}
				state__ = ParseCommaListState__expectComma__;
			} else {
				Parser__parseComma__(s__, (node__)->contents__);
				state__ = ParseCommaListState__expectValue__;
			}
		}
		bool__ local26 = (((s__)->token__)->type__) == (TokenType__closeBrace__);
		if (local26) {
			local26 = ((((s__)->token__)->indent__)) >= (((s__)->base__));
		}
		if (local26) {
			(node__)->closeBrace__ = (s__)->token__;
			Parser__readToken__(s__);
		} else {
			Parser__expected__(s__, mu_____string33);
		}
		(s__)->base__ = prev__;
		Node__ local27;
		local27.dataPtr__ = (pointer__)(node__);
		local27.id__ = local27.dataPtr__ != null__ ? Node_____Ptr__BraceExpression____ : 0;
		return local27;
	}
	if ((((s__)->token__)->type__) == (TokenType__openBracket__)) {
		Node__ local28;
		local28.dataPtr__ = (pointer__)(Parser__parseArrayExpression__(s__));
		local28.id__ = local28.dataPtr__ != null__ ? Node_____Ptr__ArrayExpression____ : 0;
		return local28;
	}
	Node__ local29;
	local29.dataPtr__ = null__;
	local29.id__ = 0;
	return local29;
}
Node__ Parser__parseMatchExpression__(ParseState__* s__) {
	MatchExpression__* local0 = (MatchExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(MatchExpression__));
	MatchExpression__ local1;
	memset(&local1, 0, sizeof(MatchExpression__));
	local1.keyword__ = (s__)->token__;
	List__Ptr__MatchExpressionCase______* local2 = (List__Ptr__MatchExpressionCase______*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Ptr__MatchExpressionCase______));
	List__Ptr__MatchExpressionCase______ local3;
	memset(&local3, 0, sizeof(List__Ptr__MatchExpressionCase______));
	*local2 = local3;
	local1.cases__ = local2;
	List__Node____* local4 = (List__Node____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Node____));
	List__Node____ local5;
	memset(&local5, 0, sizeof(List__Node____));
	*local4 = local5;
	local1.contents__ = local4;
	*local0 = local1;
	MatchExpression__* node__ = local0;
	Parser__readToken__(s__);
	bool__ prevExprNoBrace__ = (s__)->exprNoBrace__;
	(s__)->exprNoBrace__ = true__;
	(node__)->target__ = Parser__parseExpression__(s__, 0);
	(s__)->exprNoBrace__ = prevExprNoBrace__;
	bool__ local6 = (((s__)->token__)->type__) == (TokenType__openBrace__);
	if (local6) {
		local6 = ((((s__)->token__)->indent__)) >= (((s__)->base__));
	}
	if (local6) {
		(node__)->openBrace__ = (s__)->token__;
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string13);
	}
	while (true__) {
		if (!(((((s__)->token__)->indent__)) == ((Parser__sameLine__)))) { break; }
		Node__ local7;
		local7.dataPtr__ = (pointer__)((s__)->token__);
		local7.id__ = local7.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		List__add__Node____((node__)->contents__, local7);
		Parser__readBadToken_newline__(s__);
	}
	int__ prevBase__ = (s__)->base__;
	(s__)->base__ = (s__)->blockBase__;
	if (((((s__)->token__)->indent__)) > (((s__)->base__))) {
		mu_____assert(((((s__)->token__)->indent__)) < ((Parser__sameLine__)));
		int__ firstIndent__ = ((s__)->token__)->indent__;
		while (true__) {
			if (!(((((s__)->token__)->indent__)) > (((s__)->base__)))) { break; }
			if ((((s__)->token__)->type__) == (TokenType__closeBrace__)) {
				if ((s__)->ignoreIndent__) {
					goto label2;
				}
				Parser__parseErrorToken__(s__, mu_____string23, (node__)->contents__);
			} else {
				if (((((s__)->token__)->indent__)) != ((firstIndent__))) {
					Parser__parseErrorToken__(s__, mu_____string24, (node__)->contents__);
				} else {
					int__ prev__ = (s__)->base__;
					int__ local8;
					if ((s__)->ignoreIndent__) {
						local8 = -1;
					} else {
						local8 = ((s__)->token__)->indent__;
					}
					(s__)->base__ = local8;
					Parser__parseMatchExpressionCase__(s__, (node__)->cases__, (node__)->contents__);
					(s__)->base__ = prev__;
				}
			}
			while (true__) {
				if (!(((((s__)->token__)->indent__)) == ((Parser__sameLine__)))) { break; }
				Node__ local9;
				local9.dataPtr__ = (pointer__)((s__)->token__);
				local9.id__ = local9.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
				List__add__Node____((node__)->contents__, local9);
				Parser__readBadToken_newline__(s__);
			}
		}
	label2:
		{}
	} else {
		Parser__expected__(s__, mu_____string50);
	}
	(s__)->base__ = prevBase__;
	bool__ local10 = (((s__)->token__)->type__) == (TokenType__closeBrace__);
	if (local10) {
		local10 = ((((s__)->token__)->indent__)) >= (((s__)->blockBase__));
	}
	if (local10) {
		(node__)->closeBrace__ = (s__)->token__;
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string33);
	}
	Node__ local11;
	local11.dataPtr__ = (pointer__)(node__);
	local11.id__ = local11.dataPtr__ != null__ ? Node_____Ptr__MatchExpression____ : 0;
	return local11;
}
void__ Parser__module__(ParseState__* s__, Token__* name__, List__Node____* out__) {
	ModuleDef__* local0 = (ModuleDef__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(ModuleDef__));
	ModuleDef__ local1;
	memset(&local1, 0, sizeof(ModuleDef__));
	local1.name__ = name__;
	List__Ptr__ModuleInputDef______* local2 = (List__Ptr__ModuleInputDef______*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Ptr__ModuleInputDef______));
	List__Ptr__ModuleInputDef______ local3;
	memset(&local3, 0, sizeof(List__Ptr__ModuleInputDef______));
	*local2 = local3;
	local1.inputs__ = local2;
	List__Node____* local4 = (List__Node____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Node____));
	List__Node____ local5;
	memset(&local5, 0, sizeof(List__Node____));
	*local4 = local5;
	local1.inputsContents__ = local4;
	local1.unit__ = (s__)->unit__;
	*local0 = local1;
	ModuleDef__* node__ = local0;
	Node__ local6;
	local6.dataPtr__ = (pointer__)(node__);
	local6.id__ = local6.dataPtr__ != null__ ? Node_____Ptr__ModuleDef____ : 0;
	List__add__Node____(out__, local6);
	bool__ local8 = (((s__)->token__)->type__) == (TokenType__identifier__);
	if (local8) {
		local8 = string__equals__(((s__)->token__)->value__, mu_____string69);
	}
	bool__ local7 = local8;
	if (local7) {
		local7 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
	}
	if (local7) {
		(node__)->blackboxKeyword__ = (s__)->token__;
		Parser__readToken__(s__);
	}
	bool__ local9 = (((s__)->token__)->type__) == (TokenType__openParen__);
	if (local9) {
		local9 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
	}
	if (local9) {
		(node__)->openParen__ = (s__)->token__;
		Parser__readToken__(s__);
		ParseCommaListState__ state__ = ParseCommaListState__start__;
		while (true__) {
			bool__ local11 = ((((s__)->token__)->indent__)) > (((s__)->base__));
			if (local11) {
				local11 = (((s__)->token__)->type__) != (TokenType__closeParen__);
			}
			bool__ local10 = local11;
			if (local10) {
				local10 = (((s__)->token__)->type__) != (TokenType__openBrace__);
			}
			if (!(local10)) { break; }
			if ((state__) != (ParseCommaListState__expectComma__)) {
				if ((((s__)->token__)->type__) == (TokenType__identifier__)) {
					ModuleInputDef__* input__ = Parser__moduleInput__(s__);
					List__add__Ptr__ModuleInputDef______((node__)->inputs__, input__);
					Node__ local12;
					local12.dataPtr__ = (pointer__)(input__);
					local12.id__ = local12.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
					List__add__Node____((node__)->inputsContents__, local12);
				} else {
					bool__ local13 = (((s__)->token__)->type__) == (TokenType__comma__);
					if (local13) {
						local13 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
					}
					if (local13) {
						Parser__expected__(s__, mu_____string71);
					} else {
						Parser__parseErrorToken__(s__, mu_____string72, (node__)->inputsContents__);
					}
				}
				state__ = ParseCommaListState__expectComma__;
			} else {
				if (((((s__)->token__)->indent__)) == ((Parser__sameLine__))) {
					Parser__parseComma__(s__, (node__)->inputsContents__);
				}
				state__ = ParseCommaListState__expectValue__;
			}
		}
		bool__ local14 = (((s__)->token__)->type__) == (TokenType__closeParen__);
		if (local14) {
			local14 = ((((s__)->token__)->indent__)) >= (((s__)->base__));
		}
		if (local14) {
			(node__)->closeParen__ = (s__)->token__;
			Parser__readToken__(s__);
		} else {
			Parser__expected__(s__, mu_____string32);
		}
	} else {
		Parser__expected__(s__, mu_____string73);
	}
	(s__)->module__ = node__;
	(node__)->body__ = Parser__block__(s__, true__, mu_____string17);
	(s__)->module__ = null__;
}
CallExpression__* Parser__parseCallExpression__(ParseState__* s__, Node__ lhs__) {
	CallExpression__* local0 = (CallExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(CallExpression__));
	CallExpression__ local1;
	memset(&local1, 0, sizeof(CallExpression__));
	local1.target__ = lhs__;
	local1.openParen__ = (s__)->token__;
	List__Ptr__CallArg______* local2 = (List__Ptr__CallArg______*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Ptr__CallArg______));
	List__Ptr__CallArg______ local3;
	memset(&local3, 0, sizeof(List__Ptr__CallArg______));
	*local2 = local3;
	local1.args__ = local2;
	List__Node____* local4 = (List__Node____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Node____));
	List__Node____ local5;
	memset(&local5, 0, sizeof(List__Node____));
	*local4 = local5;
	local1.contents__ = local4;
	*local0 = local1;
	CallExpression__* node__ = local0;
	if ((lhs__).id__ == Node_____Ptr__Token____) {
		Node__ local6 = lhs__;
		mu_____checkedcast(local6.id__ == Node_____Ptr__Token____);
		string__ name__ = ((Token__*)(local6.dataPtr__))->value__;
		if (string__equals__(name__, mu_____string26)) {
			(node__)->builtin__ = BuiltinCall__rep__;
		} else {
			if (string__equals__(name__, mu_____string27)) {
				(node__)->builtin__ = BuiltinCall__slice__;
			} else {
				if (string__equals__(name__, mu_____string28)) {
					(node__)->builtin__ = BuiltinCall__chunk__;
				} else {
					if (string__equals__(name__, mu_____string29)) {
						(node__)->builtin__ = BuiltinCall__swizzle__;
					}
				}
			}
		}
	}
	Parser__readToken__(s__);
	int__ prev__ = (s__)->base__;
	(s__)->base__ = (s__)->blockBase__;
	ParseCommaListState__ state__ = ParseCommaListState__start__;
	while (true__) {
		bool__ local7 = ((((s__)->token__)->indent__)) > (((s__)->base__));
		if (local7) {
			local7 = (((s__)->token__)->type__) != (TokenType__closeParen__);
		}
		if (!(local7)) { break; }
		if ((state__) != (ParseCommaListState__expectComma__)) {
			Parser__parseCallArg__(s__, (node__)->args__, (node__)->contents__);
			state__ = ParseCommaListState__expectComma__;
		} else {
			if (((((s__)->token__)->indent__)) == ((Parser__sameLine__))) {
				Parser__parseComma__(s__, (node__)->contents__);
			}
			state__ = ParseCommaListState__expectValue__;
		}
	}
	bool__ local8 = (((s__)->token__)->type__) == (TokenType__closeParen__);
	if (local8) {
		local8 = ((((s__)->token__)->indent__)) >= (((s__)->base__));
	}
	if (local8) {
		(node__)->closeParen__ = (s__)->token__;
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string32);
	}
	(s__)->base__ = prev__;
	return node__;
}
NumberExpression__* Parser__parseNumber__(ParseState__* s__) {
	NumberExpression__* result__ = (NumberExpression__*)(null__);
	string__ str__ = ((s__)->token__)->value__;
	string__* local0 = &(str__);
	uint__ local1 = (uint__)(0);
	mu_____boundscheck(local1 < (uint__)local0->length__);
	if ((((char__*)local0->dataPtr__)[local1]) == ('\'')) {
		ulong__ val__ = 0uLL;
		ulong__ dontCare__ = 0uLL;
		bool__ invalid__ = false__;
		{
			int__ i__ = 1;
			while (((i__)) < (((str__).length__))) {
				val__ = ((ulong__)val__) << (1);
				dontCare__ = ((ulong__)dontCare__) << (1);
				string__* local2 = &(str__);
				uint__ local3 = (uint__)(i__);
				mu_____boundscheck(local3 < (uint__)local2->length__);
				char__ ch__ = ((char__*)local2->dataPtr__)[local3];
				if ((ch__) == ('0')) {
				} else {
					if ((ch__) == ('1')) {
						val__ = ((val__)) + ((ulong__)(1));
					} else {
						if ((ch__) == ('x')) {
							dontCare__ = ((dontCare__)) + ((ulong__)(1));
						} else {
							invalid__ = true__;
						}
					}
				}
				i__ += 1;
			}
		}
		bool__ local5 = !(invalid__);
		if (local5) {
			local5 = (((str__).length__)) > ((1));
		}
		bool__ local4 = local5;
		if (local4) {
			local4 = (((str__).length__)) <= ((65));
		}
		if (local4) {
			NumberFlags__ local6;
			if (((dontCare__)) != ((ulong__)(0))) {
				local6 = NumberFlags__dontCare__;
			} else {
				local6 = NumberFlags__none__;
			}
			NumberFlags__ flags__ = ((((NumberFlags__valid__)) | ((NumberFlags__exactWidth__)))) | ((local6));
			NumberExpression__* local7 = (NumberExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(NumberExpression__));
			NumberExpression__ local8;
			memset(&local8, 0, sizeof(NumberExpression__));
			local8.token__ = (s__)->token__;
			local8.value__ = val__;
			local8.dontCare__ = dontCare__;
			local8.width__ = (((str__).length__)) - ((1));
			local8.flags__ = flags__;
			*local7 = local8;
			result__ = local7;
		} else {
			Parser__error__(s__, mu_____string51);
			NumberExpression__* local9 = (NumberExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(NumberExpression__));
			NumberExpression__ local10;
			memset(&local10, 0, sizeof(NumberExpression__));
			local10.token__ = (s__)->token__;
			local10.width__ = (((str__).length__)) - ((1));
			local10.flags__ = NumberFlags__exactWidth__;
			*local9 = local10;
			result__ = local9;
		}
	} else {
		bool__ local12 = (((str__).length__)) >= ((2));
		if (local12) {
			string__* local13 = &(str__);
			uint__ local14 = (uint__)(0);
			mu_____boundscheck(local14 < (uint__)local13->length__);
			local12 = (((char__*)local13->dataPtr__)[local14]) == ('0');
		}
		bool__ local11 = local12;
		if (local11) {
			string__* local15 = &(str__);
			uint__ local16 = (uint__)(1);
			mu_____boundscheck(local16 < (uint__)local15->length__);
			local11 = (((char__*)local15->dataPtr__)[local16]) == ('x');
		}
		bool__ isHex__ = local11;
		int__ local17;
		if (isHex__) {
			local17 = 2;
		} else {
			local17 = 0;
		}
		int__ i__ = local17;
		while (true__) {
			bool__ local18 = ((i__)) < (((str__).length__));
			if (local18) {
				string__* local19 = &(str__);
				uint__ local20 = (uint__)(i__);
				mu_____boundscheck(local20 < (uint__)local19->length__);
				local18 = (((char__*)local19->dataPtr__)[local20]) != ('_');
			}
			if (!(local18)) { break; }
			i__ = ((i__)) + ((1));
		}
		int__ prefixTo__ = i__;
		while (true__) {
			bool__ local21 = ((i__)) < (((str__).length__));
			if (local21) {
				string__* local22 = &(str__);
				uint__ local23 = (uint__)(i__);
				mu_____boundscheck(local23 < (uint__)local22->length__);
				local21 = (((char__*)local22->dataPtr__)[local23]) == ('_');
			}
			if (!(local21)) { break; }
			i__ = ((i__)) + ((1));
		}
		int__ suffixFrom__ = i__;
		Maybe__ulong____ local24;
		if (isHex__) {
			local24 = ulong__tryParseHex__(string__slice__(str__, 2, prefixTo__));
		} else {
			local24 = ulong__tryParse__(string__slice__(str__, 0, prefixTo__));
		}
		Maybe__ulong____ pr__ = local24;
		string__ suffix__ = string__slice__(str__, suffixFrom__, (str__).length__);
		int__ width__ = Parser__parseNumberSuffix__(s__, suffix__);
		NumberFlags__ local25;
		if (((width__)) > ((0))) {
			local25 = NumberFlags__exactWidth__;
		} else {
			local25 = NumberFlags__none__;
		}
		NumberFlags__ flags__ = local25;
		if ((pr__).hasValue__) {
			bool__ local26 = (((suffix__).length__)) == ((0));
			if (!local26) {
				local26 = ((width__)) > ((0));
			}
			if (local26) {
				bool__ local27 = ((width__)) == ((0));
				if (!local27) {
					local27 = ((TypeChecker__highestBit__((pr__).value__))) <= ((width__));
				}
				if (local27) {
					NumberExpression__* local28 = (NumberExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(NumberExpression__));
					NumberExpression__ local29;
					memset(&local29, 0, sizeof(NumberExpression__));
					local29.token__ = (s__)->token__;
					local29.value__ = (pr__).value__;
					local29.width__ = width__;
					local29.flags__ = ((NumberFlags__valid__)) | ((flags__));
					*local28 = local29;
					result__ = local28;
				} else {
					Parser__error__(s__, mu_____string52);
					NumberExpression__* local30 = (NumberExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(NumberExpression__));
					NumberExpression__ local31;
					memset(&local31, 0, sizeof(NumberExpression__));
					local31.token__ = (s__)->token__;
					local31.width__ = width__;
					local31.flags__ = flags__;
					*local30 = local31;
					result__ = local30;
				}
			} else {
				Parser__error__(s__, mu_____string53);
				NumberExpression__* local32 = (NumberExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(NumberExpression__));
				NumberExpression__ local33;
				memset(&local33, 0, sizeof(NumberExpression__));
				local33.token__ = (s__)->token__;
				local33.flags__ = flags__;
				*local32 = local33;
				result__ = local32;
			}
		} else {
			string__ local34;
			if (isHex__) {
				local34 = mu_____string54;
			} else {
				local34 = mu_____string55;
			}
			Parser__error__(s__, local34);
			NumberExpression__* local35 = (NumberExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(NumberExpression__));
			NumberExpression__ local36;
			memset(&local36, 0, sizeof(NumberExpression__));
			local36.token__ = (s__)->token__;
			local36.width__ = width__;
			local36.flags__ = flags__;
			*local35 = local36;
			result__ = local35;
		}
	}
	Parser__readToken__(s__);
	return result__;
}
IfStatement__* Parser__parseIfStatement__(ParseState__* s__) {
	IfStatement__* local0 = (IfStatement__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(IfStatement__));
	IfStatement__ local1;
	memset(&local1, 0, sizeof(IfStatement__));
	local1.ifKeyword__ = (s__)->token__;
	*local0 = local1;
	IfStatement__* node__ = local0;
	Parser__readToken__(s__);
	int__ prev__ = (s__)->base__;
	(s__)->base__ = Parser__maxBase__;
	(s__)->exprNoBrace__ = true__;
	(node__)->expr__ = Parser__parseExpression__(s__, 0);
	(s__)->base__ = prev__;
	(s__)->exprNoBrace__ = false__;
	(node__)->ifBody__ = Parser__block__(s__, true__, mu_____string17);
	bool__ local3 = (((s__)->token__)->type__) == (TokenType__identifier__);
	if (local3) {
		local3 = string__equals__(((s__)->token__)->value__, mu_____string59);
	}
	bool__ local2 = local3;
	if (local2) {
		local2 = ((((s__)->token__)->indent__)) >= (((s__)->base__));
	}
	if (local2) {
		(node__)->elseKeyword__ = (s__)->token__;
		Parser__readToken__(s__);
		bool__ local5 = (((s__)->token__)->type__) == (TokenType__identifier__);
		if (local5) {
			local5 = string__equals__(((s__)->token__)->value__, mu_____string18);
		}
		bool__ local4 = local5;
		if (local4) {
			local4 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
		}
		if (local4) {
			Node__ local6;
			local6.dataPtr__ = (pointer__)(Parser__parseIfStatement__(s__));
			local6.id__ = local6.dataPtr__ != null__ ? Node_____Ptr__IfStatement____ : 0;
			(node__)->elseBranch__ = local6;
		} else {
			Node__ local7;
			local7.dataPtr__ = (pointer__)(Parser__block__(s__, true__, mu_____string17));
			local7.id__ = local7.dataPtr__ != null__ ? Node_____Ptr__Block____ : 0;
			(node__)->elseBranch__ = local7;
		}
	}
	return node__;
}
Node__ Parser__parseExpressionTail__(ParseState__* s__, Node__ lhs__, int__ minLevel__) {
	while (true__) {
		if (!(true__)) { break; }
		if (((((s__)->token__)->indent__)) <= (((s__)->base__))) {
			return lhs__;
		}
		if ((((s__)->token__)->type__) == (TokenType__openParen__)) {
			Node__ local0;
			local0.dataPtr__ = (pointer__)(Parser__parseCallExpression__(s__, lhs__));
			local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__CallExpression____ : 0;
			lhs__ = local0;
			goto label1;
		}
		bool__ local1 = (((s__)->token__)->type__) == (TokenType__openBrace__);
		if (local1) {
			local1 = !((s__)->exprNoBrace__);
		}
		if (local1) {
			Node__ local2;
			local2.dataPtr__ = (pointer__)(Parser__parseStructInitializerExpression__(s__, lhs__));
			local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__StructInitializerExpression____ : 0;
			lhs__ = local2;
			goto label1;
		}
		if ((((s__)->token__)->type__) == (TokenType__openBracket__)) {
			Node__ local3;
			local3.dataPtr__ = (pointer__)(Parser__parseIndexExpression__(s__, lhs__));
			local3.id__ = local3.dataPtr__ != null__ ? Node_____Ptr__IndexExpression____ : 0;
			lhs__ = local3;
			goto label1;
		}
		if ((((s__)->token__)->type__) != (TokenType__operator__)) {
			return lhs__;
		}
		int__ level__ = Parser__getBindingLevel__(((s__)->token__)->value__);
		if (((level__)) < ((minLevel__))) {
			return lhs__;
		}
		if (string__equals__(((s__)->token__)->value__, mu_____string49)) {
			TernaryOperatorExpression__* local4 = (TernaryOperatorExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(TernaryOperatorExpression__));
			TernaryOperatorExpression__ local5;
			memset(&local5, 0, sizeof(TernaryOperatorExpression__));
			local5.conditionExpr__ = lhs__;
			local5.question__ = (s__)->token__;
			*local4 = local5;
			TernaryOperatorExpression__* result__ = local4;
			Parser__readToken__(s__);
			(result__)->trueExpr__ = Parser__parseExpression__(s__, 10);
			bool__ local6 = string__equals__(((s__)->token__)->value__, mu_____string30);
			if (local6) {
				local6 = ((((s__)->token__)->indent__)) > (((s__)->base__));
			}
			if (local6) {
				(result__)->colon__ = (s__)->token__;
				Parser__readToken__(s__);
				(result__)->falseExpr__ = Parser__parseExpression__(s__, 10);
			} else {
				Parser__expected__(s__, mu_____string30);
			}
			Node__ local7;
			local7.dataPtr__ = (pointer__)(result__);
			local7.id__ = local7.dataPtr__ != null__ ? Node_____Ptr__TernaryOperatorExpression____ : 0;
			lhs__ = local7;
		} else {
			if (string__equals__(((s__)->token__)->value__, mu_____string35)) {
				DotExpression__* local8 = (DotExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(DotExpression__));
				DotExpression__ local9;
				memset(&local9, 0, sizeof(DotExpression__));
				local9.lhs__ = lhs__;
				local9.dot__ = (s__)->token__;
				*local8 = local9;
				DotExpression__* result__ = local8;
				Parser__readToken__(s__);
				bool__ local10 = (((s__)->token__)->type__) == (TokenType__identifier__);
				if (local10) {
					local10 = ((((s__)->token__)->indent__)) > (((s__)->base__));
				}
				if (local10) {
					(result__)->rhs__ = (s__)->token__;
					Parser__readToken__(s__);
				} else {
					Parser__expected__(s__, mu_____string16);
				}
				Node__ local11;
				local11.dataPtr__ = (pointer__)(result__);
				local11.id__ = local11.dataPtr__ != null__ ? Node_____Ptr__DotExpression____ : 0;
				lhs__ = local11;
			} else {
				BinaryOperatorExpression__* local12 = (BinaryOperatorExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(BinaryOperatorExpression__));
				BinaryOperatorExpression__ local13;
				memset(&local13, 0, sizeof(BinaryOperatorExpression__));
				local13.lhs__ = lhs__;
				local13.op__ = (s__)->token__;
				*local12 = local13;
				BinaryOperatorExpression__* result__ = local12;
				Parser__readToken__(s__);
				(result__)->rhs__ = Parser__parseExpression__(s__, ((level__)) + ((1)));
				Node__ local14;
				local14.dataPtr__ = (pointer__)(result__);
				local14.id__ = local14.dataPtr__ != null__ ? Node_____Ptr__BinaryOperatorExpression____ : 0;
				lhs__ = local14;
			}
		}
	label1:
		{}
	}
}
Block__* Parser__block__(ParseState__* s__, bool__ statements__, string__ desc__) {
	Block__* local0 = (Block__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Block__));
	Block__ local1;
	memset(&local1, 0, sizeof(Block__));
	List__Node____* local2 = (List__Node____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Node____));
	List__Node____ local3;
	memset(&local3, 0, sizeof(List__Node____));
	*local2 = local3;
	local1.contents__ = local2;
	*local0 = local1;
	Block__* node__ = local0;
	bool__ local4 = (((s__)->token__)->type__) == (TokenType__openBrace__);
	if (local4) {
		local4 = ((((s__)->token__)->indent__)) >= (((s__)->base__));
	}
	if (local4) {
		(node__)->openBrace__ = (s__)->token__;
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string13);
	}
	if (((((s__)->token__)->indent__)) == ((Parser__sameLine__))) {
		if ((((s__)->token__)->type__) != (TokenType__closeBrace__)) {
			int__ prev__ = (s__)->base__;
			int__ prevBlock__ = (s__)->blockBase__;
			(s__)->base__ = Parser__maxBase__;
			(s__)->blockBase__ = Parser__maxBase__;
			if (statements__) {
				Parser__parseStatement__(s__, (node__)->contents__);
			} else {
				Parser__fieldDef__(s__, (node__)->contents__);
			}
			(s__)->base__ = prev__;
			(s__)->blockBase__ = prevBlock__;
		}
		bool__ local5 = (((s__)->token__)->type__) == (TokenType__closeBrace__);
		if (local5) {
			local5 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
		}
		if (local5) {
			(node__)->closeBrace__ = (s__)->token__;
			Parser__readToken__(s__);
			return node__;
		}
		while (true__) {
			if (!(((((s__)->token__)->indent__)) == ((Parser__sameLine__)))) { break; }
			Node__ local6;
			local6.dataPtr__ = (pointer__)((s__)->token__);
			local6.id__ = local6.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
			List__add__Node____((node__)->contents__, local6);
			Parser__readBadToken_newline__(s__);
		}
	}
	mu_____assert(((((s__)->token__)->indent__)) < ((Parser__sameLine__)));
	int__ firstIndent__ = ((s__)->token__)->indent__;
	while (true__) {
		if (!(((((s__)->token__)->indent__)) > (((s__)->base__)))) { break; }
		if ((((s__)->token__)->type__) == (TokenType__closeBrace__)) {
			if ((s__)->ignoreIndent__) {
				goto label2;
			}
			StringBuilder__ local7;
			memset(&local7, 0, sizeof(local7));
			string__ local8 = { (pointer__)"Expected: ", 10 };
			StringBuilder__write__(&local7, local8);
			StringBuilder__write__(&local7, desc__);
			string__ local9 = { (pointer__)", or: close brace must be indented less", 39 };
			StringBuilder__write__(&local7, local9);
			Parser__parseErrorToken__(s__, StringBuilder__compactToString__(&local7), (node__)->contents__);
		} else {
			if (((((s__)->token__)->indent__)) != ((firstIndent__))) {
				StringBuilder__ local10;
				memset(&local10, 0, sizeof(local10));
				string__ local11 = { (pointer__)"Incorrect indentation: must match previous ", 43 };
				StringBuilder__write__(&local10, local11);
				StringBuilder__write__(&local10, desc__);
				Parser__parseErrorToken__(s__, StringBuilder__compactToString__(&local10), (node__)->contents__);
			} else {
				int__ prev__ = (s__)->base__;
				int__ prevBlock__ = (s__)->blockBase__;
				int__ local12;
				if ((s__)->ignoreIndent__) {
					local12 = -1;
				} else {
					local12 = ((s__)->token__)->indent__;
				}
				(s__)->base__ = local12;
				(s__)->blockBase__ = (s__)->base__;
				if (statements__) {
					Parser__parseStatement__(s__, (node__)->contents__);
				} else {
					Parser__fieldDef__(s__, (node__)->contents__);
				}
				(s__)->base__ = prev__;
				(s__)->blockBase__ = prev__;
			}
		}
		while (true__) {
			if (!(((((s__)->token__)->indent__)) == ((Parser__sameLine__)))) { break; }
			Node__ local13;
			local13.dataPtr__ = (pointer__)((s__)->token__);
			local13.id__ = local13.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
			List__add__Node____((node__)->contents__, local13);
			Parser__readBadToken_newline__(s__);
		}
	}
label2:
	{}
	if ((((s__)->token__)->type__) == (TokenType__closeBrace__)) {
		if (((((s__)->token__)->indent__)) >= (((s__)->base__))) {
			(node__)->closeBrace__ = (s__)->token__;
			Parser__readToken__(s__);
		} else {
			Parser__errorAt__(s__, (((s__)->token__)->span__).from__, mu_____string67);
		}
	} else {
		Parser__expectedAt__(s__, (((s__)->token__)->span__).from__, mu_____string33);
	}
	return node__;
}
void__ Parser__parseClockStatement__(ParseState__* s__, List__Node____* out__) {
	ClockStatement__* local0 = (ClockStatement__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(ClockStatement__));
	ClockStatement__ local1;
	memset(&local1, 0, sizeof(ClockStatement__));
	local1.keyword__ = (s__)->token__;
	*local0 = local1;
	ClockStatement__* node__ = local0;
	Node__ local2;
	local2.dataPtr__ = (pointer__)(node__);
	local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__ClockStatement____ : 0;
	List__add__Node____(out__, local2);
	Parser__readToken__(s__);
	bool__ local3 = (((s__)->token__)->type__) == (TokenType__identifier__);
	if (local3) {
		local3 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
	}
	if (local3) {
		(node__)->name__ = (s__)->token__;
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string16);
	}
	(node__)->body__ = Parser__block__(s__, true__, mu_____string17);
}
StructInitializerExpression__* Parser__parseStructInitializerExpression__(ParseState__* s__, Node__ lhs__) {
	StructInitializerExpression__* local0 = (StructInitializerExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(StructInitializerExpression__));
	StructInitializerExpression__ local1;
	memset(&local1, 0, sizeof(StructInitializerExpression__));
	local1.target__ = lhs__;
	local1.openBrace__ = (s__)->token__;
	List__Ptr__CallArg______* local2 = (List__Ptr__CallArg______*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Ptr__CallArg______));
	List__Ptr__CallArg______ local3;
	memset(&local3, 0, sizeof(List__Ptr__CallArg______));
	*local2 = local3;
	local1.args__ = local2;
	List__Node____* local4 = (List__Node____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Node____));
	List__Node____ local5;
	memset(&local5, 0, sizeof(List__Node____));
	*local4 = local5;
	local1.contents__ = local4;
	*local0 = local1;
	StructInitializerExpression__* node__ = local0;
	Parser__readToken__(s__);
	int__ prev__ = (s__)->base__;
	(s__)->base__ = (s__)->blockBase__;
	ParseCommaListState__ state__ = ParseCommaListState__start__;
	while (true__) {
		bool__ local6 = ((((s__)->token__)->indent__)) > (((s__)->base__));
		if (local6) {
			local6 = (((s__)->token__)->type__) != (TokenType__closeBrace__);
		}
		if (!(local6)) { break; }
		if ((state__) != (ParseCommaListState__expectComma__)) {
			Parser__parseCallArg__(s__, (node__)->args__, (node__)->contents__);
			state__ = ParseCommaListState__expectComma__;
		} else {
			if (((((s__)->token__)->indent__)) == ((Parser__sameLine__))) {
				Parser__parseComma__(s__, (node__)->contents__);
			}
			state__ = ParseCommaListState__expectValue__;
		}
	}
	bool__ local7 = (((s__)->token__)->type__) == (TokenType__closeBrace__);
	if (local7) {
		local7 = ((((s__)->token__)->indent__)) >= (((s__)->base__));
	}
	if (local7) {
		(node__)->closeBrace__ = (s__)->token__;
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string33);
	}
	(s__)->base__ = prev__;
	return node__;
}
int__ Parser__parseNumberSuffix__(ParseState__* s__, string__ suffix__) {
	bool__ local0 = (((suffix__).length__)) > ((0));
	if (local0) {
		string__* local1 = &(suffix__);
		uint__ local2 = (uint__)(0);
		mu_____boundscheck(local2 < (uint__)local1->length__);
		local0 = (((char__*)local1->dataPtr__)[local2]) == ('$');
	}
	if (local0) {
		Maybe__int____ pr__ = int__tryParse__(string__slice__(suffix__, 1, (suffix__).length__));
		bool__ local3 = (pr__).hasValue__;
		if (local3) {
			local3 = (((pr__).value__)) > ((0));
		}
		if (local3) {
			return (pr__).value__;
		}
	}
	return 0;
}
void__ Parser__parseComma__(ParseState__* s__, List__Node____* out__) {
	if ((((s__)->token__)->type__) == (TokenType__comma__)) {
		Node__ local0;
		local0.dataPtr__ = (pointer__)((s__)->token__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		List__add__Node____(out__, local0);
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string31);
	}
}
void__ Parser__parseCallArg__(ParseState__* s__, List__Ptr__CallArg______* out_args__, List__Node____* out_all__) {
	int__ prev__ = (s__)->base__;
	(s__)->base__ = Parser__maxBase__;
	if ((((s__)->token__)->type__) == (TokenType__identifier__)) {
		CallArg__* local0 = (CallArg__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(CallArg__));
		CallArg__ local1;
		memset(&local1, 0, sizeof(CallArg__));
		*local0 = local1;
		CallArg__* node__ = local0;
		List__add__Ptr__CallArg______(out_args__, node__);
		Token__* name__ = (s__)->token__;
		Parser__readToken__(s__);
		bool__ local2 = string__equals__(((s__)->token__)->value__, mu_____string30);
		if (local2) {
			local2 = ((((s__)->token__)->indent__)) > (((s__)->base__));
		}
		if (local2) {
			(node__)->name__ = name__;
			(node__)->colon__ = (s__)->token__;
			Parser__readToken__(s__);
			(node__)->expr__ = Parser__parseExpression__(s__, 0);
		} else {
			Node__ local3;
			local3.dataPtr__ = (pointer__)(name__);
			local3.id__ = local3.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
			(node__)->expr__ = Parser__parseExpressionTail__(s__, local3, 0);
		}
	} else {
		bool__ local4 = (((s__)->token__)->type__) == (TokenType__comma__);
		if (local4) {
			local4 = ((((s__)->token__)->indent__)) == ((Parser__sameLine__));
		}
		if (local4) {
			Parser__expected__(s__, mu_____string19);
		} else {
			Node__ expr__ = Parser__parseExpression_alwaysProgress__(s__, 0, out_all__);
			if (((expr__).dataPtr__) != ((pointer__)(null__))) {
				CallArg__* local5 = (CallArg__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(CallArg__));
				CallArg__ local6;
				memset(&local6, 0, sizeof(CallArg__));
				local6.expr__ = expr__;
				*local5 = local6;
				CallArg__* node__ = local5;
				List__add__Ptr__CallArg______(out_args__, node__);
			}
		}
	}
	(s__)->base__ = prev__;
}
IndexExpression__* Parser__parseIndexExpression__(ParseState__* s__, Node__ lhs__) {
	IndexExpression__* local0 = (IndexExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(IndexExpression__));
	IndexExpression__ local1;
	memset(&local1, 0, sizeof(IndexExpression__));
	local1.target__ = lhs__;
	local1.openBracket__ = (s__)->token__;
	*local0 = local1;
	IndexExpression__* node__ = local0;
	Parser__readToken__(s__);
	int__ prev__ = (s__)->base__;
	(s__)->base__ = (s__)->blockBase__;
	(node__)->upperExpr__ = Parser__parseExpression__(s__, 0);
	bool__ local2 = string__equals__(((s__)->token__)->value__, mu_____string30);
	if (local2) {
		local2 = ((((s__)->token__)->indent__)) > (((s__)->base__));
	}
	if (local2) {
		(node__)->colon__ = (s__)->token__;
		Parser__readToken__(s__);
		(node__)->lowerExpr__ = Parser__parseExpression__(s__, 0);
	}
	bool__ local3 = (((s__)->token__)->type__) == (TokenType__closeBracket__);
	if (local3) {
		local3 = ((((s__)->token__)->indent__)) >= (((s__)->base__));
	}
	if (local3) {
		(node__)->closeBracket__ = (s__)->token__;
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string34);
	}
	(s__)->base__ = prev__;
	return node__;
}
void__ Parser__struct___(ParseState__* s__, Token__* name__, List__Node____* out__) {
	StructDef__* local0 = (StructDef__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(StructDef__));
	StructDef__ local1;
	memset(&local1, 0, sizeof(StructDef__));
	local1.name__ = name__;
	local1.keyword__ = (s__)->token__;
	local1.unit__ = (s__)->unit__;
	List__Ptr__FieldDef______* local2 = (List__Ptr__FieldDef______*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Ptr__FieldDef______));
	List__Ptr__FieldDef______ local3;
	memset(&local3, 0, sizeof(List__Ptr__FieldDef______));
	*local2 = local3;
	local1.fields__ = local2;
	*local0 = local1;
	StructDef__* node__ = local0;
	Node__ local4;
	local4.dataPtr__ = (pointer__)(node__);
	local4.id__ = local4.dataPtr__ != null__ ? Node_____Ptr__StructDef____ : 0;
	List__add__Node____(out__, local4);
	Parser__readToken__(s__);
	(s__)->struct___ = node__;
	(node__)->body__ = Parser__block__(s__, false__, mu_____string68);
	(s__)->struct___ = null__;
}
int__ Parser__getBindingLevel__(string__ op__) {
	if (string__equals__(op__, mu_____string35)) {
		return 20;
	}
	bool__ local1 = string__equals__(op__, mu_____string36);
	if (!local1) {
		local1 = string__equals__(op__, mu_____string37);
	}
	bool__ local0 = local1;
	if (!local0) {
		local0 = string__equals__(op__, mu_____string38);
	}
	if (local0) {
		return 19;
	}
	bool__ local2 = string__equals__(op__, mu_____string39);
	if (!local2) {
		local2 = string__equals__(op__, mu_____string2);
	}
	if (local2) {
		return 18;
	}
	bool__ local7 = string__equals__(op__, mu_____string40);
	if (!local7) {
		local7 = string__equals__(op__, mu_____string41);
	}
	bool__ local6 = local7;
	if (!local6) {
		local6 = string__equals__(op__, mu_____string42);
	}
	bool__ local5 = local6;
	if (!local5) {
		local5 = string__equals__(op__, mu_____string43);
	}
	bool__ local4 = local5;
	if (!local4) {
		local4 = string__equals__(op__, mu_____string44);
	}
	bool__ local3 = local4;
	if (!local3) {
		local3 = string__equals__(op__, mu_____string45);
	}
	if (local3) {
		return 17;
	}
	if (string__equals__(op__, mu_____string46)) {
		return 15;
	}
	if (string__equals__(op__, mu_____string47)) {
		return 14;
	}
	if (string__equals__(op__, mu_____string48)) {
		return 13;
	}
	if (string__equals__(op__, mu_____string49)) {
		return 10;
	}
	return -1;
}
void__ Parser__parseErrorToken__(ParseState__* s__, string__ text__, List__Node____* out__) {
	Parser__error__(s__, text__);
	Node__ local0;
	local0.dataPtr__ = (pointer__)((s__)->token__);
	local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
	List__add__Node____(out__, local0);
	Parser__readToken__(s__);
}
Node__ Parser__parseExpression_orNull__(ParseState__* s__, int__ minLevel__) {
	if (((((s__)->token__)->indent__)) <= (((s__)->base__))) {
		Node__ local0;
		local0.dataPtr__ = null__;
		local0.id__ = 0;
		return local0;
	}
	Node__ leaf__ = Parser__parseExpressionLeaf__(s__);
	if (((leaf__).dataPtr__) == ((pointer__)(null__))) {
		Node__ local1;
		local1.dataPtr__ = null__;
		local1.id__ = 0;
		return local1;
	}
	return Parser__parseExpressionTail__(s__, leaf__, minLevel__);
}
void__ Parser__expectedAt__(ParseState__* s__, int__ index__, string__ text__) {
	StringBuilder__ local0;
	memset(&local0, 0, sizeof(local0));
	string__ local1 = { (pointer__)"Expected: ", 10 };
	StringBuilder__write__(&local0, local1);
	StringBuilder__write__(&local0, text__);
	List__add__Error____((s__)->errors__, Error__atIndex__((s__)->unit__, index__, StringBuilder__compactToString__(&local0)));
}
void__ Parser__parseMatchExpressionCase__(ParseState__* s__, List__Ptr__MatchExpressionCase______* out_cases__, List__Node____* out_all__) {
	Node__ leaf__ = Parser__parseExpressionLeaf__(s__);
	if (((leaf__).dataPtr__) == ((pointer__)(null__))) {
		Node__ local0;
		local0.dataPtr__ = (pointer__)((s__)->token__);
		local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		List__add__Node____(out_all__, local0);
		Parser__error__(s__, mu_____string25);
		Parser__readToken__(s__);
		return;
	}
	MatchExpressionCase__* local1 = (MatchExpressionCase__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(MatchExpressionCase__));
	MatchExpressionCase__ local2;
	memset(&local2, 0, sizeof(MatchExpressionCase__));
	local2.valueExpr__ = Parser__parseExpressionTail__(s__, leaf__, 0);
	*local1 = local2;
	MatchExpressionCase__* node__ = local1;
	List__add__Ptr__MatchExpressionCase______(out_cases__, node__);
	Node__ local3;
	local3.dataPtr__ = (pointer__)(node__);
	local3.id__ = local3.dataPtr__ != null__ ? Node_____Ptr__MatchExpressionCase____ : 0;
	List__add__Node____(out_all__, local3);
	bool__ local4 = string__equals__(((s__)->token__)->value__, mu_____string30);
	if (local4) {
		local4 = ((((s__)->token__)->indent__)) > (((s__)->base__));
	}
	if (local4) {
		(node__)->colon__ = (s__)->token__;
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string30);
	}
	int__ prev__ = (s__)->base__;
	(s__)->base__ = Parser__maxBase__;
	(node__)->resultExpr__ = Parser__parseExpression__(s__, 0);
	(s__)->base__ = prev__;
}
ArrayExpression__* Parser__parseArrayExpression__(ParseState__* s__) {
	ArrayExpression__* local0 = (ArrayExpression__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(ArrayExpression__));
	ArrayExpression__ local1;
	memset(&local1, 0, sizeof(ArrayExpression__));
	local1.openBracket__ = (s__)->token__;
	List__Node____* local2 = (List__Node____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__Node____));
	List__Node____ local3;
	memset(&local3, 0, sizeof(List__Node____));
	*local2 = local3;
	local1.contents__ = local2;
	List__byte____* local4 = (List__byte____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(List__byte____));
	List__byte____ local5;
	memset(&local5, 0, sizeof(List__byte____));
	*local4 = local5;
	local1.data__ = local4;
	*local0 = local1;
	ArrayExpression__* node__ = local0;
	Parser__readToken__(s__);
	int__ prev__ = (s__)->base__;
	(s__)->base__ = (s__)->blockBase__;
	while (true__) {
		bool__ local6 = ((((s__)->token__)->indent__)) > (((s__)->base__));
		if (local6) {
			local6 = (((s__)->token__)->type__) != (TokenType__closeBracket__);
		}
		if (!(local6)) { break; }
		Node__ local7;
		local7.dataPtr__ = (pointer__)((s__)->token__);
		local7.id__ = local7.dataPtr__ != null__ ? Node_____Ptr__Token____ : 0;
		List__add__Node____((node__)->contents__, local7);
		string__ str__ = ((s__)->token__)->value__;
		{
			int__ i__ = 0;
			while (((i__)) < (((str__).length__))) {
				int__ to__ = ((i__)) + ((2));
				if (((to__)) <= (((str__).length__))) {
					Maybe__ulong____ val__ = ulong__tryParseHex__(string__slice__(str__, i__, to__));
					if ((val__).hasValue__) {
						ulong__ local8 = (val__).value__;
						mu_____checkedcast(local8 <= (ulong__)(0xff));
						List__add__byte____((node__)->data__, (byte__)(local8));
					} else {
						List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, IntRange__cons__((((((s__)->token__)->span__).from__)) + ((i__)), (((((s__)->token__)->span__).from__)) + ((to__))), mu_____string58));
					}
				} else {
					List__add__Error____((s__)->errors__, Error__at__((s__)->unit__, IntRange__cons__((((((s__)->token__)->span__).to__)) - ((1)), (((s__)->token__)->span__).to__), mu_____string58));
				}
				i__ = ((i__)) + ((2));
			}
		}
		Parser__readToken__(s__);
	}
	bool__ local9 = (((s__)->token__)->type__) == (TokenType__closeBracket__);
	if (local9) {
		local9 = ((((s__)->token__)->indent__)) >= (((s__)->base__));
	}
	if (local9) {
		(node__)->closeBracket__ = (s__)->token__;
		Parser__readToken__(s__);
	} else {
		Parser__expected__(s__, mu_____string34);
	}
	(s__)->base__ = prev__;
	return node__;
}
void__ Parser__parseStatement__(ParseState__* s__, List__Node____* out__) {
	bool__ local0 = string__equals__(((s__)->token__)->value__, mu_____string14);
	if (!local0) {
		local0 = string__equals__(((s__)->token__)->value__, mu_____string15);
	}
	if (local0) {
		Parser__parseClockStatement__(s__, out__);
	} else {
		if (string__equals__(((s__)->token__)->value__, mu_____string18)) {
			Node__ local1;
			local1.dataPtr__ = (pointer__)(Parser__parseIfStatement__(s__));
			local1.id__ = local1.dataPtr__ != null__ ? Node_____Ptr__IfStatement____ : 0;
			List__add__Node____(out__, local1);
		} else {
			if ((((s__)->token__)->type__) == (TokenType__identifier__)) {
				Token__* firstToken__ = (s__)->token__;
				(firstToken__)->indent__ = Parser__sameLine__;
				Parser__parseAssignStatement__(s__, out__);
				(firstToken__)->indent__ = (s__)->base__;
			} else {
				Parser__parseErrorToken__(s__, mu_____string62, out__);
			}
		}
	}
}
void__ Parser__readBadToken_newline__(ParseState__* s__) {
	Parser__readBadToken__(s__, mu_____string22);
}
Node__ Parser__parseExpression__(ParseState__* s__, int__ minLevel__) {
	if (((((s__)->token__)->indent__)) <= (((s__)->base__))) {
		Parser__expected__(s__, mu_____string19);
		Node__ local0;
		local0.dataPtr__ = null__;
		local0.id__ = 0;
		return local0;
	}
	Node__ leaf__ = Parser__parseExpressionLeaf__(s__);
	if (((leaf__).dataPtr__) == ((pointer__)(null__))) {
		Parser__expected__(s__, mu_____string19);
		Node__ local1;
		local1.dataPtr__ = null__;
		local1.id__ = 0;
		return local1;
	}
	return Parser__parseExpressionTail__(s__, leaf__, minLevel__);
}
void__ VerilogGenerator__unaryOperator__(GeneratorState__* s__, UnaryOperatorExpression__* e__) {
	if (string__equals__(((e__)->op__)->value__, mu_____string20)) {
		VerilogGenerator__expression__(s__, (e__)->expr__);
		return;
	}
	(s__)->isNonIndexable__ = true__;
	VerilogGenerator__write__(s__, ((e__)->op__)->value__);
	VerilogGenerator__write__(s__, mu_____string73);
	VerilogGenerator__expression__(s__, (e__)->expr__);
	VerilogGenerator__write__(s__, mu_____string32);
}
void__ VerilogGenerator__output__(GeneratorState__* s__, AssignStatement__* o__, string__ genName__, Tag__ tag__) {
	bool__ isReg__ = ((o__)->regKeyword__) != (null__);
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string245);
	if (isReg__) {
		VerilogGenerator__write__(s__, mu_____string246);
	}
	VerilogGenerator__numberTag__(s__, tag__);
	VerilogGenerator__write__(s__, genName__);
	if (isReg__) {
		bool__ local0 = (((o__)->expr__).dataPtr__) != ((pointer__)(null__));
		if (local0) {
			local0 = ((((o__)->flags__)) & ((AssignFlags__regUpdate__))) == (0);
		}
		if (local0) {
			VerilogGenerator__write__(s__, mu_____string247);
			VerilogGenerator__staticValue__(s__, (s__)->inst__, (o__)->localId__, tag__);
		} else {
			VerilogGenerator__write__(s__, mu_____string251);
		}
	}
}
void__ VerilogGenerator__regUpdate__(GeneratorState__* s__, string__ genName__, Node__ expr__) {
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, genName__);
	VerilogGenerator__write__(s__, mu_____string276);
	VerilogGenerator__expression__(s__, expr__);
	VerilogGenerator__write__(s__, mu_____string265);
}
string__ VerilogGenerator__newLocal__(GeneratorState__* s__, Tag__ tag__, string__ valStr__) {
	CodeBuilder__* prev__ = VerilogGenerator__push__(s__, (s__)->first__);
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string263);
	VerilogGenerator__numberTag__(s__, tag__);
	string__ name__ = VerilogGenerator__uniqueName__(s__, (s__)->inst__, ((s__)->inst__)->genLocalsSet__, mu_____string264);
	VerilogGenerator__write__(s__, name__);
	VerilogGenerator__write__(s__, mu_____string265);
	VerilogGenerator__restore__(s__, prev__);
	prev__ = VerilogGenerator__push__(s__, (s__)->assignments__);
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string266);
	VerilogGenerator__write__(s__, name__);
	VerilogGenerator__write__(s__, mu_____string247);
	VerilogGenerator__write__(s__, valStr__);
	VerilogGenerator__write__(s__, mu_____string265);
	VerilogGenerator__restore__(s__, prev__);
	return name__;
}
void__ VerilogGenerator__value__(GeneratorState__* s__, Tag__ tag__, Value__ value__) {
	(s__)->isNonIndexable__ = true__;
	mu_____assert(((tag__).kind__) == (TagKind__number__));
	if (((value__).kind__) == (ValueKind__ulong___)) {
		if ((((tag__).q__)) > ((0))) {
			StringBuilder__ local0;
			memset(&local0, 0, sizeof(local0));
			int__writeTo__((tag__).q__, &local0);
			string__ local1 = { (pointer__)"'d", 2 };
			StringBuilder__write__(&local0, local1);
			ulong__writeTo__((value__).z__, &local0);
			VerilogGenerator__write__(s__, StringBuilder__compactToString__(&local0));
		} else {
			StringBuilder__ local2;
			memset(&local2, 0, sizeof(local2));
			ulong__writeTo__((value__).z__, &local2);
			VerilogGenerator__write__(s__, StringBuilder__compactToString__(&local2));
		}
	} else {
		if (((value__).kind__) == (ValueKind__byteArray__)) {
			Array__byte____* data__ = EmulatorRunner__unpackArray__(value__);
			StringBuilder__ local3;
			memset(&local3, 0, sizeof(local3));
			int__writeTo__((tag__).q__, &local3);
			string__ local4 = { (pointer__)"'h", 2 };
			StringBuilder__write__(&local3, local4);
			VerilogGenerator__write__(s__, StringBuilder__compactToString__(&local3));
			int__ local5 = (((((tag__).q__)) + ((7)))) / ((8));
			int__ local6 = (data__)->count__;
			int__ from__ = (local5 < local6) ? local5 : local6;
			{
				int__ i__ = ((from__)) - ((1));
				while (((i__)) >= ((0))) {
					Array__byte____* local7 = data__;
					uint__ local8 = (uint__)(i__);
					mu_____boundscheck(local8 < (uint__)local7->count__);
					Util__writeByteHexTo__(((byte__*)local7->dataPtr__)[local8], ((s__)->out__)->sb__);
					i__ = ((i__)) - ((1));
				}
			}
		} else {
			mu_____abandon(-1);
		}
	}
}
void__ VerilogGenerator__assign__(GeneratorState__* s__, AssignStatement__* st__) {
	bool__ local0 = ((((st__)->flags__)) & ((AssignFlags__reg__))) != (0);
	if (local0) {
		local0 = ((st__)->outKeyword__) == (null__);
	}
	if (local0) {
		CodeBuilder__* prev__ = VerilogGenerator__push__(s__, (s__)->first__);
		Node__ local1 = (st__)->nameExpr__;
		mu_____checkedcast(local1.id__ == Node_____Ptr__Token____);
		string__ name__ = ((Token__*)(local1.dataPtr__))->value__;
		Node__ local2;
		local2.dataPtr__ = (pointer__)(st__);
		local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
		Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local2);
		if (((tag__).kind__) == (TagKind__number__)) {
			Node__ local3;
			local3.dataPtr__ = (pointer__)(st__);
			local3.id__ = local3.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
			VerilogGenerator__reg__(s__, st__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local3, -1, -1), tag__);
		} else {
			if (((tag__).kind__) == (TagKind__struct___)) {
				List__Node____* local5 = (s__)->entities__;
				uint__ local6 = (uint__)((tag__).q__);
				mu_____boundscheck(local6 < (uint__)local5->count__);
				Node__ local4 = ((Node__*)local5->dataPtr__)[local6];
				mu_____checkedcast(local4.id__ == Node_____Ptr__StructDef____);
				StructDef__* def__ = (StructDef__*)(local4.dataPtr__);
				{
					List__Ptr__FieldDef______* local7 = (def__)->fields__;
					int__ fi__ = 0;
					while (fi__ < local7->count__) {
						FieldDef__* f__ = ((FieldDef__**)(local7->dataPtr__))[fi__];
						(s__)->evalCtxField__ = fi__;
						Node__ local8;
						local8.dataPtr__ = (pointer__)(st__);
						local8.id__ = local8.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
						Node__ local9;
						local9.dataPtr__ = (pointer__)(f__);
						local9.id__ = local9.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
						VerilogGenerator__reg__(s__, st__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local8, -1, fi__), Map__get__Node__Tag____((s__)->typeMap__, local9));
						fi__ += 1;
					}
				}
				(s__)->evalCtxField__ = -1;
			} else {
				mu_____abandon(-1);
			}
		}
		VerilogGenerator__restore__(s__, prev__);
	}
	bool__ local10 = ((((st__)->flags__)) & ((AssignFlags__wire__))) != (0);
	if (local10) {
		local10 = ((((st__)->flags__)) & ((AssignFlags__static__))) == (0);
	}
	if (local10) {
		CodeBuilder__* prev__ = VerilogGenerator__push__(s__, (s__)->first__);
		Node__ local11;
		local11.dataPtr__ = (pointer__)(st__);
		local11.id__ = local11.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
		Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local11);
		if (((tag__).kind__) == (TagKind__number__)) {
			Node__ local12;
			local12.dataPtr__ = (pointer__)(st__);
			local12.id__ = local12.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
			VerilogGenerator__wire__(s__, st__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local12, -1, -1), tag__);
		} else {
			if (((tag__).kind__) == (TagKind__struct___)) {
				List__Node____* local14 = (s__)->entities__;
				uint__ local15 = (uint__)((tag__).q__);
				mu_____boundscheck(local15 < (uint__)local14->count__);
				Node__ local13 = ((Node__*)local14->dataPtr__)[local15];
				mu_____checkedcast(local13.id__ == Node_____Ptr__StructDef____);
				StructDef__* def__ = (StructDef__*)(local13.dataPtr__);
				{
					List__Ptr__FieldDef______* local16 = (def__)->fields__;
					int__ fi__ = 0;
					while (fi__ < local16->count__) {
						FieldDef__* f__ = ((FieldDef__**)(local16->dataPtr__))[fi__];
						(s__)->evalCtxField__ = fi__;
						Node__ local17;
						local17.dataPtr__ = (pointer__)(st__);
						local17.id__ = local17.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
						Node__ local18;
						local18.dataPtr__ = (pointer__)(f__);
						local18.id__ = local18.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
						VerilogGenerator__wire__(s__, st__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local17, -1, fi__), Map__get__Node__Tag____((s__)->typeMap__, local18));
						fi__ += 1;
					}
				}
				(s__)->evalCtxField__ = -1;
			} else {
				if (((tag__).kind__) == (TagKind__moduleOut__)) {
				} else {
					mu_____abandon(-1);
				}
			}
		}
		VerilogGenerator__restore__(s__, prev__);
	}
	if (((((st__)->flags__)) & ((AssignFlags__regUpdate__))) != (0)) {
		Node__ nameExpr__ = (st__)->nameExpr__;
		switch ((nameExpr__).id__) {
			case Node_____Ptr__Token____: {
				Token__* local19 = (Token__*)(nameExpr__.dataPtr__);
				{
					Node__ sym__ = Map__get__string__Node____((((s__)->inst__)->def__)->symbols__, (local19)->value__);
					Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, sym__);
					if (((tag__).kind__) == (TagKind__number__)) {
						VerilogGenerator__regUpdate__(s__, VerilogGenerator__nameOf__(s__, (s__)->inst__, sym__, -1, -1), (st__)->expr__);
					} else {
						if (((tag__).kind__) == (TagKind__struct___)) {
							List__Node____* local21 = (s__)->entities__;
							uint__ local22 = (uint__)((tag__).q__);
							mu_____boundscheck(local22 < (uint__)local21->count__);
							Node__ local20 = ((Node__*)local21->dataPtr__)[local22];
							mu_____checkedcast(local20.id__ == Node_____Ptr__StructDef____);
							StructDef__* def__ = (StructDef__*)(local20.dataPtr__);
							{
								List__Ptr__FieldDef______* local23 = (def__)->fields__;
								int__ fi__ = 0;
								while (fi__ < local23->count__) {
									FieldDef__* f__ = ((FieldDef__**)(local23->dataPtr__))[fi__];
									(s__)->evalCtxField__ = fi__;
									VerilogGenerator__regUpdate__(s__, VerilogGenerator__nameOf__(s__, (s__)->inst__, sym__, -1, fi__), (st__)->expr__);
									fi__ += 1;
								}
							}
							(s__)->evalCtxField__ = -1;
						} else {
							mu_____abandon(-1);
						}
					}
				}
				break;
			}
			case Node_____Ptr__DotExpression____: {
				DotExpression__* local24 = (DotExpression__*)(nameExpr__.dataPtr__);
				{
					DotExpression__* dot__ = local24;
					Node__ local25 = (dot__)->lhs__;
					mu_____checkedcast(local25.id__ == Node_____Ptr__Token____);
					Token__* nameToken__ = (Token__*)(local25.dataPtr__);
					Node__ sym__ = Map__getOrDefault__string__Node____((((s__)->inst__)->def__)->symbols__, (nameToken__)->value__);
					Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, sym__);
					StructDef__* sdef__ = VerilogGenerator__unpackStruct__(s__, tag__);
					int__ fieldIndex__ = (Map__get__string__Ptr__FieldDef______((sdef__)->symbols__, ((dot__)->rhs__)->value__))->fieldIndex__;
					VerilogGenerator__regUpdate__(s__, VerilogGenerator__nameOf__(s__, (s__)->inst__, sym__, -1, fieldIndex__), (st__)->expr__);
				}
				break;
			}
			case 0:
			default: {
				mu_____nomatch();
			}
		}
	}
}
void__ VerilogGenerator__binaryOperator__(GeneratorState__* s__, BinaryOperatorExpression__* e__) {
	(s__)->isNonIndexable__ = true__;
	VerilogGenerator__write__(s__, mu_____string73);
	VerilogGenerator__expression__(s__, (e__)->lhs__);
	VerilogGenerator__write__(s__, mu_____string259);
	VerilogGenerator__write__(s__, ((e__)->op__)->value__);
	VerilogGenerator__write__(s__, mu_____string260);
	VerilogGenerator__expression__(s__, (e__)->rhs__);
	VerilogGenerator__write__(s__, mu_____string32);
}
void__ VerilogGenerator__unindent__(GeneratorState__* s__) {
	((s__)->out__)->lineSep__ = mu_____string0;
	((s__)->out__)->indent__ = ((((s__)->out__)->indent__)) - ((1));
}
void__ VerilogGenerator__restore__(GeneratorState__* s__, CodeBuilder__* cb__) {
	(s__)->out__ = cb__;
}
void__ VerilogGenerator__reg__(GeneratorState__* s__, AssignStatement__* st__, string__ genName__, Tag__ tag__) {
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string275);
	VerilogGenerator__numberTag__(s__, tag__);
	VerilogGenerator__write__(s__, genName__);
	bool__ local0 = (((st__)->expr__).dataPtr__) != ((pointer__)(null__));
	if (local0) {
		local0 = ((((st__)->flags__)) & ((AssignFlags__regUpdate__))) == (0);
	}
	if (local0) {
		VerilogGenerator__write__(s__, mu_____string247);
		VerilogGenerator__staticValue__(s__, (s__)->inst__, (st__)->localId__, tag__);
	} else {
		VerilogGenerator__write__(s__, mu_____string251);
	}
	VerilogGenerator__write__(s__, mu_____string265);
}
void__ VerilogGenerator__expressionInner__(GeneratorState__* s__, Node__ e__) {
	switch ((e__).id__) {
		case Node_____Ptr__Token____: {
			Token__* local0 = (Token__*)(e__.dataPtr__);
			VerilogGenerator__token__(s__, local0);
			break;
		}
		case Node_____Ptr__NumberExpression____: {
			NumberExpression__* local1 = (NumberExpression__*)(e__.dataPtr__);
			VerilogGenerator__number__(s__, local1);
			break;
		}
		case Node_____Ptr__UnaryOperatorExpression____: {
			UnaryOperatorExpression__* local2 = (UnaryOperatorExpression__*)(e__.dataPtr__);
			VerilogGenerator__unaryOperator__(s__, local2);
			break;
		}
		case Node_____Ptr__BinaryOperatorExpression____: {
			BinaryOperatorExpression__* local3 = (BinaryOperatorExpression__*)(e__.dataPtr__);
			VerilogGenerator__binaryOperator__(s__, local3);
			break;
		}
		case Node_____Ptr__DotExpression____: {
			DotExpression__* local4 = (DotExpression__*)(e__.dataPtr__);
			VerilogGenerator__dot__(s__, local4);
			break;
		}
		case Node_____Ptr__TernaryOperatorExpression____: {
			TernaryOperatorExpression__* local5 = (TernaryOperatorExpression__*)(e__.dataPtr__);
			VerilogGenerator__ternaryOperator__(s__, local5);
			break;
		}
		case Node_____Ptr__MatchExpression____: {
			MatchExpression__* local6 = (MatchExpression__*)(e__.dataPtr__);
			VerilogGenerator__match___(s__, local6);
			break;
		}
		case Node_____Ptr__ParenExpression____: {
			ParenExpression__* local7 = (ParenExpression__*)(e__.dataPtr__);
			VerilogGenerator__paren__(s__, local7);
			break;
		}
		case Node_____Ptr__IndexExpression____: {
			IndexExpression__* local8 = (IndexExpression__*)(e__.dataPtr__);
			VerilogGenerator__index__(s__, local8);
			break;
		}
		case Node_____Ptr__CallExpression____: {
			CallExpression__* local9 = (CallExpression__*)(e__.dataPtr__);
			VerilogGenerator__call__(s__, local9);
			break;
		}
		case Node_____Ptr__StructInitializerExpression____: {
			StructInitializerExpression__* local10 = (StructInitializerExpression__*)(e__.dataPtr__);
			VerilogGenerator__structInit__(s__, local10);
			break;
		}
		case Node_____Ptr__BraceExpression____: {
			BraceExpression__* local11 = (BraceExpression__*)(e__.dataPtr__);
			VerilogGenerator__brace__(s__, local11);
			break;
		}
		case 0:
		default: {
			mu_____nomatch();
		}
	}
}
string__ VerilogGenerator__nameOf__(GeneratorState__* s__, ModuleInstance__* inst__, Node__ node__, int__ ctxOutput__, int__ ctxField__) {
	NodeWithCtx__ local0;
	memset(&local0, 0, sizeof(NodeWithCtx__));
	local0.node__ = node__;
	local0.ctxOutput__ = ctxOutput__;
	local0.ctxField__ = ctxField__;
	NodeWithCtx__ nc__ = local0;
	Maybe__string____ existingName__ = Map__maybeGet__NodeWithCtx__string____((inst__)->genLocals__, nc__);
	if ((existingName__).hasValue__) {
		return (existingName__).value__;
	}
	StringBuilder__ local1;
	memset(&local1, 0, sizeof(StringBuilder__));
	StringBuilder__ sb__ = local1;
	switch ((node__).id__) {
		case Node_____Ptr__ModuleInputDef____: {
			ModuleInputDef__* local2 = (ModuleInputDef__*)(node__.dataPtr__);
			{
				StringBuilder__write__(&(sb__), VerilogGenerator__trimHash__(((local2)->name__)->value__));
				if (((ctxField__)) != ((-1))) {
					StringBuilder__write__(&(sb__), mu_____string239);
					Node__ local4;
					local4.dataPtr__ = (pointer__)(local2);
					local4.id__ = local4.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
					List__Ptr__FieldDef______* local3 = (VerilogGenerator__unpackStruct__(s__, Map__get__Node__Tag____((s__)->typeMap__, local4)))->fields__;
					uint__ local5 = (uint__)(ctxField__);
					mu_____boundscheck(local5 < (uint__)local3->count__);
					StringBuilder__write__(&(sb__), ((((FieldDef__**)local3->dataPtr__)[local5])->name__)->value__);
				}
			}
			break;
		}
		case Node_____Ptr__AssignStatement____: {
			AssignStatement__* local6 = (AssignStatement__*)(node__.dataPtr__);
			{
				Node__ local7;
				local7.dataPtr__ = (pointer__)(local6);
				local7.id__ = local7.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
				mu_____assert(((Map__get__Node__Tag____((s__)->typeMap__, local7)).kind__) != (TagKind__moduleOut__));
				Node__ local8 = (local6)->nameExpr__;
				mu_____checkedcast(local8.id__ == Node_____Ptr__Token____);
				StringBuilder__write__(&(sb__), VerilogGenerator__trimHash__(((Token__*)(local8.dataPtr__))->value__));
				if (((ctxField__)) != ((-1))) {
					StringBuilder__write__(&(sb__), mu_____string239);
					Node__ local10;
					local10.dataPtr__ = (pointer__)(local6);
					local10.id__ = local10.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
					List__Ptr__FieldDef______* local9 = (VerilogGenerator__unpackStruct__(s__, Map__get__Node__Tag____((s__)->typeMap__, local10)))->fields__;
					uint__ local11 = (uint__)(ctxField__);
					mu_____boundscheck(local11 < (uint__)local9->count__);
					StringBuilder__write__(&(sb__), ((((FieldDef__**)local9->dataPtr__)[local11])->name__)->value__);
				}
			}
			break;
		}
		case Node_____Ptr__CallExpression____: {
			CallExpression__* local12 = (CallExpression__*)(node__.dataPtr__);
			{
				List__Ptr__ModuleInstance______* local13 = ((s__)->es__)->moduleInstances__;
				Array__int____* local15 = (inst__)->calls__;
				uint__ local16 = (uint__)((local12)->callId__);
				mu_____boundscheck(local16 < (uint__)local15->count__);
				uint__ local14 = (uint__)(((int__*)local15->dataPtr__)[local16]);
				mu_____boundscheck(local14 < (uint__)local13->count__);
				ModuleInstance__* target__ = ((ModuleInstance__**)local13->dataPtr__)[local14];
				List__Ptr__AssignStatement______* local17 = ((target__)->def__)->outputs__;
				uint__ local18 = (uint__)(ctxOutput__);
				mu_____boundscheck(local18 < (uint__)local17->count__);
				AssignStatement__* output__ = ((AssignStatement__**)local17->dataPtr__)[local18];
				StringBuilder__write__(&(sb__), (target__)->genLocalName__);
				StringBuilder__write__(&(sb__), mu_____string239);
				string__ local19;
				if ((((target__)->def__)->blackboxKeyword__) == (null__)) {
					Node__ local20;
					local20.dataPtr__ = (pointer__)(output__);
					local20.id__ = local20.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
					local19 = VerilogGenerator__nameOf__(s__, target__, local20, -1, ctxField__);
				} else {
					Node__ local21 = (output__)->nameExpr__;
					mu_____checkedcast(local21.id__ == Node_____Ptr__Token____);
					local19 = ((Token__*)(local21.dataPtr__))->value__;
				}
				StringBuilder__write__(&(sb__), local19);
			}
			break;
		}
		case 0:
		default: {
			mu_____nomatch();
			return mu_____string0;
		}
	}
	string__ name__ = VerilogGenerator__uniqueName__(s__, inst__, (inst__)->genLocalsSet__, StringBuilder__compactToString__(&(sb__)));
	Map__add__NodeWithCtx__string____((inst__)->genLocals__, nc__, name__);
	return name__;
}
void__ VerilogGenerator__wire__(GeneratorState__* s__, AssignStatement__* st__, string__ genName__, Tag__ tag__) {
	if (((st__)->outKeyword__) == (null__)) {
		VerilogGenerator__beginLine__(s__);
		VerilogGenerator__write__(s__, mu_____string263);
		VerilogGenerator__numberTag__(s__, tag__);
		VerilogGenerator__write__(s__, genName__);
		VerilogGenerator__write__(s__, mu_____string265);
	}
	CodeBuilder__* local0 = (CodeBuilder__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(CodeBuilder__));
	*local0 = CodeBuilder__create__();
	CodeBuilder__* cb__ = local0;
	CodeBuilder__* prev__ = VerilogGenerator__push__(s__, cb__);
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string266);
	VerilogGenerator__write__(s__, genName__);
	VerilogGenerator__write__(s__, mu_____string247);
	VerilogGenerator__expression__(s__, (st__)->expr__);
	VerilogGenerator__write__(s__, mu_____string265);
	(s__)->out__ = (s__)->assignments__;
	VerilogGenerator__write__(s__, StringBuilder__compactToString__((cb__)->sb__));
	VerilogGenerator__restore__(s__, prev__);
}
string__ VerilogGenerator__trimHash__(string__ s__) {
	string__* local0 = &(s__);
	uint__ local1 = (uint__)(0);
	mu_____boundscheck(local1 < (uint__)local0->length__);
	if ((((char__*)local0->dataPtr__)[local1]) == ('#')) {
		return string__slice__(s__, 1, (s__).length__);
	}
	return s__;
}
StructDef__* VerilogGenerator__unpackStruct__(GeneratorState__* s__, Tag__ tag__) {
	mu_____assert(((tag__).kind__) == (TagKind__struct___));
	List__Node____* local1 = (s__)->entities__;
	uint__ local2 = (uint__)((tag__).q__);
	mu_____boundscheck(local2 < (uint__)local1->count__);
	Node__ local0 = ((Node__*)local1->dataPtr__)[local2];
	mu_____checkedcast(local0.id__ == Node_____Ptr__StructDef____);
	return (StructDef__*)(local0.dataPtr__);
}
void__ VerilogGenerator__if___(GeneratorState__* s__, IfStatement__* st__) {
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string255);
	VerilogGenerator__expression__(s__, (st__)->expr__);
	VerilogGenerator__write__(s__, mu_____string254);
	VerilogGenerator__indent__(s__, mu_____string0);
	VerilogGenerator__block__(s__, (st__)->ifBody__);
	VerilogGenerator__unindent__(s__);
	if ((((st__)->elseBranch__).dataPtr__) != ((pointer__)(null__))) {
		VerilogGenerator__beginLine__(s__);
		VerilogGenerator__write__(s__, mu_____string274);
		VerilogGenerator__indent__(s__, mu_____string0);
		if (((st__)->elseBranch__).id__ == Node_____Ptr__IfStatement____) {
			Node__ local0 = (st__)->elseBranch__;
			mu_____checkedcast(local0.id__ == Node_____Ptr__IfStatement____);
			VerilogGenerator__if___(s__, (IfStatement__*)(local0.dataPtr__));
		} else {
			if (((st__)->elseBranch__).id__ == Node_____Ptr__Block____) {
				Node__ local1 = (st__)->elseBranch__;
				mu_____checkedcast(local1.id__ == Node_____Ptr__Block____);
				VerilogGenerator__block__(s__, (Block__*)(local1.dataPtr__));
			}
		}
		VerilogGenerator__unindent__(s__);
	}
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string234);
}
void__ VerilogGenerator__paren__(GeneratorState__* s__, ParenExpression__* e__) {
	(s__)->isNonIndexable__ = true__;
	VerilogGenerator__write__(s__, mu_____string73);
	VerilogGenerator__expression__(s__, (e__)->expr__);
	VerilogGenerator__write__(s__, mu_____string32);
}
void__ VerilogGenerator__module__(GeneratorState__* s__, ModuleInstance__* inst__) {
	(s__)->inst__ = inst__;
	ModuleDef__* def__ = (inst__)->def__;
	{
		int__ i__ = 1;
		while (((i__)) < ((((inst__)->calls__)->count__))) {
			List__Ptr__ModuleInstance______* local0 = ((s__)->es__)->moduleInstances__;
			Array__int____* local2 = (inst__)->calls__;
			uint__ local3 = (uint__)(i__);
			mu_____boundscheck(local3 < (uint__)local2->count__);
			uint__ local1 = (uint__)(((int__*)local2->dataPtr__)[local3]);
			mu_____boundscheck(local1 < (uint__)local0->count__);
			ModuleInstance__* mi__ = ((ModuleInstance__**)local0->dataPtr__)[local1];
			(mi__)->genLocalName__ = VerilogGenerator__uniqueName__(s__, (s__)->inst__, ((s__)->inst__)->genLocalsSet__, (mi__)->localName__);
			i__ += 1;
		}
	}
	VerilogGenerator__write__(s__, mu_____string241);
	VerilogGenerator__write__(s__, (inst__)->genGlobalName__);
	VerilogGenerator__write__(s__, mu_____string73);
	VerilogGenerator__indent__(s__, mu_____string31);
	{
		List__Ptr__ModuleInputDef______* local4 = (def__)->inputs__;
		int__ local5 = 0;
		while (local5 < local4->count__) {
			ModuleInputDef__* inp__ = ((ModuleInputDef__**)(local4->dataPtr__))[local5];
			if (((((inp__)->flags__)) & ((ModuleInputFlags__static__))) == (0)) {
				Node__ local6;
				local6.dataPtr__ = (pointer__)(inp__);
				local6.id__ = local6.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
				Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local6);
				if (((tag__).kind__) == (TagKind__number__)) {
					Node__ local7;
					local7.dataPtr__ = (pointer__)(inp__);
					local7.id__ = local7.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
					VerilogGenerator__input__(s__, inp__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local7, -1, -1), tag__);
				} else {
					if (((tag__).kind__) == (TagKind__struct___)) {
						List__Node____* local9 = (s__)->entities__;
						uint__ local10 = (uint__)((tag__).q__);
						mu_____boundscheck(local10 < (uint__)local9->count__);
						Node__ local8 = ((Node__*)local9->dataPtr__)[local10];
						mu_____checkedcast(local8.id__ == Node_____Ptr__StructDef____);
						StructDef__* sdef__ = (StructDef__*)(local8.dataPtr__);
						{
							List__Ptr__FieldDef______* local11 = (sdef__)->fields__;
							int__ fi__ = 0;
							while (fi__ < local11->count__) {
								FieldDef__* f__ = ((FieldDef__**)(local11->dataPtr__))[fi__];
								Node__ local12;
								local12.dataPtr__ = (pointer__)(inp__);
								local12.id__ = local12.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
								Node__ local13;
								local13.dataPtr__ = (pointer__)(f__);
								local13.id__ = local13.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
								VerilogGenerator__input__(s__, inp__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local12, -1, fi__), Map__get__Node__Tag____((s__)->typeMap__, local13));
								fi__ += 1;
							}
						}
					} else {
						mu_____abandon(-1);
					}
				}
			}
			local5 += 1;
		}
	}
	{
		List__Ptr__AssignStatement______* local14 = (def__)->outputs__;
		int__ local15 = 0;
		while (local15 < local14->count__) {
			AssignStatement__* o__ = ((AssignStatement__**)(local14->dataPtr__))[local15];
			Node__ local16;
			local16.dataPtr__ = (pointer__)(o__);
			local16.id__ = local16.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
			Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local16);
			if (((tag__).kind__) == (TagKind__number__)) {
				Node__ local17;
				local17.dataPtr__ = (pointer__)(o__);
				local17.id__ = local17.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
				VerilogGenerator__output__(s__, o__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local17, -1, -1), tag__);
			} else {
				if (((tag__).kind__) == (TagKind__struct___)) {
					List__Node____* local19 = (s__)->entities__;
					uint__ local20 = (uint__)((tag__).q__);
					mu_____boundscheck(local20 < (uint__)local19->count__);
					Node__ local18 = ((Node__*)local19->dataPtr__)[local20];
					mu_____checkedcast(local18.id__ == Node_____Ptr__StructDef____);
					StructDef__* sdef__ = (StructDef__*)(local18.dataPtr__);
					{
						List__Ptr__FieldDef______* local21 = (sdef__)->fields__;
						int__ fi__ = 0;
						while (fi__ < local21->count__) {
							FieldDef__* f__ = ((FieldDef__**)(local21->dataPtr__))[fi__];
							(s__)->evalCtxField__ = fi__;
							Node__ local22;
							local22.dataPtr__ = (pointer__)(o__);
							local22.id__ = local22.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
							Node__ local23;
							local23.dataPtr__ = (pointer__)(f__);
							local23.id__ = local23.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
							VerilogGenerator__output__(s__, o__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local22, -1, fi__), Map__get__Node__Tag____((s__)->typeMap__, local23));
							fi__ += 1;
						}
					}
					(s__)->evalCtxField__ = -1;
				} else {
					mu_____abandon(-1);
				}
			}
			local15 += 1;
		}
	}
	VerilogGenerator__unindent__(s__);
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string252);
	CodeBuilder__* local24 = (CodeBuilder__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(CodeBuilder__));
	*local24 = CodeBuilder__create__();
	(s__)->assignments__ = local24;
	CodeBuilder__* local25 = (CodeBuilder__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(CodeBuilder__));
	*local25 = CodeBuilder__create__();
	(s__)->regUpdates__ = local25;
	(s__)->first__ = VerilogGenerator__push__(s__, (s__)->regUpdates__);
	int__ firstPos__ = (((s__)->first__)->sb__)->count__;
	VerilogGenerator__block__(s__, (def__)->body__);
	if ((((((s__)->regUpdates__)->sb__)->count__)) > ((0))) {
		VerilogGenerator__beginLine__(s__);
	}
	{
		int__ i__ = 1;
		while (((i__)) < ((((inst__)->calls__)->count__))) {
			List__Ptr__ModuleInstance______* local26 = ((s__)->es__)->moduleInstances__;
			Array__int____* local28 = (inst__)->calls__;
			uint__ local29 = (uint__)(i__);
			mu_____boundscheck(local29 < (uint__)local28->count__);
			uint__ local27 = (uint__)(((int__*)local28->dataPtr__)[local29]);
			mu_____boundscheck(local27 < (uint__)local26->count__);
			VerilogGenerator__callInst__(s__, ((ModuleInstance__**)local26->dataPtr__)[local27]);
			i__ += 1;
		}
	}
	VerilogGenerator__restore__(s__, (s__)->first__);
	if ((((((s__)->first__)->sb__)->count__)) != ((firstPos__))) {
		VerilogGenerator__beginLine__(s__);
	}
	string__ str__ = StringBuilder__compactToString__(((s__)->assignments__)->sb__);
	if (!string__equals__(str__, mu_____string0)) {
		VerilogGenerator__write__(s__, str__);
		VerilogGenerator__beginLine__(s__);
	}
	str__ = StringBuilder__compactToString__(((s__)->regUpdates__)->sb__);
	if (!string__equals__(str__, mu_____string0)) {
		VerilogGenerator__write__(s__, str__);
	}
	if (((((inst__)->calls__)->count__)) == ((0))) {
		VerilogGenerator__beginLine__(s__);
	}
	VerilogGenerator__write__(s__, mu_____string280);
}
void__ VerilogGenerator__callInst__(GeneratorState__* s__, ModuleInstance__* target__) {
	ModuleDef__* def__ = (target__)->def__;
	CallExpression__* callExpr__ = (target__)->callExpr__;
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string277);
	VerilogGenerator__write__(s__, (target__)->genGlobalName__);
	VerilogGenerator__write__(s__, mu_____string78);
	if (((def__)->blackboxKeyword__) != (null__)) {
		if (VerilogGenerator__hasStaticInputs__(s__, def__)) {
			VerilogGenerator__write__(s__, mu_____string278);
			VerilogGenerator__indent__(s__, mu_____string31);
			{
				List__Ptr__ModuleInputDef______* local0 = (def__)->inputs__;
				int__ local1 = 0;
				while (local1 < local0->count__) {
					ModuleInputDef__* inp__ = ((ModuleInputDef__**)(local0->dataPtr__))[local1];
					if (((((inp__)->flags__)) & ((ModuleInputFlags__static__))) != (0)) {
						Node__ local2;
						local2.dataPtr__ = (pointer__)(inp__);
						local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
						Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local2);
						VerilogGenerator__beginLine__(s__);
						VerilogGenerator__write__(s__, mu_____string35);
						VerilogGenerator__write__(s__, VerilogGenerator__trimHash__(((inp__)->name__)->value__));
						VerilogGenerator__write__(s__, mu_____string73);
						VerilogGenerator__staticValue__(s__, target__, (inp__)->localId__, tag__);
						VerilogGenerator__write__(s__, mu_____string32);
					}
					local1 += 1;
				}
			}
			VerilogGenerator__unindent__(s__);
			VerilogGenerator__beginLine__(s__);
			VerilogGenerator__write__(s__, mu_____string259);
		}
	}
	VerilogGenerator__write__(s__, (target__)->genLocalName__);
	VerilogGenerator__write__(s__, mu_____string73);
	VerilogGenerator__indent__(s__, mu_____string31);
	{
		List__Ptr__ModuleInputDef______* local3 = (def__)->inputs__;
		int__ local4 = 0;
		while (local4 < local3->count__) {
			ModuleInputDef__* inp__ = ((ModuleInputDef__**)(local3->dataPtr__))[local4];
			if (((((inp__)->flags__)) & ((ModuleInputFlags__static__))) == (0)) {
				Node__ local5;
				local5.dataPtr__ = (pointer__)(inp__);
				local5.id__ = local5.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
				Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local5);
				if (((tag__).kind__) == (TagKind__number__)) {
					VerilogGenerator__beginLine__(s__);
					VerilogGenerator__write__(s__, mu_____string35);
					string__ local6;
					if (((def__)->blackboxKeyword__) == (null__)) {
						Node__ local7;
						local7.dataPtr__ = (pointer__)(inp__);
						local7.id__ = local7.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
						local6 = VerilogGenerator__nameOf__(s__, target__, local7, -1, -1);
					} else {
						local6 = ((inp__)->name__)->value__;
					}
					VerilogGenerator__write__(s__, local6);
					VerilogGenerator__write__(s__, mu_____string73);
					List__Ptr__CallArg______* local8 = (callExpr__)->args__;
					Array__int____* local10 = (callExpr__)->calleeLocalIdToArgIndex__;
					uint__ local11 = (uint__)((inp__)->localId__);
					mu_____boundscheck(local11 < (uint__)local10->count__);
					uint__ local9 = (uint__)(((int__*)local10->dataPtr__)[local11]);
					mu_____boundscheck(local9 < (uint__)local8->count__);
					VerilogGenerator__expression__(s__, (((CallArg__**)local8->dataPtr__)[local9])->expr__);
					VerilogGenerator__write__(s__, mu_____string32);
				} else {
					if (((tag__).kind__) == (TagKind__struct___)) {
						StructDef__* sdef__ = VerilogGenerator__unpackStruct__(s__, tag__);
						{
							List__Ptr__FieldDef______* local12 = (sdef__)->fields__;
							int__ i__ = 0;
							while (i__ < local12->count__) {
								FieldDef__* f__ = ((FieldDef__**)(local12->dataPtr__))[i__];
								VerilogGenerator__beginLine__(s__);
								VerilogGenerator__write__(s__, mu_____string35);
								string__ local13;
								if (((def__)->blackboxKeyword__) == (null__)) {
									Node__ local14;
									local14.dataPtr__ = (pointer__)(inp__);
									local14.id__ = local14.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
									local13 = VerilogGenerator__nameOf__(s__, target__, local14, -1, i__);
								} else {
									local13 = ((inp__)->name__)->value__;
								}
								VerilogGenerator__write__(s__, local13);
								VerilogGenerator__write__(s__, mu_____string73);
								(s__)->evalCtxField__ = i__;
								List__Ptr__CallArg______* local15 = (callExpr__)->args__;
								Array__int____* local17 = (callExpr__)->calleeLocalIdToArgIndex__;
								uint__ local18 = (uint__)((inp__)->localId__);
								mu_____boundscheck(local18 < (uint__)local17->count__);
								uint__ local16 = (uint__)(((int__*)local17->dataPtr__)[local18]);
								mu_____boundscheck(local16 < (uint__)local15->count__);
								VerilogGenerator__expression__(s__, (((CallArg__**)local15->dataPtr__)[local16])->expr__);
								VerilogGenerator__write__(s__, mu_____string32);
								i__ += 1;
							}
						}
						(s__)->evalCtxField__ = -1;
					} else {
						mu_____abandon(-1);
					}
				}
			}
			local4 += 1;
		}
	}
	{
		List__Ptr__AssignStatement______* local19 = (def__)->outputs__;
		int__ oi__ = 0;
		while (oi__ < local19->count__) {
			AssignStatement__* o__ = ((AssignStatement__**)(local19->dataPtr__))[oi__];
			Node__ local20;
			local20.dataPtr__ = (pointer__)(o__);
			local20.id__ = local20.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
			Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local20);
			if (((tag__).kind__) == (TagKind__number__)) {
				VerilogGenerator__beginLine__(s__);
				VerilogGenerator__write__(s__, mu_____string35);
				string__ local21;
				if (((def__)->blackboxKeyword__) == (null__)) {
					Node__ local22;
					local22.dataPtr__ = (pointer__)(o__);
					local22.id__ = local22.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
					local21 = VerilogGenerator__nameOf__(s__, target__, local22, -1, -1);
				} else {
					Node__ local23 = (o__)->nameExpr__;
					mu_____checkedcast(local23.id__ == Node_____Ptr__Token____);
					local21 = ((Token__*)(local23.dataPtr__))->value__;
				}
				VerilogGenerator__write__(s__, local21);
				VerilogGenerator__write__(s__, mu_____string73);
				Node__ local24;
				local24.dataPtr__ = (pointer__)(callExpr__);
				local24.id__ = local24.dataPtr__ != null__ ? Node_____Ptr__CallExpression____ : 0;
				VerilogGenerator__write__(s__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local24, oi__, -1));
				VerilogGenerator__write__(s__, mu_____string32);
			} else {
				if (((tag__).kind__) == (TagKind__struct___)) {
					StructDef__* sdef__ = VerilogGenerator__unpackStruct__(s__, tag__);
					{
						List__Ptr__FieldDef______* local25 = (sdef__)->fields__;
						int__ fi__ = 0;
						while (fi__ < local25->count__) {
							FieldDef__* f__ = ((FieldDef__**)(local25->dataPtr__))[fi__];
							VerilogGenerator__beginLine__(s__);
							VerilogGenerator__write__(s__, mu_____string35);
							string__ local26;
							if (((def__)->blackboxKeyword__) == (null__)) {
								Node__ local27;
								local27.dataPtr__ = (pointer__)(o__);
								local27.id__ = local27.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
								local26 = VerilogGenerator__nameOf__(s__, target__, local27, -1, fi__);
							} else {
								Node__ local28 = (o__)->nameExpr__;
								mu_____checkedcast(local28.id__ == Node_____Ptr__Token____);
								local26 = ((Token__*)(local28.dataPtr__))->value__;
							}
							VerilogGenerator__write__(s__, local26);
							VerilogGenerator__write__(s__, mu_____string73);
							Node__ local29;
							local29.dataPtr__ = (pointer__)(callExpr__);
							local29.id__ = local29.dataPtr__ != null__ ? Node_____Ptr__CallExpression____ : 0;
							VerilogGenerator__write__(s__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local29, oi__, fi__));
							VerilogGenerator__write__(s__, mu_____string32);
							fi__ += 1;
						}
					}
				} else {
					mu_____abandon(-1);
				}
			}
			oi__ += 1;
		}
	}
	VerilogGenerator__unindent__(s__);
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string279);
	CodeBuilder__* prev__ = VerilogGenerator__push__(s__, (s__)->first__);
	{
		List__Ptr__AssignStatement______* local30 = (def__)->outputs__;
		int__ oi__ = 0;
		while (oi__ < local30->count__) {
			AssignStatement__* o__ = ((AssignStatement__**)(local30->dataPtr__))[oi__];
			Node__ local31;
			local31.dataPtr__ = (pointer__)(o__);
			local31.id__ = local31.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
			Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local31);
			if (((tag__).kind__) == (TagKind__number__)) {
				VerilogGenerator__beginLine__(s__);
				VerilogGenerator__write__(s__, mu_____string263);
				VerilogGenerator__numberTag__(s__, tag__);
				Node__ local32;
				local32.dataPtr__ = (pointer__)(callExpr__);
				local32.id__ = local32.dataPtr__ != null__ ? Node_____Ptr__CallExpression____ : 0;
				VerilogGenerator__write__(s__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local32, oi__, -1));
				VerilogGenerator__write__(s__, mu_____string265);
			} else {
				if (((tag__).kind__) == (TagKind__struct___)) {
					StructDef__* sdef__ = VerilogGenerator__unpackStruct__(s__, tag__);
					{
						List__Ptr__FieldDef______* local33 = (sdef__)->fields__;
						int__ fi__ = 0;
						while (fi__ < local33->count__) {
							FieldDef__* f__ = ((FieldDef__**)(local33->dataPtr__))[fi__];
							VerilogGenerator__beginLine__(s__);
							VerilogGenerator__write__(s__, mu_____string263);
							Node__ local34;
							local34.dataPtr__ = (pointer__)(f__);
							local34.id__ = local34.dataPtr__ != null__ ? Node_____Ptr__FieldDef____ : 0;
							VerilogGenerator__numberTag__(s__, Map__get__Node__Tag____((s__)->typeMap__, local34));
							Node__ local35;
							local35.dataPtr__ = (pointer__)(callExpr__);
							local35.id__ = local35.dataPtr__ != null__ ? Node_____Ptr__CallExpression____ : 0;
							VerilogGenerator__write__(s__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local35, oi__, fi__));
							VerilogGenerator__write__(s__, mu_____string265);
							fi__ += 1;
						}
					}
				} else {
					mu_____abandon(-1);
				}
			}
			oi__ += 1;
		}
	}
	VerilogGenerator__restore__(s__, prev__);
	VerilogGenerator__beginLine__(s__);
}
void__ VerilogGenerator__clock__(GeneratorState__* s__, ClockStatement__* st__) {
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string253);
	VerilogGenerator__write__(s__, ((st__)->keyword__)->value__);
	VerilogGenerator__write__(s__, mu_____string78);
	VerilogGenerator__write__(s__, ((st__)->name__)->value__);
	VerilogGenerator__write__(s__, mu_____string254);
	VerilogGenerator__indent__(s__, mu_____string0);
	VerilogGenerator__block__(s__, (st__)->body__);
	VerilogGenerator__unindent__(s__);
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string234);
}
void__ VerilogGenerator__number__(GeneratorState__* s__, NumberExpression__* e__) {
	(s__)->isNonIndexable__ = true__;
	StringBuilder__* sb__ = ((s__)->out__)->sb__;
	bool__ local0 = (((s__)->evalCtxField__)) == ((-1));
	if (local0) {
		local0 = (((s__)->evalCtxOutput__)) == ((-1));
	}
	mu_____assert(local0);
	mu_____assert((((e__)->dontCare__)) != ((ulong__)(0)));
	Node__ local1;
	local1.dataPtr__ = (pointer__)(e__);
	local1.id__ = local1.dataPtr__ != null__ ? Node_____Ptr__NumberExpression____ : 0;
	Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, local1);
	mu_____assert(((tag__).kind__) == (TagKind__number__));
	mu_____assert((((tag__).q__)) > ((0)));
	ulong__ mask__ = ((ulong__)1uLL) << ((((tag__).q__)) - ((1)));
	int__writeTo__((tag__).q__, sb__);
	StringBuilder__write__(sb__, mu_____string256);
	while (true__) {
		if (!(((mask__)) != ((ulong__)(0)))) { break; }
		if (((((mask__)) & (((e__)->dontCare__)))) != ((ulong__)(0))) {
			StringBuilder__write__(sb__, mu_____string257);
		} else {
			if (((((mask__)) & (((e__)->value__)))) != ((ulong__)(0))) {
				StringBuilder__write__(sb__, mu_____string258);
			} else {
				StringBuilder__write__(sb__, mu_____string1);
			}
		}
		mask__ = ((ulong__)mask__) >> (1);
	}
}
void__ VerilogGenerator__dot__(GeneratorState__* s__, DotExpression__* e__) {
	Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, (e__)->lhs__);
	if (((tag__).kind__) == (TagKind__struct___)) {
		mu_____assert((((s__)->evalCtxField__)) == ((-1)));
		List__Node____* local1 = (s__)->entities__;
		uint__ local2 = (uint__)((tag__).q__);
		mu_____boundscheck(local2 < (uint__)local1->count__);
		Node__ local0 = ((Node__*)local1->dataPtr__)[local2];
		mu_____checkedcast(local0.id__ == Node_____Ptr__StructDef____);
		StructDef__* def__ = (StructDef__*)(local0.dataPtr__);
		(s__)->evalCtxField__ = (Map__get__string__Ptr__FieldDef______((def__)->symbols__, ((e__)->rhs__)->value__))->fieldIndex__;
		VerilogGenerator__expression__(s__, (e__)->lhs__);
		(s__)->evalCtxField__ = -1;
	} else {
		if (((tag__).kind__) == (TagKind__moduleOut__)) {
			mu_____assert((((s__)->evalCtxOutput__)) == ((-1)));
			List__Node____* local4 = (s__)->entities__;
			uint__ local5 = (uint__)((tag__).q__);
			mu_____boundscheck(local5 < (uint__)local4->count__);
			Node__ local3 = ((Node__*)local4->dataPtr__)[local5];
			mu_____checkedcast(local3.id__ == Node_____Ptr__ModuleDef____);
			ModuleDef__* def__ = (ModuleDef__*)(local3.dataPtr__);
			Node__ local6 = Map__get__string__Node____((def__)->symbols__, ((e__)->rhs__)->value__);
			mu_____checkedcast(local6.id__ == Node_____Ptr__AssignStatement____);
			(s__)->evalCtxOutput__ = ((AssignStatement__*)(local6.dataPtr__))->outputIndex__;
			VerilogGenerator__expression__(s__, (e__)->lhs__);
			(s__)->evalCtxOutput__ = -1;
		} else {
			mu_____abandon(-1);
		}
	}
}
void__ VerilogGenerator__block__(GeneratorState__* s__, Block__* block__) {
	{
		List__Node____* local0 = (block__)->contents__;
		int__ local1 = 0;
		while (local1 < local0->count__) {
			Node__ n__ = ((Node__*)(local0->dataPtr__))[local1];
			switch ((n__).id__) {
				case Node_____Ptr__ClockStatement____: {
					ClockStatement__* local2 = (ClockStatement__*)(n__.dataPtr__);
					VerilogGenerator__clock__(s__, local2);
					break;
				}
				case Node_____Ptr__IfStatement____: {
					IfStatement__* local3 = (IfStatement__*)(n__.dataPtr__);
					VerilogGenerator__if___(s__, local3);
					break;
				}
				case Node_____Ptr__AssignStatement____: {
					AssignStatement__* local4 = (AssignStatement__*)(n__.dataPtr__);
					VerilogGenerator__assign__(s__, local4);
					break;
				}
				case 0:
				default: {
					mu_____nomatch();
				}
			}
			local1 += 1;
		}
	}
}
void__ VerilogGenerator__rep__(GeneratorState__* s__, CallExpression__* e__) {
	(s__)->isNonIndexable__ = true__;
	List__Ptr__CallArg______* local0 = (e__)->args__;
	uint__ local1 = (uint__)(1);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	int__ n__ = TypeChecker__unpackInt__(Map__get__Node__Value____((s__)->constMap__, (((CallArg__**)local0->dataPtr__)[local1])->expr__));
	VerilogGenerator__write__(s__, mu_____string272);
	bool__ sep__ = false__;
	{
		int__ i__ = 0;
		while (((i__)) < ((n__))) {
			if (sep__) {
				VerilogGenerator__write__(s__, mu_____string197);
			} else {
				sep__ = true__;
			}
			List__Ptr__CallArg______* local2 = (e__)->args__;
			uint__ local3 = (uint__)(0);
			mu_____boundscheck(local3 < (uint__)local2->count__);
			VerilogGenerator__expression__(s__, (((CallArg__**)local2->dataPtr__)[local3])->expr__);
			i__ += 1;
		}
	}
	VerilogGenerator__write__(s__, mu_____string273);
}
void__ VerilogGenerator__structInit__(GeneratorState__* s__, StructInitializerExpression__* e__) {
	mu_____assert((((s__)->evalCtxField__)) >= ((0)));
	Node__ local0;
	local0.dataPtr__ = (pointer__)(e__);
	local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__StructInitializerExpression____ : 0;
	StructDef__* def__ = VerilogGenerator__unpackStruct__(s__, Map__get__Node__Tag____((s__)->typeMap__, local0));
	Array__int____* local1 = (e__)->fieldIndexToArgIndex__;
	uint__ local2 = (uint__)((s__)->evalCtxField__);
	mu_____boundscheck(local2 < (uint__)local1->count__);
	int__ argIndex__ = ((int__*)local1->dataPtr__)[local2];
	if (((argIndex__)) >= ((0))) {
		List__Ptr__CallArg______* local3 = (e__)->args__;
		uint__ local4 = (uint__)(argIndex__);
		mu_____boundscheck(local4 < (uint__)local3->count__);
		Node__ arg__ = (((CallArg__**)local3->dataPtr__)[local4])->expr__;
		int__ prevCtxField__ = (s__)->evalCtxField__;
		(s__)->evalCtxField__ = -1;
		VerilogGenerator__expression__(s__, arg__);
		(s__)->evalCtxField__ = prevCtxField__;
	} else {
		(s__)->isNonIndexable__ = true__;
		VerilogGenerator__write__(s__, mu_____string1);
	}
}
void__ VerilogGenerator__numberTag__(GeneratorState__* s__, Tag__ tag__) {
	mu_____assert(((tag__).kind__) == (TagKind__number__));
	mu_____assert((((tag__).q__)) > ((0)));
	if ((((tag__).q__)) > ((1))) {
		StringBuilder__ local0;
		memset(&local0, 0, sizeof(local0));
		string__ local1 = { (pointer__)"[", 1 };
		StringBuilder__write__(&local0, local1);
		int__writeTo__((((tag__).q__)) - ((1)), &local0);
		string__ local2 = { (pointer__)":0] ", 4 };
		StringBuilder__write__(&local0, local2);
		VerilogGenerator__write__(s__, StringBuilder__compactToString__(&local0));
	}
}
string__ VerilogGenerator__uniqueName__(GeneratorState__* s__, ModuleInstance__* inst__, Set__string____* set__, string__ origName__) {
	string__ name__ = origName__;
	int__ i__ = 1;
	while (true__) {
		if (!(true__)) { break; }
		bool__ local0 = !(Set__contains__string____((s__)->globals__, name__));
		if (local0) {
			local0 = !(Set__contains__string____((inst__)->genLocalsSet__, name__));
		}
		if (local0) {
			Set__add__string____(set__, name__);
			return name__;
		}
		StringBuilder__ local1;
		memset(&local1, 0, sizeof(local1));
		StringBuilder__write__(&local1, origName__);
		string__ local2 = { (pointer__)"_", 1 };
		StringBuilder__write__(&local1, local2);
		int__writeTo__(i__, &local1);
		name__ = StringBuilder__compactToString__(&local1);
		i__ = ((i__)) + ((1));
	}
}
void__ VerilogGenerator__write__(GeneratorState__* s__, string__ str__) {
	StringBuilder__write__(((s__)->out__)->sb__, str__);
}
CodeBuilder__* VerilogGenerator__push__(GeneratorState__* s__, CodeBuilder__* cb__) {
	CodeBuilder__* prev__ = (s__)->out__;
	(s__)->out__ = cb__;
	return prev__;
}
void__ VerilogGenerator__call__(GeneratorState__* s__, CallExpression__* e__) {
	if (((e__)->builtin__) == (BuiltinCall__rep__)) {
		VerilogGenerator__rep__(s__, e__);
		return;
	}
	mu_____assert(((e__)->builtin__) == (BuiltinCall__none__));
	mu_____assert((((s__)->evalCtxOutput__)) >= ((0)));
	Node__ local0;
	local0.dataPtr__ = (pointer__)(e__);
	local0.id__ = local0.dataPtr__ != null__ ? Node_____Ptr__CallExpression____ : 0;
	VerilogGenerator__write__(s__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local0, (s__)->evalCtxOutput__, (s__)->evalCtxField__));
}
CodeBuilder__* VerilogGenerator__comp__(Compilation__* comp__, EmulatorState__* es__) {
	GeneratorState__* local0 = (GeneratorState__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(GeneratorState__));
	GeneratorState__ local1;
	memset(&local1, 0, sizeof(GeneratorState__));
	local1.comp__ = comp__;
	local1.symbols__ = (comp__)->symbols__;
	local1.typeMap__ = (comp__)->typeMap__;
	local1.constMap__ = (comp__)->constMap__;
	local1.entities__ = (comp__)->entities__;
	local1.errors__ = (comp__)->errors__;
	local1.es__ = es__;
	local1.evalCtxOutput__ = -1;
	local1.evalCtxField__ = -1;
	CodeBuilder__* local2 = (CodeBuilder__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(CodeBuilder__));
	*local2 = CodeBuilder__create__();
	local1.out__ = local2;
	Set__string____* local3 = (Set__string____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Set__string____));
	*local3 = Set__create__string____();
	local1.globals__ = local3;
	*local0 = local1;
	GeneratorState__* s__ = local0;
	Set__add__string____((s__)->globals__, mu_____string231);
	Set__add__string____((s__)->globals__, mu_____string232);
	Set__add__string____((s__)->globals__, mu_____string233);
	Set__add__string____((s__)->globals__, mu_____string234);
	Set__add__string____((s__)->globals__, mu_____string18);
	Set__add__string____((s__)->globals__, mu_____string59);
	Set__add__string____((s__)->globals__, mu_____string14);
	Set__add__string____((s__)->globals__, mu_____string15);
	Set__add__string____((s__)->globals__, mu_____string147);
	Set__add__string____((s__)->globals__, mu_____string61);
	Set__add__string____((s__)->globals__, mu_____string235);
	Set__add__string____((s__)->globals__, mu_____string236);
	Set__add__string____((s__)->globals__, mu_____string237);
	Set__add__string____((s__)->globals__, mu_____string238);
	{
		List__Ptr__CodeUnit______* local4 = ((s__)->comp__)->units__;
		int__ local5 = 0;
		while (local5 < local4->count__) {
			CodeUnit__* u__ = ((CodeUnit__**)(local4->dataPtr__))[local5];
			{
				List__Node____* local6 = (u__)->contents__;
				int__ local7 = 0;
				while (local7 < local6->count__) {
					Node__ node__ = ((Node__*)(local6->dataPtr__))[local7];
					if ((node__).id__ == Node_____Ptr__ModuleDef____) {
						Node__ local8 = node__;
						mu_____checkedcast(local8.id__ == Node_____Ptr__ModuleDef____);
						ModuleDef__* def__ = (ModuleDef__*)(local8.dataPtr__);
						if (((def__)->blackboxKeyword__) != (null__)) {
							Set__tryAdd__string____((s__)->globals__, ((def__)->name__)->value__);
						}
					}
					local7 += 1;
				}
			}
			local5 += 1;
		}
	}
	{
		List__Ptr__ModuleInstance______* local9 = (es__)->moduleInstances__;
		int__ local10 = 0;
		while (local10 < local9->count__) {
			ModuleInstance__* mi__ = ((ModuleInstance__**)(local9->dataPtr__))[local10];
			if ((((mi__)->def__)->blackboxKeyword__) == (null__)) {
				Map__NodeWithCtx__string____* local11 = (Map__NodeWithCtx__string____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Map__NodeWithCtx__string____));
				*local11 = Map__create__NodeWithCtx__string____();
				(mi__)->genLocals__ = local11;
				Set__string____* local12 = (Set__string____*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(Set__string____));
				*local12 = Set__create__string____();
				(mi__)->genLocalsSet__ = local12;
				string__ local13;
				if (!string__equals__((mi__)->fullName__, mu_____string0)) {
					local13 = string__replace__((mi__)->fullName__, mu_____string35, mu_____string239);
				} else {
					local13 = (((mi__)->def__)->name__)->value__;
				}
				string__ name__ = local13;
				(mi__)->genGlobalName__ = VerilogGenerator__uniqueName__(s__, mi__, (s__)->globals__, name__);
			} else {
				(mi__)->genGlobalName__ = (((mi__)->def__)->name__)->value__;
			}
			local10 += 1;
		}
	}
	{
		List__Ptr__ModuleInstance______* local14 = (es__)->moduleInstances__;
		int__ local15 = 0;
		while (local15 < local14->count__) {
			ModuleInstance__* mi__ = ((ModuleInstance__**)(local14->dataPtr__))[local15];
			Set__tryRemove__string____((s__)->globals__, (mi__)->genGlobalName__);
			local15 += 1;
		}
	}
	StringBuilder__ local16;
	memset(&local16, 0, sizeof(local16));
	string__ local17 = { (pointer__)"// Generated by Wyre compiler ", 30 };
	StringBuilder__write__(&local16, local17);
	StringBuilder__write__(&local16, top_____compilerVersion__);
	string__ local18 = { (pointer__)"\x0a""", 1 };
	StringBuilder__write__(&local16, local18);
	VerilogGenerator__write__(s__, StringBuilder__compactToString__(&local16));
	{
		List__Ptr__ModuleInstance______* local19 = (es__)->moduleInstances__;
		int__ local20 = 0;
		while (local20 < local19->count__) {
			ModuleInstance__* mi__ = ((ModuleInstance__**)(local19->dataPtr__))[local20];
			if ((((mi__)->def__)->blackboxKeyword__) == (null__)) {
				VerilogGenerator__module__(s__, mi__);
			}
			local20 += 1;
		}
	}
	return (s__)->out__;
}
void__ VerilogGenerator__expression__(GeneratorState__* s__, Node__ e__) {
	Value__ val__ = Map__getOrDefault__Node__Value____((s__)->constMap__, e__);
	if (((val__).kind__) != (ValueKind__none__)) {
		bool__ local0 = (((s__)->evalCtxField__)) == ((-1));
		if (local0) {
			local0 = (((s__)->evalCtxOutput__)) == ((-1));
		}
		mu_____assert(local0);
		Tag__ tag__ = Map__get__Node__Tag____((s__)->typeMap__, e__);
		VerilogGenerator__value__(s__, tag__, val__);
	} else {
		VerilogGenerator__expressionInner__(s__, e__);
	}
}
void__ VerilogGenerator__match___(GeneratorState__* s__, MatchExpression__* e__) {
	CodeBuilder__* local0 = (CodeBuilder__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(CodeBuilder__));
	*local0 = CodeBuilder__create__();
	CodeBuilder__* eb__ = local0;
	CodeBuilder__* prev__ = VerilogGenerator__push__(s__, eb__);
	(s__)->isNonIndexable__ = false__;
	VerilogGenerator__expression__(s__, (e__)->target__);
	VerilogGenerator__restore__(s__, prev__);
	string__ target__ = mu_____string0;
	if (!((s__)->isNonIndexable__)) {
		target__ = StringBuilder__compactToString__((eb__)->sb__);
	} else {
		target__ = VerilogGenerator__newLocal__(s__, Map__get__Node__Tag____((s__)->typeMap__, (e__)->target__), StringBuilder__compactToString__((eb__)->sb__));
	}
	VerilogGenerator__indent__(s__, mu_____string0);
	{
		List__Ptr__MatchExpressionCase______* local1 = (e__)->cases__;
		int__ local2 = 0;
		while (local2 < local1->count__) {
			MatchExpressionCase__* cs__ = ((MatchExpressionCase__**)(local1->dataPtr__))[local2];
			VerilogGenerator__beginLine__(s__);
			VerilogGenerator__write__(s__, mu_____string267);
			VerilogGenerator__write__(s__, target__);
			VerilogGenerator__write__(s__, mu_____string268);
			VerilogGenerator__expression__(s__, (cs__)->valueExpr__);
			VerilogGenerator__write__(s__, mu_____string261);
			VerilogGenerator__expression__(s__, (cs__)->resultExpr__);
			VerilogGenerator__write__(s__, mu_____string269);
			local2 += 1;
		}
	}
	VerilogGenerator__write__(s__, mu_____string78);
	Node__ local3;
	local3.dataPtr__ = (pointer__)(e__);
	local3.id__ = local3.dataPtr__ != null__ ? Node_____Ptr__MatchExpression____ : 0;
	Tag__ resultTag__ = Map__get__Node__Tag____((s__)->typeMap__, local3);
	StringBuilder__ local4;
	memset(&local4, 0, sizeof(local4));
	int__writeTo__((resultTag__).q__, &local4);
	string__ local5 = { (pointer__)"'b", 2 };
	StringBuilder__write__(&local4, local5);
	StringBuilder__write__(&local4, string__repeatChar__('x', (resultTag__).q__));
	VerilogGenerator__write__(s__, StringBuilder__compactToString__(&local4));
	VerilogGenerator__write__(s__, string__repeatChar__(')', ((e__)->cases__)->count__));
	VerilogGenerator__unindent__(s__);
	(s__)->isNonIndexable__ = true__;
}
void__ VerilogGenerator__index__(GeneratorState__* s__, IndexExpression__* e__) {
	CodeBuilder__* local0 = (CodeBuilder__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(CodeBuilder__));
	*local0 = CodeBuilder__create__();
	CodeBuilder__* eb__ = local0;
	CodeBuilder__* prev__ = VerilogGenerator__push__(s__, eb__);
	(s__)->isNonIndexable__ = false__;
	VerilogGenerator__expression__(s__, (e__)->target__);
	VerilogGenerator__restore__(s__, prev__);
	if (!((s__)->isNonIndexable__)) {
		VerilogGenerator__write__(s__, StringBuilder__compactToString__((eb__)->sb__));
	} else {
		VerilogGenerator__write__(s__, VerilogGenerator__newLocal__(s__, Map__get__Node__Tag____((s__)->typeMap__, (e__)->target__), StringBuilder__compactToString__((eb__)->sb__)));
	}
	StringBuilder__* sb__ = ((s__)->out__)->sb__;
	StringBuilder__write__(sb__, mu_____string271);
	ulong__ upper__ = (Map__get__Node__Value____((s__)->constMap__, (e__)->upperExpr__)).z__;
	ulong__writeTo__(upper__, sb__);
	if ((((e__)->lowerExpr__).dataPtr__) != ((pointer__)(null__))) {
		StringBuilder__write__(sb__, mu_____string30);
		ulong__ lower__ = (Map__get__Node__Value____((s__)->constMap__, (e__)->lowerExpr__)).z__;
		ulong__writeTo__(lower__, sb__);
	}
	StringBuilder__write__(sb__, mu_____string34);
	(s__)->isNonIndexable__ = true__;
}
void__ VerilogGenerator__ternaryOperator__(GeneratorState__* s__, TernaryOperatorExpression__* e__) {
	(s__)->isNonIndexable__ = true__;
	VerilogGenerator__write__(s__, mu_____string73);
	VerilogGenerator__expression__(s__, (e__)->conditionExpr__);
	VerilogGenerator__write__(s__, mu_____string261);
	VerilogGenerator__expression__(s__, (e__)->trueExpr__);
	VerilogGenerator__write__(s__, mu_____string262);
	VerilogGenerator__expression__(s__, (e__)->falseExpr__);
	VerilogGenerator__write__(s__, mu_____string32);
}
void__ VerilogGenerator__token__(GeneratorState__* s__, Token__* e__) {
	string__ name__ = (e__)->value__;
	Node__ sym__ = Map__getOrDefault__string__Node____((((s__)->inst__)->def__)->symbols__, name__);
	if ((((s__)->evalCtxOutput__)) == ((-1))) {
		switch ((sym__).id__) {
			case Node_____Ptr__ModuleInputDef____: {
				ModuleInputDef__* local0 = (ModuleInputDef__*)(sym__.dataPtr__);
				{
					if (((((local0)->flags__)) & ((ModuleInputFlags__static__))) == (0)) {
						Node__ local1;
						local1.dataPtr__ = (pointer__)(local0);
						local1.id__ = local1.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
						VerilogGenerator__write__(s__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local1, -1, (s__)->evalCtxField__));
					} else {
						Node__ local2;
						local2.dataPtr__ = (pointer__)(local0);
						local2.id__ = local2.dataPtr__ != null__ ? Node_____Ptr__ModuleInputDef____ : 0;
						VerilogGenerator__staticValue__(s__, (s__)->inst__, (local0)->localId__, Map__get__Node__Tag____((s__)->typeMap__, local2));
					}
				}
				break;
			}
			case Node_____Ptr__AssignStatement____: {
				AssignStatement__* local3 = (AssignStatement__*)(sym__.dataPtr__);
				{
					if (((((local3)->flags__)) & ((AssignFlags__static__))) == (0)) {
						Node__ local4;
						local4.dataPtr__ = (pointer__)(local3);
						local4.id__ = local4.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
						VerilogGenerator__write__(s__, VerilogGenerator__nameOf__(s__, (s__)->inst__, local4, -1, (s__)->evalCtxField__));
					} else {
						Node__ local5;
						local5.dataPtr__ = (pointer__)(local3);
						local5.id__ = local5.dataPtr__ != null__ ? Node_____Ptr__AssignStatement____ : 0;
						VerilogGenerator__staticValue__(s__, (s__)->inst__, (local3)->localId__, Map__get__Node__Tag____((s__)->typeMap__, local5));
					}
				}
				break;
			}
			case 0:
			default: {
				mu_____nomatch();
			}
		}
	} else {
		Node__ local6 = sym__;
		mu_____checkedcast(local6.id__ == Node_____Ptr__AssignStatement____);
		AssignStatement__* assign__ = (AssignStatement__*)(local6.dataPtr__);
		mu_____assert(((assign__)->expr__).id__ == Node_____Ptr__CallExpression____);
		VerilogGenerator__expression__(s__, (assign__)->expr__);
	}
}
bool__ VerilogGenerator__hasStaticInputs__(GeneratorState__* s__, ModuleDef__* def__) {
	bool__ result__ = false__;
	{
		List__Ptr__ModuleInputDef______* local0 = (def__)->inputs__;
		int__ local1 = 0;
		while (local1 < local0->count__) {
			ModuleInputDef__* inp__ = ((ModuleInputDef__**)(local0->dataPtr__))[local1];
			bool__ local2 = result__;
			if (!local2) {
				local2 = ((((inp__)->flags__)) & ((ModuleInputFlags__static__))) != (0);
			}
			result__ = local2;
			local1 += 1;
		}
	}
	return result__;
}
void__ VerilogGenerator__beginLine__(GeneratorState__* s__) {
	if (!(((s__)->out__)->skipSep__)) {
		VerilogGenerator__write__(s__, ((s__)->out__)->lineSep__);
	} else {
		((s__)->out__)->skipSep__ = false__;
	}
	VerilogGenerator__write__(s__, mu_____string242);
	{
		int__ i__ = 0;
		while (((i__)) < ((((s__)->out__)->indent__))) {
			StringBuilder__writeChar__(((s__)->out__)->sb__, '\t');
			i__ += 1;
		}
	}
}
void__ VerilogGenerator__brace__(GeneratorState__* s__, BraceExpression__* e__) {
	(s__)->isNonIndexable__ = true__;
	VerilogGenerator__write__(s__, mu_____string272);
	bool__ sep__ = false__;
	{
		List__Node____* local0 = (e__)->args__;
		int__ local1 = 0;
		while (local1 < local0->count__) {
			Node__ arg__ = ((Node__*)(local0->dataPtr__))[local1];
			if (sep__) {
				VerilogGenerator__write__(s__, mu_____string197);
			} else {
				sep__ = true__;
			}
			VerilogGenerator__expression__(s__, arg__);
			local1 += 1;
		}
	}
	VerilogGenerator__write__(s__, mu_____string273);
}
void__ VerilogGenerator__staticValue__(GeneratorState__* s__, ModuleInstance__* instance__, int__ localId__, Tag__ tag__) {
	Array__int____* local0 = (instance__)->localState__;
	uint__ local1 = (uint__)(localId__);
	mu_____boundscheck(local1 < (uint__)local0->count__);
	int__ local2 = 0;
	int__ local3 = (s__)->evalCtxField__;
	int__ si__ = ((((int__*)local0->dataPtr__)[local1])) + (((local2 > local3) ? local2 : local3));
	List__Value____* local4 = ((s__)->es__)->rs__;
	uint__ local5 = (uint__)(si__);
	mu_____boundscheck(local5 < (uint__)local4->count__);
	VerilogGenerator__value__(s__, tag__, ((Value__*)local4->dataPtr__)[local5]);
}
void__ VerilogGenerator__input__(GeneratorState__* s__, ModuleInputDef__* inp__, string__ genName__, Tag__ tag__) {
	VerilogGenerator__beginLine__(s__);
	VerilogGenerator__write__(s__, mu_____string243);
	VerilogGenerator__numberTag__(s__, tag__);
	VerilogGenerator__write__(s__, genName__);
}
void__ VerilogGenerator__indent__(GeneratorState__* s__, string__ lineSep__) {
	((s__)->out__)->lineSep__ = lineSep__;
	((s__)->out__)->skipSep__ = true__;
	((s__)->out__)->indent__ = ((((s__)->out__)->indent__)) + ((1));
}
ModuleDef__* VerilogGenerator__unpackModule__(GeneratorState__* s__, Tag__ tag__) {
	mu_____assert(((tag__).kind__) == (TagKind__moduleOut__));
	List__Node____* local1 = (s__)->entities__;
	uint__ local2 = (uint__)((tag__).q__);
	mu_____boundscheck(local2 < (uint__)local1->count__);
	Node__ local0 = ((Node__*)local1->dataPtr__)[local2];
	mu_____checkedcast(local0.id__ == Node_____Ptr__ModuleDef____);
	return (ModuleDef__*)(local0.dataPtr__);
}
void__ Util__writeByteHexTo__(byte__ b__, StringBuilder__* sb__) {
	if (((int__)(b__)) < ((16))) {
		StringBuilder__write__(sb__, mu_____string1);
	}
	ulong__writeHexTo__((ulong__)(b__), sb__);
}
bool__ Util__arrayEquals__byte____(Array__byte____* a__, Array__byte____* b__) {
	if ((((a__)->count__)) != (((b__)->count__))) {
		return false__;
	}
	{
		int__ i__ = 0;
		while (((i__)) < (((a__)->count__))) {
			Array__byte____* local0 = a__;
			uint__ local1 = (uint__)(i__);
			mu_____boundscheck(local1 < (uint__)local0->count__);
			Array__byte____* local2 = b__;
			uint__ local3 = (uint__)(i__);
			mu_____boundscheck(local3 < (uint__)local2->count__);
			if (((int__)(((byte__*)local0->dataPtr__)[local1])) != ((int__)(((byte__*)local2->dataPtr__)[local3]))) {
				return false__;
			}
			i__ += 1;
		}
	}
	return true__;
}
bool__ Util__valEquals__(Value__ a__, Value__ b__) {
	if (((a__).kind__) != ((b__).kind__)) {
		return false__;
	}
	if (((a__).kind__) == (ValueKind__ulong___)) {
		return (((a__).z__)) == (((b__).z__));
	} else {
		if (((a__).kind__) == (ValueKind__byteArray__)) {
			bool__ local0 = (((a__).z__)) == (((b__).z__));
			if (!local0) {
				local0 = Util__arrayEquals__byte____(EmulatorRunner__unpackArray__(a__), EmulatorRunner__unpackArray__(b__));
			}
			return local0;
		} else {
			mu_____abandon(-1);
			return false__;
		}
	}
}
void__ Util__shlArray__(Array__byte____* a__, int__ n__) {
	bool__ local0 = ((0)) <= ((n__));
	if (local0) {
		local0 = ((n__)) < ((8));
	}
	mu_____assert(local0);
	if (((n__)) == ((0))) {
		return;
	}
	int__ m__ = ((8)) - ((n__));
	{
		int__ i__ = 0;
		while (((i__)) < (((((a__)->count__)) - ((1))))) {
			Array__byte____* local1 = a__;
			uint__ local2 = (uint__)(i__);
			mu_____boundscheck(local2 < (uint__)local1->count__);
			Array__byte____* local3 = a__;
			uint__ local4 = (uint__)(i__);
			mu_____boundscheck(local4 < (uint__)local3->count__);
			Array__byte____* local5 = a__;
			uint__ local6 = (uint__)(((i__)) + ((1)));
			mu_____boundscheck(local6 < (uint__)local5->count__);
			((byte__*)local1->dataPtr__)[local2] = (byte__)(((((uint__)((byte__*)local3->dataPtr__)[local4]) >> (n__))) | ((((uint__)((byte__*)local5->dataPtr__)[local6]) << (m__))));
			i__ += 1;
		}
	}
	Array__byte____* local7 = a__;
	uint__ local8 = (uint__)((((a__)->count__)) - ((1)));
	mu_____boundscheck(local8 < (uint__)local7->count__);
	Array__byte____* local9 = a__;
	uint__ local10 = (uint__)((((a__)->count__)) - ((1)));
	mu_____boundscheck(local10 < (uint__)local9->count__);
	((byte__*)local7->dataPtr__)[local8] = (byte__)(((uint__)((byte__*)local9->dataPtr__)[local10]) >> (n__));
}
Error__ Error__at__(CodeUnit__* unit__, IntRange__ span__, string__ text__) {
	mu_____assert((((span__).from__)) <= (((span__).to__)));
	Error__ local0;
	memset(&local0, 0, sizeof(Error__));
	local0.unit__ = unit__;
	local0.span__ = span__;
	local0.text__ = text__;
	return local0;
}
Error__ Error__atIndex__(CodeUnit__* unit__, int__ index__, string__ text__) {
	Error__ local0;
	memset(&local0, 0, sizeof(Error__));
	local0.unit__ = unit__;
	local0.span__ = IntRange__cons__(index__, index__);
	local0.text__ = text__;
	return local0;
}
CodeBuilder__ CodeBuilder__create__() {
	CodeBuilder__ local0;
	memset(&local0, 0, sizeof(CodeBuilder__));
	StringBuilder__* local1 = (StringBuilder__*)top_____currentAllocator__.allocFn__(top_____currentAllocator__.data__, sizeof(StringBuilder__));
	StringBuilder__ local2;
	memset(&local2, 0, sizeof(StringBuilder__));
	*local1 = local2;
	local0.sb__ = local1;
	return local0;
}
// ENTRYPOINT
int main(int argc, char** argv) {
	mu_____argc = argc;
	mu_____argv = (pointer__)argv;
	top_____main__();
	return 0;
}
